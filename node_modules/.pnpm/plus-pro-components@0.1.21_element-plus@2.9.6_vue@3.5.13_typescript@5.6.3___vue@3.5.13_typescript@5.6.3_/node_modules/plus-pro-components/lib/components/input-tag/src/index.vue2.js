'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vue = require('vue');
var elementPlus = require('element-plus');
require('../../../hooks/index.js');
require('../../utils/index.js');
var useLocale = require('../../../hooks/useLocale.js');
var is = require('../../utils/is.js');

var _sfc_main = /* @__PURE__ */ vue.defineComponent({
  ...{
    name: "PlusInputTag"
  },
  __name: "index",
  props: {
    modelValue: { default: () => [] },
    trigger: { default: () => ["blur", "enter", "space"] },
    inputProps: { default: () => ({}) },
    tagProps: { default: () => ({}) },
    limit: { default: Infinity },
    formatTag: { type: Function, default: void 0 },
    retainInputValue: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "change", "remove", "blur", "enter", "space"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const inputInstance = vue.ref();
    const tagInstance = vue.ref();
    const plusInputTagInstance = vue.ref();
    const state = vue.reactive({
      tags: [],
      inputValue: "",
      isFocus: false
    });
    const formDisabled = elementPlus.useFormDisabled();
    const { t } = useLocale.useLocale();
    vue.watch(
      () => props.modelValue,
      (val) => {
        state.tags = val.slice(0, props.limit);
      },
      { immediate: true }
    );
    const onClickOutside = () => {
      state.isFocus = false;
    };
    const handleClick = () => {
      var _a;
      state.isFocus = true;
      (_a = inputInstance.value) == null ? void 0 : _a.focus();
    };
    const handleClose = (tag) => {
      if (formDisabled.value) return;
      state.tags = state.tags.filter((item) => item !== tag);
      emit("remove", tag);
      emit("update:modelValue", state.tags);
      emit("change", state.tags);
    };
    const handleValue = () => {
      if (state.inputValue.trim() && !state.tags.includes(state.inputValue.trim()) && state.tags.length < props.limit) {
        state.tags.push(state.inputValue.trim());
      }
      if (!props.retainInputValue) {
        state.inputValue = "";
      }
      emit("update:modelValue", state.tags);
      emit("change", state.tags);
    };
    const handle = (event, type) => {
      emit(type, state.inputValue, event);
      const triggerList = is.isArray(props.trigger) ? props.trigger : is.isString(props.trigger) ? [props.trigger] : ["blur", "enter", "space"];
      if (triggerList.includes(type)) {
        handleValue();
      }
    };
    __expose({ inputInstance, tagInstance });
    return (_ctx, _cache) => {
      return vue.withDirectives((vue.openBlock(), vue.createElementBlock(
        "div",
        {
          ref_key: "plusInputTagInstance",
          ref: plusInputTagInstance,
          class: vue.normalizeClass(["plus-input-tag", {
            "is-focus": state.isFocus,
            "is-disabled": vue.unref(formDisabled)
          }]),
          onClick: handleClick
        },
        [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList(state.tags, (tag) => {
              return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElTag), vue.mergeProps({
                ref_for: true,
                ref_key: "tagInstance",
                ref: tagInstance,
                key: tag,
                class: "plus-input-tag__tag"
              }, _ctx.tagProps, {
                closable: "",
                onClose: ($event) => handleClose(tag)
              }), {
                default: vue.withCtx(() => [
                  vue.createTextVNode(
                    vue.toDisplayString(_ctx.formatTag && vue.unref(is.isFunction)(_ctx.formatTag) ? _ctx.formatTag(tag) : tag),
                    1
                    /* TEXT */
                  )
                ]),
                _: 2
                /* DYNAMIC */
              }, 1040, ["onClose"]);
            }),
            128
            /* KEYED_FRAGMENT */
          )),
          state.tags.length < _ctx.limit ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElInput), vue.mergeProps({
            key: 0,
            ref_key: "inputInstance",
            ref: inputInstance,
            modelValue: state.inputValue,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.inputValue = $event),
            class: "plus-input-tag__input",
            placeholder: state.tags.length ? "" : vue.unref(t)("plus.inputTag.placeholder"),
            disabled: vue.unref(formDisabled) || state.tags.length >= _ctx.limit
          }, _ctx.inputProps, {
            clearable: "",
            onBlur: _cache[1] || (_cache[1] = ($event) => handle($event, "blur")),
            onKeyup: [
              _cache[2] || (_cache[2] = vue.withKeys(vue.withModifiers(($event) => handle($event, "enter"), ["exact"]), ["enter"])),
              _cache[3] || (_cache[3] = vue.withKeys(vue.withModifiers(($event) => handle($event, "space"), ["exact"]), ["space"]))
            ]
          }), null, 16, ["modelValue", "placeholder", "disabled"])) : vue.createCommentVNode("v-if", true)
        ],
        2
        /* CLASS */
      )), [
        [vue.unref(elementPlus.ClickOutside), onClickOutside]
      ]);
    };
  }
});

exports.default = _sfc_main;
