'use strict';

var vue = require('vue');
require('../components/utils/index.js');
var lodashEs = require('lodash-es');
var is = require('../components/utils/is.js');

const throwError = (data) => {
  if (!is.isArray(data)) {
    console.error("Uncaught TypeError: ", `options expected Array but got ${is.toRawType(data)}`);
  }
};
const getOptionsByOptionsMap = (options, props) => {
  const optionsMap = props.optionsMap;
  const valueType = props.valueType;
  if (valueType === "cascader" || !is.isPlainObject(optionsMap)) {
    return options;
  }
  const data = options.map((item) => {
    const temp = lodashEs.cloneDeep(item);
    const label = optionsMap.label || "label";
    const value = optionsMap.value || "value";
    const __origin = {
      [label]: temp[label],
      [value]: temp[value]
    };
    optionsMap.label && Reflect.deleteProperty(temp, label);
    optionsMap.value && Reflect.deleteProperty(temp, value);
    return { ...temp, __origin, label: item[label], value: item[value] };
  });
  return data;
};
const useGetOptions = (props) => {
  const options = vue.ref([]);
  const optionsIsReady = vue.ref(false);
  if (!props.options) {
    options.value = [];
    optionsIsReady.value = true;
  } else if (vue.isRef(props.options) || vue.isReactive(props.options) || is.isArray(props.options)) {
    vue.watch(
      () => props.options,
      (val) => {
        const value = vue.isRef(val) ? val.value : val;
        options.value = getOptionsByOptionsMap(value, props);
        optionsIsReady.value = true;
      },
      {
        immediate: true,
        deep: true
      }
    );
  } else if (is.isFunction(props.options)) {
    const getValue = props.options;
    const result = getValue(props);
    if (is.isPromise(result)) {
      result.then((value) => {
        options.value = getOptionsByOptionsMap(value, props);
        optionsIsReady.value = true;
        throwError(options.value);
      }).catch((err) => {
        throw err;
      });
    } else {
      options.value = getOptionsByOptionsMap(result, props);
      optionsIsReady.value = true;
    }
  } else if (is.isPromise(props.options)) {
    const getValue = props.options;
    getValue.then((value) => {
      options.value = getOptionsByOptionsMap(value, props);
      optionsIsReady.value = true;
      throwError(options.value);
    }).catch((err) => {
      throw err;
    });
  } else {
    optionsIsReady.value = true;
    throwError(props.options);
  }
  return { customOptions: options, customOptionsIsReady: optionsIsReady };
};

exports.getOptionsByOptionsMap = getOptionsByOptionsMap;
exports.useGetOptions = useGetOptions;
