import { RadioGroupContext, FormItemContext } from 'element-plus';
import { LooseRequired } from '@vue/shared';
import { EpPropFinalized, EpPropMergeType } from 'element-plus/es/utils';
import { DefineComponent, Ref, CreateComponentPublicInstance, ExtractPropTypes, PropType, ComputedRef, WritableComputedRef, ComponentOptionsMixin, VNodeProps, AllowedComponentProps, ComponentCustomProps, PublicProps } from 'vue';
import { OptionsRow, PlusColumn, RecordType, RenderTypes } from 'plus-pro-components/es/types';

type ValueType = string | number | boolean;
export interface PlusRadioProps {
    modelValue?: ValueType;
    options: OptionsRow<RecordType>[];
    isCancel?: boolean;
    fieldSlots?: PlusColumn['fieldSlots'];
    fieldChildrenSlot?: PlusColumn['fieldChildrenSlot'];
}
export interface PlusRadioEmits {
    (e: 'change', value: ValueType): void;
    (e: 'update:modelValue', value: ValueType): void;
}
export interface RadioState {
    radio: ValueType;
}
declare const _default: DefineComponent<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<PlusRadioProps>, {
    modelValue: string;
    options: () => never[];
    isCancel: boolean;
    fieldSlots: undefined;
    fieldChildrenSlot: undefined;
}>, {
    radioInstance: Ref< CreateComponentPublicInstance<Readonly< ExtractPropTypes<{
        readonly border: BooleanConstructor;
        readonly modelValue: EpPropFinalized<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
        readonly size: {
            readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", never>>;
            readonly required: false;
            readonly validator: ((val: unknown) => boolean) | undefined;
            __epPropKey: true;
        };
        readonly disabled: BooleanConstructor;
        readonly label: EpPropFinalized<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
        readonly value: EpPropFinalized<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
        readonly name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    }>> & {
        onChange?: ((val: string | number | boolean | undefined) => any) | undefined;
        "onUpdate:modelValue"?: ((val: string | number | boolean | undefined) => any) | undefined;
    }, {
        props: Readonly< LooseRequired<Readonly< ExtractPropTypes<{
            readonly border: BooleanConstructor;
            readonly modelValue: EpPropFinalized<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
            readonly size: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", never>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly disabled: BooleanConstructor;
            readonly label: EpPropFinalized<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
            readonly value: EpPropFinalized<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
            readonly name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
        }>> & {
            onChange?: ((val: string | number | boolean | undefined) => any) | undefined;
            "onUpdate:modelValue"?: ((val: string | number | boolean | undefined) => any) | undefined;
        }>>;
        emit: ((event: "update:modelValue", val: string | number | boolean | undefined) => void) & ((event: "change", val: string | number | boolean | undefined) => void);
        ns: {
            namespace: ComputedRef<string>;
            b: (blockSuffix?: string | undefined) => string;
            e: (element?: string | undefined) => string;
            m: (modifier?: string | undefined) => string;
            be: (blockSuffix?: string | undefined, element?: string | undefined) => string;
            em: (element?: string | undefined, modifier?: string | undefined) => string;
            bm: (blockSuffix?: string | undefined, modifier?: string | undefined) => string;
            bem: (blockSuffix?: string | undefined, element?: string | undefined, modifier?: string | undefined) => string;
            is: {
                (name: string, state: boolean | undefined): string;
                (name: string): string;
            };
            cssVar: (object: Record<string, string>) => Record<string, string>;
            cssVarName: (name: string) => string;
            cssVarBlock: (object: Record<string, string>) => Record<string, string>;
            cssVarBlockName: (name: string) => string;
        };
        radioRef: Ref<HTMLInputElement | undefined>;
        radioGroup: RadioGroupContext | undefined;
        focus: Ref<boolean>;
        size: ComputedRef<"" | "default" | "small" | "large">;
        disabled: ComputedRef<boolean>;
        modelValue: WritableComputedRef< EpPropMergeType<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown> | undefined>;
        actualValue: ComputedRef< EpPropMergeType<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown> | undefined>;
        handleChange: () => void;
    }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
        "update:modelValue": (val: string | number | boolean | undefined) => boolean;
        change: (val: string | number | boolean | undefined) => boolean;
    }, VNodeProps & AllowedComponentProps & ComponentCustomProps & Readonly< ExtractPropTypes<{
        readonly border: BooleanConstructor;
        readonly modelValue: EpPropFinalized<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
        readonly size: {
            readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", never>>;
            readonly required: false;
            readonly validator: ((val: unknown) => boolean) | undefined;
            __epPropKey: true;
        };
        readonly disabled: BooleanConstructor;
        readonly label: EpPropFinalized<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
        readonly value: EpPropFinalized<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
        readonly name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    }>> & {
        onChange?: ((val: string | number | boolean | undefined) => any) | undefined;
        "onUpdate:modelValue"?: ((val: string | number | boolean | undefined) => any) | undefined;
    }, {
        readonly value: EpPropMergeType<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown>;
        readonly modelValue: EpPropMergeType<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown>;
        readonly label: EpPropMergeType<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown>;
        readonly disabled: boolean;
        readonly name: string;
        readonly border: boolean;
    }, true, {}, {}, {
        P: {};
        B: {};
        D: {};
        C: {};
        M: {};
        Defaults: {};
    }, Readonly< ExtractPropTypes<{
        readonly border: BooleanConstructor;
        readonly modelValue: EpPropFinalized<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
        readonly size: {
            readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", never>>;
            readonly required: false;
            readonly validator: ((val: unknown) => boolean) | undefined;
            __epPropKey: true;
        };
        readonly disabled: BooleanConstructor;
        readonly label: EpPropFinalized<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
        readonly value: EpPropFinalized<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
        readonly name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
    }>> & {
        onChange?: ((val: string | number | boolean | undefined) => any) | undefined;
        "onUpdate:modelValue"?: ((val: string | number | boolean | undefined) => any) | undefined;
    }, {
        props: Readonly< LooseRequired<Readonly< ExtractPropTypes<{
            readonly border: BooleanConstructor;
            readonly modelValue: EpPropFinalized<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
            readonly size: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", never>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly disabled: BooleanConstructor;
            readonly label: EpPropFinalized<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
            readonly value: EpPropFinalized<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown, undefined, boolean>;
            readonly name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
        }>> & {
            onChange?: ((val: string | number | boolean | undefined) => any) | undefined;
            "onUpdate:modelValue"?: ((val: string | number | boolean | undefined) => any) | undefined;
        }>>;
        emit: ((event: "update:modelValue", val: string | number | boolean | undefined) => void) & ((event: "change", val: string | number | boolean | undefined) => void);
        ns: {
            namespace: ComputedRef<string>;
            b: (blockSuffix?: string | undefined) => string;
            e: (element?: string | undefined) => string;
            m: (modifier?: string | undefined) => string;
            be: (blockSuffix?: string | undefined, element?: string | undefined) => string;
            em: (element?: string | undefined, modifier?: string | undefined) => string;
            bm: (blockSuffix?: string | undefined, modifier?: string | undefined) => string;
            bem: (blockSuffix?: string | undefined, element?: string | undefined, modifier?: string | undefined) => string;
            is: {
                (name: string, state: boolean | undefined): string;
                (name: string): string;
            };
            cssVar: (object: Record<string, string>) => Record<string, string>;
            cssVarName: (name: string) => string;
            cssVarBlock: (object: Record<string, string>) => Record<string, string>;
            cssVarBlockName: (name: string) => string;
        };
        radioRef: Ref<HTMLInputElement | undefined>;
        radioGroup: RadioGroupContext | undefined;
        focus: Ref<boolean>;
        size: ComputedRef<"" | "default" | "small" | "large">;
        disabled: ComputedRef<boolean>;
        modelValue: WritableComputedRef< EpPropMergeType<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown> | undefined>;
        actualValue: ComputedRef< EpPropMergeType<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown> | undefined>;
        handleChange: () => void;
    }, {}, {}, {}, {
        readonly value: EpPropMergeType<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown>;
        readonly modelValue: EpPropMergeType<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown>;
        readonly label: EpPropMergeType<(NumberConstructor | BooleanConstructor | StringConstructor)[], unknown, unknown>;
        readonly disabled: boolean;
        readonly name: string;
        readonly border: boolean;
    }> | null | undefined>;
    radioGroupInstance: Ref< CreateComponentPublicInstance<Readonly< ExtractPropTypes<{
        readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
        readonly size: {
            readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", never>>;
            readonly required: false;
            readonly validator: ((val: unknown) => boolean) | undefined;
            __epPropKey: true;
        };
        readonly disabled: BooleanConstructor;
        readonly modelValue: EpPropFinalized<readonly [StringConstructor, NumberConstructor, BooleanConstructor], unknown, unknown, undefined, boolean>;
        readonly fill: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
        readonly label: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
        readonly textColor: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
        readonly name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
        readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    }>> & {
        onChange?: ((val: string | number | boolean | undefined) => any) | undefined;
        "onUpdate:modelValue"?: ((val: string | number | boolean | undefined) => any) | undefined;
    }, {
        props: Readonly< LooseRequired<Readonly< ExtractPropTypes<{
            readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
            readonly size: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", never>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly disabled: BooleanConstructor;
            readonly modelValue: EpPropFinalized<readonly [StringConstructor, NumberConstructor, BooleanConstructor], unknown, unknown, undefined, boolean>;
            readonly fill: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
            readonly label: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
            readonly textColor: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
            readonly name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
            readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
        }>> & {
            onChange?: ((val: string | number | boolean | undefined) => any) | undefined;
            "onUpdate:modelValue"?: ((val: string | number | boolean | undefined) => any) | undefined;
        }>>;
        emit: ((event: "update:modelValue", val: string | number | boolean | undefined) => void) & ((event: "change", val: string | number | boolean | undefined) => void);
        ns: {
            namespace: ComputedRef<string>;
            b: (blockSuffix?: string | undefined) => string;
            e: (element?: string | undefined) => string;
            m: (modifier?: string | undefined) => string;
            be: (blockSuffix?: string | undefined, element?: string | undefined) => string;
            em: (element?: string | undefined, modifier?: string | undefined) => string;
            bm: (blockSuffix?: string | undefined, modifier?: string | undefined) => string;
            bem: (blockSuffix?: string | undefined, element?: string | undefined, modifier?: string | undefined) => string;
            is: {
                (name: string, state: boolean | undefined): string;
                (name: string): string;
            };
            cssVar: (object: Record<string, string>) => Record<string, string>;
            cssVarName: (name: string) => string;
            cssVarBlock: (object: Record<string, string>) => Record<string, string>;
            cssVarBlockName: (name: string) => string;
        };
        radioId: Ref<string>;
        radioGroupRef: Ref<HTMLDivElement | undefined>;
        formItem: FormItemContext | undefined;
        groupId: Ref<string | undefined>;
        isLabeledByFormItem: ComputedRef<boolean>;
        changeEvent: (value: EpPropMergeType<readonly [StringConstructor, NumberConstructor, BooleanConstructor], unknown, unknown> | undefined) => void;
        name: ComputedRef<string>;
    }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
        "update:modelValue": (val: string | number | boolean | undefined) => boolean;
        change: (val: string | number | boolean | undefined) => boolean;
    }, VNodeProps & AllowedComponentProps & ComponentCustomProps & Readonly< ExtractPropTypes<{
        readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
        readonly size: {
            readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", never>>;
            readonly required: false;
            readonly validator: ((val: unknown) => boolean) | undefined;
            __epPropKey: true;
        };
        readonly disabled: BooleanConstructor;
        readonly modelValue: EpPropFinalized<readonly [StringConstructor, NumberConstructor, BooleanConstructor], unknown, unknown, undefined, boolean>;
        readonly fill: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
        readonly label: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
        readonly textColor: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
        readonly name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
        readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    }>> & {
        onChange?: ((val: string | number | boolean | undefined) => any) | undefined;
        "onUpdate:modelValue"?: ((val: string | number | boolean | undefined) => any) | undefined;
    }, {
        readonly fill: string;
        readonly modelValue: EpPropMergeType<readonly [StringConstructor, NumberConstructor, BooleanConstructor], unknown, unknown>;
        readonly label: string;
        readonly id: string;
        readonly disabled: boolean;
        readonly name: string;
        readonly validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
        readonly textColor: string;
    }, true, {}, {}, {
        P: {};
        B: {};
        D: {};
        C: {};
        M: {};
        Defaults: {};
    }, Readonly< ExtractPropTypes<{
        readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
        readonly size: {
            readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", never>>;
            readonly required: false;
            readonly validator: ((val: unknown) => boolean) | undefined;
            __epPropKey: true;
        };
        readonly disabled: BooleanConstructor;
        readonly modelValue: EpPropFinalized<readonly [StringConstructor, NumberConstructor, BooleanConstructor], unknown, unknown, undefined, boolean>;
        readonly fill: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
        readonly label: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
        readonly textColor: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
        readonly name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
        readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
    }>> & {
        onChange?: ((val: string | number | boolean | undefined) => any) | undefined;
        "onUpdate:modelValue"?: ((val: string | number | boolean | undefined) => any) | undefined;
    }, {
        props: Readonly< LooseRequired<Readonly< ExtractPropTypes<{
            readonly id: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
            readonly size: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", never>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly disabled: BooleanConstructor;
            readonly modelValue: EpPropFinalized<readonly [StringConstructor, NumberConstructor, BooleanConstructor], unknown, unknown, undefined, boolean>;
            readonly fill: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
            readonly label: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
            readonly textColor: EpPropFinalized<StringConstructor, unknown, unknown, "", boolean>;
            readonly name: EpPropFinalized<StringConstructor, unknown, unknown, undefined, boolean>;
            readonly validateEvent: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
        }>> & {
            onChange?: ((val: string | number | boolean | undefined) => any) | undefined;
            "onUpdate:modelValue"?: ((val: string | number | boolean | undefined) => any) | undefined;
        }>>;
        emit: ((event: "update:modelValue", val: string | number | boolean | undefined) => void) & ((event: "change", val: string | number | boolean | undefined) => void);
        ns: {
            namespace: ComputedRef<string>;
            b: (blockSuffix?: string | undefined) => string;
            e: (element?: string | undefined) => string;
            m: (modifier?: string | undefined) => string;
            be: (blockSuffix?: string | undefined, element?: string | undefined) => string;
            em: (element?: string | undefined, modifier?: string | undefined) => string;
            bm: (blockSuffix?: string | undefined, modifier?: string | undefined) => string;
            bem: (blockSuffix?: string | undefined, element?: string | undefined, modifier?: string | undefined) => string;
            is: {
                (name: string, state: boolean | undefined): string;
                (name: string): string;
            };
            cssVar: (object: Record<string, string>) => Record<string, string>;
            cssVarName: (name: string) => string;
            cssVarBlock: (object: Record<string, string>) => Record<string, string>;
            cssVarBlockName: (name: string) => string;
        };
        radioId: Ref<string>;
        radioGroupRef: Ref<HTMLDivElement | undefined>;
        formItem: FormItemContext | undefined;
        groupId: Ref<string | undefined>;
        isLabeledByFormItem: ComputedRef<boolean>;
        changeEvent: (value: EpPropMergeType<readonly [StringConstructor, NumberConstructor, BooleanConstructor], unknown, unknown> | undefined) => void;
        name: ComputedRef<string>;
    }, {}, {}, {}, {
        readonly fill: string;
        readonly modelValue: EpPropMergeType<readonly [StringConstructor, NumberConstructor, BooleanConstructor], unknown, unknown>;
        readonly label: string;
        readonly id: string;
        readonly disabled: boolean;
        readonly name: string;
        readonly validateEvent: EpPropMergeType<BooleanConstructor, unknown, unknown>;
        readonly textColor: string;
    }> | null | undefined>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    change: (value: ValueType) => void;
    "update:modelValue": (value: ValueType) => void;
}, string, PublicProps, Readonly< ExtractPropTypes<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<PlusRadioProps>, {
    modelValue: string;
    options: () => never[];
    isCancel: boolean;
    fieldSlots: undefined;
    fieldChildrenSlot: undefined;
}>>> & {
    onChange?: ((value: ValueType) => any) | undefined;
    "onUpdate:modelValue"?: ((value: ValueType) => any) | undefined;
}, {
    modelValue: ValueType;
    options: OptionsRow<RecordType>[];
    fieldSlots: {
        [slotName: string]: (data?: any) => RenderTypes;
    };
    fieldChildrenSlot: (option?: OptionsRow<undefined> | undefined) => RenderTypes;
    isCancel: boolean;
}, {}>;
export default _default;
type __VLS_NonUndefinedable<T> = T extends undefined ? never : T;
type __VLS_TypePropsToRuntimeProps<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? {
        type: PropType<__VLS_NonUndefinedable<T[K]>>;
    } : {
        type: PropType<T[K]>;
        required: true;
    };
};
type __VLS_WithDefaults<P, D> = {
    [K in keyof Pick<P, keyof P>]: K extends keyof D ? __VLS_Prettify<P[K] & {
        default: D[K];
    }> : P[K];
};
type __VLS_Prettify<T> = {
    [K in keyof T]: T[K];
} & {};
