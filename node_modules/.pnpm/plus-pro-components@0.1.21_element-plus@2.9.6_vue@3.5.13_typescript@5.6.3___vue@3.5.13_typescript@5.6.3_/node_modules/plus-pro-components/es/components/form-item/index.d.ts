import { PlusFormItemProps } from './src/index.vue';
import { RuleItem } from 'async-validator';
import { LooseRequired } from '@vue/shared';
import { PlusRadioProps, PlusDatePickerProps, PlusInputTagProps } from 'plus-pro-components';
import { TimeSelectProps } from 'element-plus/es/components/time-select/src/time-select';
import { EpPropMergeType, EpPropFinalized, Arrayable } from 'element-plus/es/utils';
import { PropsItemType, Mutable, OmitTypes, CascaderProps, RecordType, TableValueType, OptionsType, FieldValueType, PlusColumn, RenderTypes, OptionsRow, FormItemValueType } from 'plus-pro-components';
import { ElTooltipProps, FormItemProps, ProgressFn, CascaderNode, InputAutoSize, AutocompleteProps, CheckboxGroupProps, ColorPickerProps, DatePickerProps, InputProps, InputNumberProps, RadioGroupProps, RateProps, ISelectProps, SliderProps, SwitchProps, TimePickerDefaultProps, TextProps, ImageProps, LinkProps, TagProps, ProgressProps, FormItemProp, FormItemRule, FormContext, FormItemContext, FormValidateFailure, FormValidateCallback, FormValidationResult } from 'element-plus';
import { CreateComponentPublicInstance, ExtractPropTypes, PropType, ComputedRef, CSSProperties, Ref, Slot, DefineComponent, ComponentOptionsMixin, VNodeProps, AllowedComponentProps, ComponentCustomProps, ComponentOptionsBase } from 'vue';
export type { PlusFormItemProps } from './src/index.vue';
export declare const PlusFormItem: {
    new (...args: any[]): CreateComponentPublicInstance<Readonly< ExtractPropTypes<{
        prop: {
            type: PropType<string>;
            required: true;
        };
        label: {
            type: PropType<string | ComputedRef<string>>;
            default: string;
        };
        index: {
            type: PropType<number>;
            default: number;
        };
        tooltip: {
            type: PropType<string | Partial< ElTooltipProps> | ComputedRef<string> | ComputedRef<Partial< ElTooltipProps>>>;
            default: string;
        };
        formItemProps: {
            type: PropType<PropsItemType< Mutable<FormItemProps> & {
                [key: string]: any;
                style?: CSSProperties | undefined;
            }>>;
            default: () => {};
        };
        fieldProps: {
            type: PropType<PropsItemType<Partial<{
                [key: string]: any;
                style: CSSProperties;
                rows: number;
                autocomplete: string;
                type: "" | "number" | "default" | "search" | "checkbox" | "radio" | "textarea" | "text" | "circle" | "color" | "button" | "success" | "warning" | "info" | "primary" | "danger" | "reset" | "submit" | "date" | "year" | "years" | "month" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "range" | "line" | "dashboard" | "hidden" | "time" | "image" | "datetime-local" | "email" | "file" | "password" | "tel" | "url";
                loading: EpPropMergeType<BooleanConstructor, unknown, unknown> | EpPropMergeType<StringConstructor, "lazy" | "eager", unknown> | undefined;
                step: string | number;
                format: string | ProgressFn | undefined;
                filterMethod: Function | ((node: CascaderNode, keyword: string) => boolean) | undefined;
                id: string | [string, string];
                effect: string;
                height: string | number;
                autosize: InputAutoSize;
            } & Mutable<Omit< AutocompleteProps, OmitTypes> & Omit< CascaderProps, OmitTypes> & Omit< CheckboxGroupProps, OmitTypes> & Omit< ColorPickerProps, OmitTypes> & Omit< DatePickerProps, OmitTypes> & Omit< InputProps, OmitTypes> & Omit< InputNumberProps, OmitTypes> & Omit< RadioGroupProps, OmitTypes> & Omit< RateProps, OmitTypes> & Omit< ISelectProps, OmitTypes> & Omit< SliderProps, OmitTypes> & Omit< SwitchProps, OmitTypes> & Omit< TimePickerDefaultProps, OmitTypes> & Omit< TimeSelectProps, OmitTypes> & Omit< PlusRadioProps, OmitTypes> & Omit< PlusDatePickerProps, OmitTypes> & Omit< PlusInputTagProps, OmitTypes> & Omit< TextProps, OmitTypes> & Omit< ImageProps, OmitTypes> & Omit< LinkProps, OmitTypes> & Omit< TagProps, OmitTypes> & Omit< ProgressProps, OmitTypes>>>>>;
            default: () => {};
        };
        hasLabel: {
            type: PropType<boolean | Ref<boolean> | ComputedRef<boolean>>;
            default: boolean;
        };
        modelValue: {
            type: PropType<string | number | boolean | RecordType | Date | string[] | boolean[] | number[] | Date[] | [Date, Date] | [number, number] | [string, string] | string[][] | number[][] | null>;
            default: string;
        };
        clearable: {
            type: PropType<boolean>;
            default: boolean;
        };
        valueType: {
            type: PropType< TableValueType | "autocomplete" | "cascader" | "checkbox" | "color-picker" | "date-picker" | "input-number" | "radio" | "rate" | "select" | "slider" | "switch" | "time-picker" | "time-select" | "textarea" | "input" | "text" | "plus-radio" | "plus-date-picker" | "plus-input-tag" | "transfer" | "tree-select" | "select-v2">;
            default: undefined;
        };
        options: {
            type: PropType<OptionsType>;
            default: () => never[];
        };
        renderField: {
            type: PropType<(value: FieldValueType, onChange: (value: FieldValueType) => void, props: PlusColumn) => RenderTypes>;
            default: undefined;
        };
        renderLabel: {
            type: PropType<(label: string, props: PlusColumn) => RenderTypes>;
            default: undefined;
        };
        fieldSlots: {
            type: PropType<{
                [slotName: string]: (data?: any) => RenderTypes;
            }>;
            default: () => {};
        };
        fieldChildrenSlot: {
            type: PropType<(option?: OptionsRow<undefined> | undefined) => RenderTypes>;
            default: undefined;
        };
        optionsMap: {
            type: PropType<{
                label?: string | undefined;
                value?: string | undefined;
            }>;
            default: undefined;
        };
    }>> & {
        onChange?: ((value: FieldValueType) => any) | undefined;
        "onUpdate:modelValue"?: ((value: FieldValueType) => any) | undefined;
    }, {
        formItemInstance: Ref< CreateComponentPublicInstance<Readonly< ExtractPropTypes<{
            readonly label: StringConstructor;
            readonly labelWidth: EpPropFinalized<readonly [StringConstructor, NumberConstructor], unknown, unknown, "", boolean>;
            readonly prop: {
                readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => FormItemProp) | ((new (...args: any[]) => string | string[]) | (() => FormItemProp))[], unknown, unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly required: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
            readonly rules: {
                readonly type: PropType<EpPropMergeType<(new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>) | ((new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>))[], unknown, unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly error: StringConstructor;
            readonly validateStatus: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "success" | "error" | "validating", unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly for: StringConstructor;
            readonly inlineMessage: EpPropFinalized<readonly [StringConstructor, BooleanConstructor], unknown, unknown, "", boolean>;
            readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
            readonly size: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
        }>>, {
            props: Readonly< LooseRequired<Readonly< ExtractPropTypes<{
                readonly label: StringConstructor;
                readonly labelWidth: EpPropFinalized<readonly [StringConstructor, NumberConstructor], unknown, unknown, "", boolean>;
                readonly prop: {
                    readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => FormItemProp) | ((new (...args: any[]) => string | string[]) | (() => FormItemProp))[], unknown, unknown>>;
                    readonly required: false;
                    readonly validator: ((val: unknown) => boolean) | undefined;
                    __epPropKey: true;
                };
                readonly required: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
                readonly rules: {
                    readonly type: PropType<EpPropMergeType<(new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>) | ((new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>))[], unknown, unknown>>;
                    readonly required: false;
                    readonly validator: ((val: unknown) => boolean) | undefined;
                    __epPropKey: true;
                };
                readonly error: StringConstructor;
                readonly validateStatus: {
                    readonly type: PropType<EpPropMergeType<StringConstructor, "" | "success" | "error" | "validating", unknown>>;
                    readonly required: false;
                    readonly validator: ((val: unknown) => boolean) | undefined;
                    __epPropKey: true;
                };
                readonly for: StringConstructor;
                readonly inlineMessage: EpPropFinalized<readonly [StringConstructor, BooleanConstructor], unknown, unknown, "", boolean>;
                readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
                readonly size: {
                    readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", unknown>>;
                    readonly required: false;
                    readonly validator: ((val: unknown) => boolean) | undefined;
                    __epPropKey: true;
                };
            }>> & {
                [x: `on${string}`]: ((...args: any[]) => any) | ((...args: unknown[]) => any) | undefined;
            }>>;
            slots: Readonly<{
                [name: string]: Slot<any> | undefined;
            }>;
            formContext: FormContext | undefined;
            parentFormItemContext: FormItemContext | undefined;
            _size: ComputedRef<"" | "default" | "small" | "large">;
            ns: {
                namespace: ComputedRef<string>;
                b: (blockSuffix?: string | undefined) => string;
                e: (element?: string | undefined) => string;
                m: (modifier?: string | undefined) => string;
                be: (blockSuffix?: string | undefined, element?: string | undefined) => string;
                em: (element?: string | undefined, modifier?: string | undefined) => string;
                bm: (blockSuffix?: string | undefined, modifier?: string | undefined) => string;
                bem: (blockSuffix?: string | undefined, element?: string | undefined, modifier?: string | undefined) => string;
                is: {
                    (name: string, state: boolean | undefined): string;
                    (name: string): string;
                };
                cssVar: (object: Record<string, string>) => Record<string, string>;
                cssVarName: (name: string) => string;
                cssVarBlock: (object: Record<string, string>) => Record<string, string>;
                cssVarBlockName: (name: string) => string;
            };
            labelId: string;
            inputIds: Ref<string[]>;
            validateState: Ref<"" | "success" | "error" | "validating">;
            validateStateDebounced: Readonly< Ref<"" | "success" | "error" | "validating">>;
            validateMessage: Ref<string>;
            formItemRef: Ref<HTMLDivElement | undefined>;
            initialValue: any;
            isResettingField: boolean;
            labelStyle: ComputedRef<CSSProperties>;
            contentStyle: ComputedRef<CSSProperties>;
            formItemClasses: ComputedRef<(string | {
                [x: string]: boolean | undefined;
            })[]>;
            _inlineMessage: ComputedRef<boolean>;
            validateClasses: ComputedRef<(string | {
                [x: string]: boolean;
            })[]>;
            propString: ComputedRef<string>;
            hasLabel: ComputedRef<boolean>;
            labelFor: ComputedRef<string | undefined>;
            isGroup: ComputedRef<boolean>;
            isNested: boolean;
            fieldValue: ComputedRef<any>;
            normalizedRules: ComputedRef< FormItemRule[]>;
            validateEnabled: ComputedRef<boolean>;
            getFilteredRule: (trigger: string) => RuleItem[];
            isRequired: ComputedRef<boolean>;
            shouldShowError: ComputedRef<EpPropMergeType<BooleanConstructor, unknown, unknown>>;
            currentLabel: ComputedRef<string>;
            setValidationState: (state: "" | "success" | "error" | "validating") => void;
            onValidationFailed: (error: FormValidateFailure) => void;
            onValidationSucceeded: () => void;
            doValidate: (rules: RuleItem[]) => Promise<true>;
            validate: (trigger: string, callback?: FormValidateCallback | undefined) => FormValidationResult;
            clearValidate: () => void;
            resetField: () => void;
            addInputId: (id: string) => void;
            removeInputId: (id: string) => void;
            context: FormItemContext;
            FormLabelWrap: DefineComponent<{
                isAutoWidth: BooleanConstructor;
                updateAll: BooleanConstructor;
            }, () => JSX.Element | null, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly< ExtractPropTypes<{
                isAutoWidth: BooleanConstructor;
                updateAll: BooleanConstructor;
            }>>, {
                isAutoWidth: boolean;
                updateAll: boolean;
            }, {}>;
        }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, VNodeProps & AllowedComponentProps & ComponentCustomProps & Readonly< ExtractPropTypes<{
            readonly label: StringConstructor;
            readonly labelWidth: EpPropFinalized<readonly [StringConstructor, NumberConstructor], unknown, unknown, "", boolean>;
            readonly prop: {
                readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => FormItemProp) | ((new (...args: any[]) => string | string[]) | (() => FormItemProp))[], unknown, unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly required: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
            readonly rules: {
                readonly type: PropType<EpPropMergeType<(new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>) | ((new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>))[], unknown, unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly error: StringConstructor;
            readonly validateStatus: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "success" | "error" | "validating", unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly for: StringConstructor;
            readonly inlineMessage: EpPropFinalized<readonly [StringConstructor, BooleanConstructor], unknown, unknown, "", boolean>;
            readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
            readonly size: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
        }>>, {
            readonly required: EpPropMergeType<BooleanConstructor, unknown, unknown>;
            readonly labelWidth: EpPropMergeType<readonly [StringConstructor, NumberConstructor], unknown, unknown>;
            readonly showMessage: EpPropMergeType<BooleanConstructor, unknown, unknown>;
            readonly inlineMessage: EpPropMergeType<readonly [StringConstructor, BooleanConstructor], unknown, unknown>;
        }, true, {}, {}, {
            P: {};
            B: {};
            D: {};
            C: {};
            M: {};
            Defaults: {};
        }, Readonly< ExtractPropTypes<{
            readonly label: StringConstructor;
            readonly labelWidth: EpPropFinalized<readonly [StringConstructor, NumberConstructor], unknown, unknown, "", boolean>;
            readonly prop: {
                readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => FormItemProp) | ((new (...args: any[]) => string | string[]) | (() => FormItemProp))[], unknown, unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly required: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
            readonly rules: {
                readonly type: PropType<EpPropMergeType<(new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>) | ((new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>))[], unknown, unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly error: StringConstructor;
            readonly validateStatus: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "success" | "error" | "validating", unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly for: StringConstructor;
            readonly inlineMessage: EpPropFinalized<readonly [StringConstructor, BooleanConstructor], unknown, unknown, "", boolean>;
            readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
            readonly size: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
        }>>, {
            props: Readonly< LooseRequired<Readonly< ExtractPropTypes<{
                readonly label: StringConstructor;
                readonly labelWidth: EpPropFinalized<readonly [StringConstructor, NumberConstructor], unknown, unknown, "", boolean>;
                readonly prop: {
                    readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => FormItemProp) | ((new (...args: any[]) => string | string[]) | (() => FormItemProp))[], unknown, unknown>>;
                    readonly required: false;
                    readonly validator: ((val: unknown) => boolean) | undefined;
                    __epPropKey: true;
                };
                readonly required: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
                readonly rules: {
                    readonly type: PropType<EpPropMergeType<(new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>) | ((new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>))[], unknown, unknown>>;
                    readonly required: false;
                    readonly validator: ((val: unknown) => boolean) | undefined;
                    __epPropKey: true;
                };
                readonly error: StringConstructor;
                readonly validateStatus: {
                    readonly type: PropType<EpPropMergeType<StringConstructor, "" | "success" | "error" | "validating", unknown>>;
                    readonly required: false;
                    readonly validator: ((val: unknown) => boolean) | undefined;
                    __epPropKey: true;
                };
                readonly for: StringConstructor;
                readonly inlineMessage: EpPropFinalized<readonly [StringConstructor, BooleanConstructor], unknown, unknown, "", boolean>;
                readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
                readonly size: {
                    readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", unknown>>;
                    readonly required: false;
                    readonly validator: ((val: unknown) => boolean) | undefined;
                    __epPropKey: true;
                };
            }>> & {
                [x: `on${string}`]: ((...args: any[]) => any) | ((...args: unknown[]) => any) | undefined;
            }>>;
            slots: Readonly<{
                [name: string]: Slot<any> | undefined;
            }>;
            formContext: FormContext | undefined;
            parentFormItemContext: FormItemContext | undefined;
            _size: ComputedRef<"" | "default" | "small" | "large">;
            ns: {
                namespace: ComputedRef<string>;
                b: (blockSuffix?: string | undefined) => string;
                e: (element?: string | undefined) => string;
                m: (modifier?: string | undefined) => string;
                be: (blockSuffix?: string | undefined, element?: string | undefined) => string;
                em: (element?: string | undefined, modifier?: string | undefined) => string;
                bm: (blockSuffix?: string | undefined, modifier?: string | undefined) => string;
                bem: (blockSuffix?: string | undefined, element?: string | undefined, modifier?: string | undefined) => string;
                is: {
                    (name: string, state: boolean | undefined): string;
                    (name: string): string;
                };
                cssVar: (object: Record<string, string>) => Record<string, string>;
                cssVarName: (name: string) => string;
                cssVarBlock: (object: Record<string, string>) => Record<string, string>;
                cssVarBlockName: (name: string) => string;
            };
            labelId: string;
            inputIds: Ref<string[]>;
            validateState: Ref<"" | "success" | "error" | "validating">;
            validateStateDebounced: Readonly< Ref<"" | "success" | "error" | "validating">>;
            validateMessage: Ref<string>;
            formItemRef: Ref<HTMLDivElement | undefined>;
            initialValue: any;
            isResettingField: boolean;
            labelStyle: ComputedRef<CSSProperties>;
            contentStyle: ComputedRef<CSSProperties>;
            formItemClasses: ComputedRef<(string | {
                [x: string]: boolean | undefined;
            })[]>;
            _inlineMessage: ComputedRef<boolean>;
            validateClasses: ComputedRef<(string | {
                [x: string]: boolean;
            })[]>;
            propString: ComputedRef<string>;
            hasLabel: ComputedRef<boolean>;
            labelFor: ComputedRef<string | undefined>;
            isGroup: ComputedRef<boolean>;
            isNested: boolean;
            fieldValue: ComputedRef<any>;
            normalizedRules: ComputedRef< FormItemRule[]>;
            validateEnabled: ComputedRef<boolean>;
            getFilteredRule: (trigger: string) => RuleItem[];
            isRequired: ComputedRef<boolean>;
            shouldShowError: ComputedRef<EpPropMergeType<BooleanConstructor, unknown, unknown>>;
            currentLabel: ComputedRef<string>;
            setValidationState: (state: "" | "success" | "error" | "validating") => void;
            onValidationFailed: (error: FormValidateFailure) => void;
            onValidationSucceeded: () => void;
            doValidate: (rules: RuleItem[]) => Promise<true>;
            validate: (trigger: string, callback?: FormValidateCallback | undefined) => FormValidationResult;
            clearValidate: () => void;
            resetField: () => void;
            addInputId: (id: string) => void;
            removeInputId: (id: string) => void;
            context: FormItemContext;
            FormLabelWrap: DefineComponent<{
                isAutoWidth: BooleanConstructor;
                updateAll: BooleanConstructor;
            }, () => JSX.Element | null, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly< ExtractPropTypes<{
                isAutoWidth: BooleanConstructor;
                updateAll: BooleanConstructor;
            }>>, {
                isAutoWidth: boolean;
                updateAll: boolean;
            }, {}>;
        }, {}, {}, {}, {
            readonly required: EpPropMergeType<BooleanConstructor, unknown, unknown>;
            readonly labelWidth: EpPropMergeType<readonly [StringConstructor, NumberConstructor], unknown, unknown>;
            readonly showMessage: EpPropMergeType<BooleanConstructor, unknown, unknown>;
            readonly inlineMessage: EpPropMergeType<readonly [StringConstructor, BooleanConstructor], unknown, unknown>;
        }> | null | undefined>;
        fieldInstance: Ref<any>;
    }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
        "update:modelValue": (value: FieldValueType) => void;
        change: (value: FieldValueType) => void;
    }, VNodeProps & AllowedComponentProps & ComponentCustomProps & Readonly< ExtractPropTypes<{
        prop: {
            type: PropType<string>;
            required: true;
        };
        label: {
            type: PropType<string | ComputedRef<string>>;
            default: string;
        };
        index: {
            type: PropType<number>;
            default: number;
        };
        tooltip: {
            type: PropType<string | Partial< ElTooltipProps> | ComputedRef<string> | ComputedRef<Partial< ElTooltipProps>>>;
            default: string;
        };
        formItemProps: {
            type: PropType<PropsItemType< Mutable<FormItemProps> & {
                [key: string]: any;
                style?: CSSProperties | undefined;
            }>>;
            default: () => {};
        };
        fieldProps: {
            type: PropType<PropsItemType<Partial<{
                [key: string]: any;
                style: CSSProperties;
                rows: number;
                autocomplete: string;
                type: "" | "number" | "default" | "search" | "checkbox" | "radio" | "textarea" | "text" | "circle" | "color" | "button" | "success" | "warning" | "info" | "primary" | "danger" | "reset" | "submit" | "date" | "year" | "years" | "month" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "range" | "line" | "dashboard" | "hidden" | "time" | "image" | "datetime-local" | "email" | "file" | "password" | "tel" | "url";
                loading: EpPropMergeType<BooleanConstructor, unknown, unknown> | EpPropMergeType<StringConstructor, "lazy" | "eager", unknown> | undefined;
                step: string | number;
                format: string | ProgressFn | undefined;
                filterMethod: Function | ((node: CascaderNode, keyword: string) => boolean) | undefined;
                id: string | [string, string];
                effect: string;
                height: string | number;
                autosize: InputAutoSize;
            } & Mutable<Omit< AutocompleteProps, OmitTypes> & Omit< CascaderProps, OmitTypes> & Omit< CheckboxGroupProps, OmitTypes> & Omit< ColorPickerProps, OmitTypes> & Omit< DatePickerProps, OmitTypes> & Omit< InputProps, OmitTypes> & Omit< InputNumberProps, OmitTypes> & Omit< RadioGroupProps, OmitTypes> & Omit< RateProps, OmitTypes> & Omit< ISelectProps, OmitTypes> & Omit< SliderProps, OmitTypes> & Omit< SwitchProps, OmitTypes> & Omit< TimePickerDefaultProps, OmitTypes> & Omit< TimeSelectProps, OmitTypes> & Omit< PlusRadioProps, OmitTypes> & Omit< PlusDatePickerProps, OmitTypes> & Omit< PlusInputTagProps, OmitTypes> & Omit< TextProps, OmitTypes> & Omit< ImageProps, OmitTypes> & Omit< LinkProps, OmitTypes> & Omit< TagProps, OmitTypes> & Omit< ProgressProps, OmitTypes>>>>>;
            default: () => {};
        };
        hasLabel: {
            type: PropType<boolean | Ref<boolean> | ComputedRef<boolean>>;
            default: boolean;
        };
        modelValue: {
            type: PropType<string | number | boolean | RecordType | Date | string[] | boolean[] | number[] | Date[] | [Date, Date] | [number, number] | [string, string] | string[][] | number[][] | null>;
            default: string;
        };
        clearable: {
            type: PropType<boolean>;
            default: boolean;
        };
        valueType: {
            type: PropType< TableValueType | "autocomplete" | "cascader" | "checkbox" | "color-picker" | "date-picker" | "input-number" | "radio" | "rate" | "select" | "slider" | "switch" | "time-picker" | "time-select" | "textarea" | "input" | "text" | "plus-radio" | "plus-date-picker" | "plus-input-tag" | "transfer" | "tree-select" | "select-v2">;
            default: undefined;
        };
        options: {
            type: PropType<OptionsType>;
            default: () => never[];
        };
        renderField: {
            type: PropType<(value: FieldValueType, onChange: (value: FieldValueType) => void, props: PlusColumn) => RenderTypes>;
            default: undefined;
        };
        renderLabel: {
            type: PropType<(label: string, props: PlusColumn) => RenderTypes>;
            default: undefined;
        };
        fieldSlots: {
            type: PropType<{
                [slotName: string]: (data?: any) => RenderTypes;
            }>;
            default: () => {};
        };
        fieldChildrenSlot: {
            type: PropType<(option?: OptionsRow<undefined> | undefined) => RenderTypes>;
            default: undefined;
        };
        optionsMap: {
            type: PropType<{
                label?: string | undefined;
                value?: string | undefined;
            }>;
            default: undefined;
        };
    }>> & {
        onChange?: ((value: FieldValueType) => any) | undefined;
        "onUpdate:modelValue"?: ((value: FieldValueType) => any) | undefined;
    }, {
        label: string | ComputedRef<string>;
        index: number;
        tooltip: string | Partial< ElTooltipProps> | ComputedRef<string> | ComputedRef<Partial< ElTooltipProps>>;
        formItemProps: PropsItemType< Mutable<FormItemProps> & {
            [key: string]: any;
            style?: CSSProperties | undefined;
        }>;
        fieldProps: PropsItemType<Partial<{
            [key: string]: any;
            style: CSSProperties;
            rows: number;
            autocomplete: string;
            type: "" | "number" | "default" | "search" | "checkbox" | "radio" | "textarea" | "text" | "circle" | "color" | "button" | "success" | "warning" | "info" | "primary" | "danger" | "reset" | "submit" | "date" | "year" | "years" | "month" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "range" | "line" | "dashboard" | "hidden" | "time" | "image" | "datetime-local" | "email" | "file" | "password" | "tel" | "url";
            loading: EpPropMergeType<BooleanConstructor, unknown, unknown> | EpPropMergeType<StringConstructor, "lazy" | "eager", unknown> | undefined;
            step: string | number;
            format: string | ProgressFn | undefined;
            filterMethod: Function | ((node: CascaderNode, keyword: string) => boolean) | undefined;
            id: string | [string, string];
            effect: string;
            height: string | number;
            autosize: InputAutoSize;
        } & Mutable<Omit< AutocompleteProps, OmitTypes> & Omit< CascaderProps, OmitTypes> & Omit< CheckboxGroupProps, OmitTypes> & Omit< ColorPickerProps, OmitTypes> & Omit< DatePickerProps, OmitTypes> & Omit< InputProps, OmitTypes> & Omit< InputNumberProps, OmitTypes> & Omit< RadioGroupProps, OmitTypes> & Omit< RateProps, OmitTypes> & Omit< ISelectProps, OmitTypes> & Omit< SliderProps, OmitTypes> & Omit< SwitchProps, OmitTypes> & Omit< TimePickerDefaultProps, OmitTypes> & Omit< TimeSelectProps, OmitTypes> & Omit< PlusRadioProps, OmitTypes> & Omit< PlusDatePickerProps, OmitTypes> & Omit< PlusInputTagProps, OmitTypes> & Omit< TextProps, OmitTypes> & Omit< ImageProps, OmitTypes> & Omit< LinkProps, OmitTypes> & Omit< TagProps, OmitTypes> & Omit< ProgressProps, OmitTypes>>>>;
        hasLabel: boolean | Ref<boolean> | ComputedRef<boolean>;
        modelValue: string | number | boolean | RecordType | Date | string[] | boolean[] | number[] | Date[] | [Date, Date] | [number, number] | [string, string] | string[][] | number[][] | null;
        clearable: boolean;
        valueType: TableValueType | "autocomplete" | "cascader" | "checkbox" | "color-picker" | "date-picker" | "input-number" | "radio" | "rate" | "select" | "slider" | "switch" | "time-picker" | "time-select" | "textarea" | "input" | "text" | "plus-radio" | "plus-date-picker" | "plus-input-tag" | "transfer" | "tree-select" | "select-v2";
        options: OptionsType;
        renderField: (value: FieldValueType, onChange: (value: FieldValueType) => void, props: PlusColumn) => RenderTypes;
        renderLabel: (label: string, props: PlusColumn) => RenderTypes;
        fieldSlots: {
            [slotName: string]: (data?: any) => RenderTypes;
        };
        fieldChildrenSlot: (option?: OptionsRow<undefined> | undefined) => RenderTypes;
        optionsMap: {
            label?: string | undefined;
            value?: string | undefined;
        };
    }, true, {}, {}, {
        P: {};
        B: {};
        D: {};
        C: {};
        M: {};
        Defaults: {};
    }, Readonly< ExtractPropTypes<{
        prop: {
            type: PropType<string>;
            required: true;
        };
        label: {
            type: PropType<string | ComputedRef<string>>;
            default: string;
        };
        index: {
            type: PropType<number>;
            default: number;
        };
        tooltip: {
            type: PropType<string | Partial< ElTooltipProps> | ComputedRef<string> | ComputedRef<Partial< ElTooltipProps>>>;
            default: string;
        };
        formItemProps: {
            type: PropType<PropsItemType< Mutable<FormItemProps> & {
                [key: string]: any;
                style?: CSSProperties | undefined;
            }>>;
            default: () => {};
        };
        fieldProps: {
            type: PropType<PropsItemType<Partial<{
                [key: string]: any;
                style: CSSProperties;
                rows: number;
                autocomplete: string;
                type: "" | "number" | "default" | "search" | "checkbox" | "radio" | "textarea" | "text" | "circle" | "color" | "button" | "success" | "warning" | "info" | "primary" | "danger" | "reset" | "submit" | "date" | "year" | "years" | "month" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "range" | "line" | "dashboard" | "hidden" | "time" | "image" | "datetime-local" | "email" | "file" | "password" | "tel" | "url";
                loading: EpPropMergeType<BooleanConstructor, unknown, unknown> | EpPropMergeType<StringConstructor, "lazy" | "eager", unknown> | undefined;
                step: string | number;
                format: string | ProgressFn | undefined;
                filterMethod: Function | ((node: CascaderNode, keyword: string) => boolean) | undefined;
                id: string | [string, string];
                effect: string;
                height: string | number;
                autosize: InputAutoSize;
            } & Mutable<Omit< AutocompleteProps, OmitTypes> & Omit< CascaderProps, OmitTypes> & Omit< CheckboxGroupProps, OmitTypes> & Omit< ColorPickerProps, OmitTypes> & Omit< DatePickerProps, OmitTypes> & Omit< InputProps, OmitTypes> & Omit< InputNumberProps, OmitTypes> & Omit< RadioGroupProps, OmitTypes> & Omit< RateProps, OmitTypes> & Omit< ISelectProps, OmitTypes> & Omit< SliderProps, OmitTypes> & Omit< SwitchProps, OmitTypes> & Omit< TimePickerDefaultProps, OmitTypes> & Omit< TimeSelectProps, OmitTypes> & Omit< PlusRadioProps, OmitTypes> & Omit< PlusDatePickerProps, OmitTypes> & Omit< PlusInputTagProps, OmitTypes> & Omit< TextProps, OmitTypes> & Omit< ImageProps, OmitTypes> & Omit< LinkProps, OmitTypes> & Omit< TagProps, OmitTypes> & Omit< ProgressProps, OmitTypes>>>>>;
            default: () => {};
        };
        hasLabel: {
            type: PropType<boolean | Ref<boolean> | ComputedRef<boolean>>;
            default: boolean;
        };
        modelValue: {
            type: PropType<string | number | boolean | RecordType | Date | string[] | boolean[] | number[] | Date[] | [Date, Date] | [number, number] | [string, string] | string[][] | number[][] | null>;
            default: string;
        };
        clearable: {
            type: PropType<boolean>;
            default: boolean;
        };
        valueType: {
            type: PropType< TableValueType | "autocomplete" | "cascader" | "checkbox" | "color-picker" | "date-picker" | "input-number" | "radio" | "rate" | "select" | "slider" | "switch" | "time-picker" | "time-select" | "textarea" | "input" | "text" | "plus-radio" | "plus-date-picker" | "plus-input-tag" | "transfer" | "tree-select" | "select-v2">;
            default: undefined;
        };
        options: {
            type: PropType<OptionsType>;
            default: () => never[];
        };
        renderField: {
            type: PropType<(value: FieldValueType, onChange: (value: FieldValueType) => void, props: PlusColumn) => RenderTypes>;
            default: undefined;
        };
        renderLabel: {
            type: PropType<(label: string, props: PlusColumn) => RenderTypes>;
            default: undefined;
        };
        fieldSlots: {
            type: PropType<{
                [slotName: string]: (data?: any) => RenderTypes;
            }>;
            default: () => {};
        };
        fieldChildrenSlot: {
            type: PropType<(option?: OptionsRow<undefined> | undefined) => RenderTypes>;
            default: undefined;
        };
        optionsMap: {
            type: PropType<{
                label?: string | undefined;
                value?: string | undefined;
            }>;
            default: undefined;
        };
    }>> & {
        onChange?: ((value: FieldValueType) => any) | undefined;
        "onUpdate:modelValue"?: ((value: FieldValueType) => any) | undefined;
    }, {
        formItemInstance: Ref< CreateComponentPublicInstance<Readonly< ExtractPropTypes<{
            readonly label: StringConstructor;
            readonly labelWidth: EpPropFinalized<readonly [StringConstructor, NumberConstructor], unknown, unknown, "", boolean>;
            readonly prop: {
                readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => FormItemProp) | ((new (...args: any[]) => string | string[]) | (() => FormItemProp))[], unknown, unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly required: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
            readonly rules: {
                readonly type: PropType<EpPropMergeType<(new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>) | ((new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>))[], unknown, unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly error: StringConstructor;
            readonly validateStatus: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "success" | "error" | "validating", unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly for: StringConstructor;
            readonly inlineMessage: EpPropFinalized<readonly [StringConstructor, BooleanConstructor], unknown, unknown, "", boolean>;
            readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
            readonly size: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
        }>>, {
            props: Readonly< LooseRequired<Readonly< ExtractPropTypes<{
                readonly label: StringConstructor;
                readonly labelWidth: EpPropFinalized<readonly [StringConstructor, NumberConstructor], unknown, unknown, "", boolean>;
                readonly prop: {
                    readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => FormItemProp) | ((new (...args: any[]) => string | string[]) | (() => FormItemProp))[], unknown, unknown>>;
                    readonly required: false;
                    readonly validator: ((val: unknown) => boolean) | undefined;
                    __epPropKey: true;
                };
                readonly required: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
                readonly rules: {
                    readonly type: PropType<EpPropMergeType<(new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>) | ((new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>))[], unknown, unknown>>;
                    readonly required: false;
                    readonly validator: ((val: unknown) => boolean) | undefined;
                    __epPropKey: true;
                };
                readonly error: StringConstructor;
                readonly validateStatus: {
                    readonly type: PropType<EpPropMergeType<StringConstructor, "" | "success" | "error" | "validating", unknown>>;
                    readonly required: false;
                    readonly validator: ((val: unknown) => boolean) | undefined;
                    __epPropKey: true;
                };
                readonly for: StringConstructor;
                readonly inlineMessage: EpPropFinalized<readonly [StringConstructor, BooleanConstructor], unknown, unknown, "", boolean>;
                readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
                readonly size: {
                    readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", unknown>>;
                    readonly required: false;
                    readonly validator: ((val: unknown) => boolean) | undefined;
                    __epPropKey: true;
                };
            }>> & {
                [x: `on${string}`]: ((...args: any[]) => any) | ((...args: unknown[]) => any) | undefined;
            }>>;
            slots: Readonly<{
                [name: string]: Slot<any> | undefined;
            }>;
            formContext: FormContext | undefined;
            parentFormItemContext: FormItemContext | undefined;
            _size: ComputedRef<"" | "default" | "small" | "large">;
            ns: {
                namespace: ComputedRef<string>;
                b: (blockSuffix?: string | undefined) => string;
                e: (element?: string | undefined) => string;
                m: (modifier?: string | undefined) => string;
                be: (blockSuffix?: string | undefined, element?: string | undefined) => string;
                em: (element?: string | undefined, modifier?: string | undefined) => string;
                bm: (blockSuffix?: string | undefined, modifier?: string | undefined) => string;
                bem: (blockSuffix?: string | undefined, element?: string | undefined, modifier?: string | undefined) => string;
                is: {
                    (name: string, state: boolean | undefined): string;
                    (name: string): string;
                };
                cssVar: (object: Record<string, string>) => Record<string, string>;
                cssVarName: (name: string) => string;
                cssVarBlock: (object: Record<string, string>) => Record<string, string>;
                cssVarBlockName: (name: string) => string;
            };
            labelId: string;
            inputIds: Ref<string[]>;
            validateState: Ref<"" | "success" | "error" | "validating">;
            validateStateDebounced: Readonly< Ref<"" | "success" | "error" | "validating">>;
            validateMessage: Ref<string>;
            formItemRef: Ref<HTMLDivElement | undefined>;
            initialValue: any;
            isResettingField: boolean;
            labelStyle: ComputedRef<CSSProperties>;
            contentStyle: ComputedRef<CSSProperties>;
            formItemClasses: ComputedRef<(string | {
                [x: string]: boolean | undefined;
            })[]>;
            _inlineMessage: ComputedRef<boolean>;
            validateClasses: ComputedRef<(string | {
                [x: string]: boolean;
            })[]>;
            propString: ComputedRef<string>;
            hasLabel: ComputedRef<boolean>;
            labelFor: ComputedRef<string | undefined>;
            isGroup: ComputedRef<boolean>;
            isNested: boolean;
            fieldValue: ComputedRef<any>;
            normalizedRules: ComputedRef< FormItemRule[]>;
            validateEnabled: ComputedRef<boolean>;
            getFilteredRule: (trigger: string) => RuleItem[];
            isRequired: ComputedRef<boolean>;
            shouldShowError: ComputedRef<EpPropMergeType<BooleanConstructor, unknown, unknown>>;
            currentLabel: ComputedRef<string>;
            setValidationState: (state: "" | "success" | "error" | "validating") => void;
            onValidationFailed: (error: FormValidateFailure) => void;
            onValidationSucceeded: () => void;
            doValidate: (rules: RuleItem[]) => Promise<true>;
            validate: (trigger: string, callback?: FormValidateCallback | undefined) => FormValidationResult;
            clearValidate: () => void;
            resetField: () => void;
            addInputId: (id: string) => void;
            removeInputId: (id: string) => void;
            context: FormItemContext;
            FormLabelWrap: DefineComponent<{
                isAutoWidth: BooleanConstructor;
                updateAll: BooleanConstructor;
            }, () => JSX.Element | null, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly< ExtractPropTypes<{
                isAutoWidth: BooleanConstructor;
                updateAll: BooleanConstructor;
            }>>, {
                isAutoWidth: boolean;
                updateAll: boolean;
            }, {}>;
        }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, VNodeProps & AllowedComponentProps & ComponentCustomProps & Readonly< ExtractPropTypes<{
            readonly label: StringConstructor;
            readonly labelWidth: EpPropFinalized<readonly [StringConstructor, NumberConstructor], unknown, unknown, "", boolean>;
            readonly prop: {
                readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => FormItemProp) | ((new (...args: any[]) => string | string[]) | (() => FormItemProp))[], unknown, unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly required: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
            readonly rules: {
                readonly type: PropType<EpPropMergeType<(new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>) | ((new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>))[], unknown, unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly error: StringConstructor;
            readonly validateStatus: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "success" | "error" | "validating", unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly for: StringConstructor;
            readonly inlineMessage: EpPropFinalized<readonly [StringConstructor, BooleanConstructor], unknown, unknown, "", boolean>;
            readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
            readonly size: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
        }>>, {
            readonly required: EpPropMergeType<BooleanConstructor, unknown, unknown>;
            readonly labelWidth: EpPropMergeType<readonly [StringConstructor, NumberConstructor], unknown, unknown>;
            readonly showMessage: EpPropMergeType<BooleanConstructor, unknown, unknown>;
            readonly inlineMessage: EpPropMergeType<readonly [StringConstructor, BooleanConstructor], unknown, unknown>;
        }, true, {}, {}, {
            P: {};
            B: {};
            D: {};
            C: {};
            M: {};
            Defaults: {};
        }, Readonly< ExtractPropTypes<{
            readonly label: StringConstructor;
            readonly labelWidth: EpPropFinalized<readonly [StringConstructor, NumberConstructor], unknown, unknown, "", boolean>;
            readonly prop: {
                readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => FormItemProp) | ((new (...args: any[]) => string | string[]) | (() => FormItemProp))[], unknown, unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly required: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
            readonly rules: {
                readonly type: PropType<EpPropMergeType<(new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>) | ((new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>))[], unknown, unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly error: StringConstructor;
            readonly validateStatus: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "success" | "error" | "validating", unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly for: StringConstructor;
            readonly inlineMessage: EpPropFinalized<readonly [StringConstructor, BooleanConstructor], unknown, unknown, "", boolean>;
            readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
            readonly size: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
        }>>, {
            props: Readonly< LooseRequired<Readonly< ExtractPropTypes<{
                readonly label: StringConstructor;
                readonly labelWidth: EpPropFinalized<readonly [StringConstructor, NumberConstructor], unknown, unknown, "", boolean>;
                readonly prop: {
                    readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => FormItemProp) | ((new (...args: any[]) => string | string[]) | (() => FormItemProp))[], unknown, unknown>>;
                    readonly required: false;
                    readonly validator: ((val: unknown) => boolean) | undefined;
                    __epPropKey: true;
                };
                readonly required: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
                readonly rules: {
                    readonly type: PropType<EpPropMergeType<(new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>) | ((new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>))[], unknown, unknown>>;
                    readonly required: false;
                    readonly validator: ((val: unknown) => boolean) | undefined;
                    __epPropKey: true;
                };
                readonly error: StringConstructor;
                readonly validateStatus: {
                    readonly type: PropType<EpPropMergeType<StringConstructor, "" | "success" | "error" | "validating", unknown>>;
                    readonly required: false;
                    readonly validator: ((val: unknown) => boolean) | undefined;
                    __epPropKey: true;
                };
                readonly for: StringConstructor;
                readonly inlineMessage: EpPropFinalized<readonly [StringConstructor, BooleanConstructor], unknown, unknown, "", boolean>;
                readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
                readonly size: {
                    readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", unknown>>;
                    readonly required: false;
                    readonly validator: ((val: unknown) => boolean) | undefined;
                    __epPropKey: true;
                };
            }>> & {
                [x: `on${string}`]: ((...args: any[]) => any) | ((...args: unknown[]) => any) | undefined;
            }>>;
            slots: Readonly<{
                [name: string]: Slot<any> | undefined;
            }>;
            formContext: FormContext | undefined;
            parentFormItemContext: FormItemContext | undefined;
            _size: ComputedRef<"" | "default" | "small" | "large">;
            ns: {
                namespace: ComputedRef<string>;
                b: (blockSuffix?: string | undefined) => string;
                e: (element?: string | undefined) => string;
                m: (modifier?: string | undefined) => string;
                be: (blockSuffix?: string | undefined, element?: string | undefined) => string;
                em: (element?: string | undefined, modifier?: string | undefined) => string;
                bm: (blockSuffix?: string | undefined, modifier?: string | undefined) => string;
                bem: (blockSuffix?: string | undefined, element?: string | undefined, modifier?: string | undefined) => string;
                is: {
                    (name: string, state: boolean | undefined): string;
                    (name: string): string;
                };
                cssVar: (object: Record<string, string>) => Record<string, string>;
                cssVarName: (name: string) => string;
                cssVarBlock: (object: Record<string, string>) => Record<string, string>;
                cssVarBlockName: (name: string) => string;
            };
            labelId: string;
            inputIds: Ref<string[]>;
            validateState: Ref<"" | "success" | "error" | "validating">;
            validateStateDebounced: Readonly< Ref<"" | "success" | "error" | "validating">>;
            validateMessage: Ref<string>;
            formItemRef: Ref<HTMLDivElement | undefined>;
            initialValue: any;
            isResettingField: boolean;
            labelStyle: ComputedRef<CSSProperties>;
            contentStyle: ComputedRef<CSSProperties>;
            formItemClasses: ComputedRef<(string | {
                [x: string]: boolean | undefined;
            })[]>;
            _inlineMessage: ComputedRef<boolean>;
            validateClasses: ComputedRef<(string | {
                [x: string]: boolean;
            })[]>;
            propString: ComputedRef<string>;
            hasLabel: ComputedRef<boolean>;
            labelFor: ComputedRef<string | undefined>;
            isGroup: ComputedRef<boolean>;
            isNested: boolean;
            fieldValue: ComputedRef<any>;
            normalizedRules: ComputedRef< FormItemRule[]>;
            validateEnabled: ComputedRef<boolean>;
            getFilteredRule: (trigger: string) => RuleItem[];
            isRequired: ComputedRef<boolean>;
            shouldShowError: ComputedRef<EpPropMergeType<BooleanConstructor, unknown, unknown>>;
            currentLabel: ComputedRef<string>;
            setValidationState: (state: "" | "success" | "error" | "validating") => void;
            onValidationFailed: (error: FormValidateFailure) => void;
            onValidationSucceeded: () => void;
            doValidate: (rules: RuleItem[]) => Promise<true>;
            validate: (trigger: string, callback?: FormValidateCallback | undefined) => FormValidationResult;
            clearValidate: () => void;
            resetField: () => void;
            addInputId: (id: string) => void;
            removeInputId: (id: string) => void;
            context: FormItemContext;
            FormLabelWrap: DefineComponent<{
                isAutoWidth: BooleanConstructor;
                updateAll: BooleanConstructor;
            }, () => JSX.Element | null, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly< ExtractPropTypes<{
                isAutoWidth: BooleanConstructor;
                updateAll: BooleanConstructor;
            }>>, {
                isAutoWidth: boolean;
                updateAll: boolean;
            }, {}>;
        }, {}, {}, {}, {
            readonly required: EpPropMergeType<BooleanConstructor, unknown, unknown>;
            readonly labelWidth: EpPropMergeType<readonly [StringConstructor, NumberConstructor], unknown, unknown>;
            readonly showMessage: EpPropMergeType<BooleanConstructor, unknown, unknown>;
            readonly inlineMessage: EpPropMergeType<readonly [StringConstructor, BooleanConstructor], unknown, unknown>;
        }> | null | undefined>;
        fieldInstance: Ref<any>;
    }, {}, {}, {}, {
        label: string | ComputedRef<string>;
        index: number;
        tooltip: string | Partial< ElTooltipProps> | ComputedRef<string> | ComputedRef<Partial< ElTooltipProps>>;
        formItemProps: PropsItemType< Mutable<FormItemProps> & {
            [key: string]: any;
            style?: CSSProperties | undefined;
        }>;
        fieldProps: PropsItemType<Partial<{
            [key: string]: any;
            style: CSSProperties;
            rows: number;
            autocomplete: string;
            type: "" | "number" | "default" | "search" | "checkbox" | "radio" | "textarea" | "text" | "circle" | "color" | "button" | "success" | "warning" | "info" | "primary" | "danger" | "reset" | "submit" | "date" | "year" | "years" | "month" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "range" | "line" | "dashboard" | "hidden" | "time" | "image" | "datetime-local" | "email" | "file" | "password" | "tel" | "url";
            loading: EpPropMergeType<BooleanConstructor, unknown, unknown> | EpPropMergeType<StringConstructor, "lazy" | "eager", unknown> | undefined;
            step: string | number;
            format: string | ProgressFn | undefined;
            filterMethod: Function | ((node: CascaderNode, keyword: string) => boolean) | undefined;
            id: string | [string, string];
            effect: string;
            height: string | number;
            autosize: InputAutoSize;
        } & Mutable<Omit< AutocompleteProps, OmitTypes> & Omit< CascaderProps, OmitTypes> & Omit< CheckboxGroupProps, OmitTypes> & Omit< ColorPickerProps, OmitTypes> & Omit< DatePickerProps, OmitTypes> & Omit< InputProps, OmitTypes> & Omit< InputNumberProps, OmitTypes> & Omit< RadioGroupProps, OmitTypes> & Omit< RateProps, OmitTypes> & Omit< ISelectProps, OmitTypes> & Omit< SliderProps, OmitTypes> & Omit< SwitchProps, OmitTypes> & Omit< TimePickerDefaultProps, OmitTypes> & Omit< TimeSelectProps, OmitTypes> & Omit< PlusRadioProps, OmitTypes> & Omit< PlusDatePickerProps, OmitTypes> & Omit< PlusInputTagProps, OmitTypes> & Omit< TextProps, OmitTypes> & Omit< ImageProps, OmitTypes> & Omit< LinkProps, OmitTypes> & Omit< TagProps, OmitTypes> & Omit< ProgressProps, OmitTypes>>>>;
        hasLabel: boolean | Ref<boolean> | ComputedRef<boolean>;
        modelValue: string | number | boolean | RecordType | Date | string[] | boolean[] | number[] | Date[] | [Date, Date] | [number, number] | [string, string] | string[][] | number[][] | null;
        clearable: boolean;
        valueType: TableValueType | "autocomplete" | "cascader" | "checkbox" | "color-picker" | "date-picker" | "input-number" | "radio" | "rate" | "select" | "slider" | "switch" | "time-picker" | "time-select" | "textarea" | "input" | "text" | "plus-radio" | "plus-date-picker" | "plus-input-tag" | "transfer" | "tree-select" | "select-v2";
        options: OptionsType;
        renderField: (value: FieldValueType, onChange: (value: FieldValueType) => void, props: PlusColumn) => RenderTypes;
        renderLabel: (label: string, props: PlusColumn) => RenderTypes;
        fieldSlots: {
            [slotName: string]: (data?: any) => RenderTypes;
        };
        fieldChildrenSlot: (option?: OptionsRow<undefined> | undefined) => RenderTypes;
        optionsMap: {
            label?: string | undefined;
            value?: string | undefined;
        };
    }>;
    __isFragment?: undefined;
    __isTeleport?: undefined;
    __isSuspense?: undefined;
} & ComponentOptionsBase<Readonly< ExtractPropTypes<{
    prop: {
        type: PropType<string>;
        required: true;
    };
    label: {
        type: PropType<string | ComputedRef<string>>;
        default: string;
    };
    index: {
        type: PropType<number>;
        default: number;
    };
    tooltip: {
        type: PropType<string | Partial< ElTooltipProps> | ComputedRef<string> | ComputedRef<Partial< ElTooltipProps>>>;
        default: string;
    };
    formItemProps: {
        type: PropType<PropsItemType< Mutable<FormItemProps> & {
            [key: string]: any;
            style?: CSSProperties | undefined;
        }>>;
        default: () => {};
    };
    fieldProps: {
        type: PropType<PropsItemType<Partial<{
            [key: string]: any;
            style: CSSProperties;
            rows: number;
            autocomplete: string;
            type: "" | "number" | "default" | "search" | "checkbox" | "radio" | "textarea" | "text" | "circle" | "color" | "button" | "success" | "warning" | "info" | "primary" | "danger" | "reset" | "submit" | "date" | "year" | "years" | "month" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "range" | "line" | "dashboard" | "hidden" | "time" | "image" | "datetime-local" | "email" | "file" | "password" | "tel" | "url";
            loading: EpPropMergeType<BooleanConstructor, unknown, unknown> | EpPropMergeType<StringConstructor, "lazy" | "eager", unknown> | undefined;
            step: string | number;
            format: string | ProgressFn | undefined;
            filterMethod: Function | ((node: CascaderNode, keyword: string) => boolean) | undefined;
            id: string | [string, string];
            effect: string;
            height: string | number;
            autosize: InputAutoSize;
        } & Mutable<Omit< AutocompleteProps, OmitTypes> & Omit< CascaderProps, OmitTypes> & Omit< CheckboxGroupProps, OmitTypes> & Omit< ColorPickerProps, OmitTypes> & Omit< DatePickerProps, OmitTypes> & Omit< InputProps, OmitTypes> & Omit< InputNumberProps, OmitTypes> & Omit< RadioGroupProps, OmitTypes> & Omit< RateProps, OmitTypes> & Omit< ISelectProps, OmitTypes> & Omit< SliderProps, OmitTypes> & Omit< SwitchProps, OmitTypes> & Omit< TimePickerDefaultProps, OmitTypes> & Omit< TimeSelectProps, OmitTypes> & Omit< PlusRadioProps, OmitTypes> & Omit< PlusDatePickerProps, OmitTypes> & Omit< PlusInputTagProps, OmitTypes> & Omit< TextProps, OmitTypes> & Omit< ImageProps, OmitTypes> & Omit< LinkProps, OmitTypes> & Omit< TagProps, OmitTypes> & Omit< ProgressProps, OmitTypes>>>>>;
        default: () => {};
    };
    hasLabel: {
        type: PropType<boolean | Ref<boolean> | ComputedRef<boolean>>;
        default: boolean;
    };
    modelValue: {
        type: PropType<string | number | boolean | RecordType | Date | string[] | boolean[] | number[] | Date[] | [Date, Date] | [number, number] | [string, string] | string[][] | number[][] | null>;
        default: string;
    };
    clearable: {
        type: PropType<boolean>;
        default: boolean;
    };
    valueType: {
        type: PropType< TableValueType | "autocomplete" | "cascader" | "checkbox" | "color-picker" | "date-picker" | "input-number" | "radio" | "rate" | "select" | "slider" | "switch" | "time-picker" | "time-select" | "textarea" | "input" | "text" | "plus-radio" | "plus-date-picker" | "plus-input-tag" | "transfer" | "tree-select" | "select-v2">;
        default: undefined;
    };
    options: {
        type: PropType<OptionsType>;
        default: () => never[];
    };
    renderField: {
        type: PropType<(value: FieldValueType, onChange: (value: FieldValueType) => void, props: PlusColumn) => RenderTypes>;
        default: undefined;
    };
    renderLabel: {
        type: PropType<(label: string, props: PlusColumn) => RenderTypes>;
        default: undefined;
    };
    fieldSlots: {
        type: PropType<{
            [slotName: string]: (data?: any) => RenderTypes;
        }>;
        default: () => {};
    };
    fieldChildrenSlot: {
        type: PropType<(option?: OptionsRow<undefined> | undefined) => RenderTypes>;
        default: undefined;
    };
    optionsMap: {
        type: PropType<{
            label?: string | undefined;
            value?: string | undefined;
        }>;
        default: undefined;
    };
}>> & {
    onChange?: ((value: FieldValueType) => any) | undefined;
    "onUpdate:modelValue"?: ((value: FieldValueType) => any) | undefined;
}, {
    formItemInstance: Ref< CreateComponentPublicInstance<Readonly< ExtractPropTypes<{
        readonly label: StringConstructor;
        readonly labelWidth: EpPropFinalized<readonly [StringConstructor, NumberConstructor], unknown, unknown, "", boolean>;
        readonly prop: {
            readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => FormItemProp) | ((new (...args: any[]) => string | string[]) | (() => FormItemProp))[], unknown, unknown>>;
            readonly required: false;
            readonly validator: ((val: unknown) => boolean) | undefined;
            __epPropKey: true;
        };
        readonly required: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
        readonly rules: {
            readonly type: PropType<EpPropMergeType<(new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>) | ((new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>))[], unknown, unknown>>;
            readonly required: false;
            readonly validator: ((val: unknown) => boolean) | undefined;
            __epPropKey: true;
        };
        readonly error: StringConstructor;
        readonly validateStatus: {
            readonly type: PropType<EpPropMergeType<StringConstructor, "" | "success" | "error" | "validating", unknown>>;
            readonly required: false;
            readonly validator: ((val: unknown) => boolean) | undefined;
            __epPropKey: true;
        };
        readonly for: StringConstructor;
        readonly inlineMessage: EpPropFinalized<readonly [StringConstructor, BooleanConstructor], unknown, unknown, "", boolean>;
        readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
        readonly size: {
            readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", unknown>>;
            readonly required: false;
            readonly validator: ((val: unknown) => boolean) | undefined;
            __epPropKey: true;
        };
    }>>, {
        props: Readonly< LooseRequired<Readonly< ExtractPropTypes<{
            readonly label: StringConstructor;
            readonly labelWidth: EpPropFinalized<readonly [StringConstructor, NumberConstructor], unknown, unknown, "", boolean>;
            readonly prop: {
                readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => FormItemProp) | ((new (...args: any[]) => string | string[]) | (() => FormItemProp))[], unknown, unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly required: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
            readonly rules: {
                readonly type: PropType<EpPropMergeType<(new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>) | ((new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>))[], unknown, unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly error: StringConstructor;
            readonly validateStatus: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "success" | "error" | "validating", unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly for: StringConstructor;
            readonly inlineMessage: EpPropFinalized<readonly [StringConstructor, BooleanConstructor], unknown, unknown, "", boolean>;
            readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
            readonly size: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
        }>> & {
            [x: `on${string}`]: ((...args: any[]) => any) | ((...args: unknown[]) => any) | undefined;
        }>>;
        slots: Readonly<{
            [name: string]: Slot<any> | undefined;
        }>;
        formContext: FormContext | undefined;
        parentFormItemContext: FormItemContext | undefined;
        _size: ComputedRef<"" | "default" | "small" | "large">;
        ns: {
            namespace: ComputedRef<string>;
            b: (blockSuffix?: string | undefined) => string;
            e: (element?: string | undefined) => string;
            m: (modifier?: string | undefined) => string;
            be: (blockSuffix?: string | undefined, element?: string | undefined) => string;
            em: (element?: string | undefined, modifier?: string | undefined) => string;
            bm: (blockSuffix?: string | undefined, modifier?: string | undefined) => string;
            bem: (blockSuffix?: string | undefined, element?: string | undefined, modifier?: string | undefined) => string;
            is: {
                (name: string, state: boolean | undefined): string;
                (name: string): string;
            };
            cssVar: (object: Record<string, string>) => Record<string, string>;
            cssVarName: (name: string) => string;
            cssVarBlock: (object: Record<string, string>) => Record<string, string>;
            cssVarBlockName: (name: string) => string;
        };
        labelId: string;
        inputIds: Ref<string[]>;
        validateState: Ref<"" | "success" | "error" | "validating">;
        validateStateDebounced: Readonly< Ref<"" | "success" | "error" | "validating">>;
        validateMessage: Ref<string>;
        formItemRef: Ref<HTMLDivElement | undefined>;
        initialValue: any;
        isResettingField: boolean;
        labelStyle: ComputedRef<CSSProperties>;
        contentStyle: ComputedRef<CSSProperties>;
        formItemClasses: ComputedRef<(string | {
            [x: string]: boolean | undefined;
        })[]>;
        _inlineMessage: ComputedRef<boolean>;
        validateClasses: ComputedRef<(string | {
            [x: string]: boolean;
        })[]>;
        propString: ComputedRef<string>;
        hasLabel: ComputedRef<boolean>;
        labelFor: ComputedRef<string | undefined>;
        isGroup: ComputedRef<boolean>;
        isNested: boolean;
        fieldValue: ComputedRef<any>;
        normalizedRules: ComputedRef< FormItemRule[]>;
        validateEnabled: ComputedRef<boolean>;
        getFilteredRule: (trigger: string) => RuleItem[];
        isRequired: ComputedRef<boolean>;
        shouldShowError: ComputedRef<EpPropMergeType<BooleanConstructor, unknown, unknown>>;
        currentLabel: ComputedRef<string>;
        setValidationState: (state: "" | "success" | "error" | "validating") => void;
        onValidationFailed: (error: FormValidateFailure) => void;
        onValidationSucceeded: () => void;
        doValidate: (rules: RuleItem[]) => Promise<true>;
        validate: (trigger: string, callback?: FormValidateCallback | undefined) => FormValidationResult;
        clearValidate: () => void;
        resetField: () => void;
        addInputId: (id: string) => void;
        removeInputId: (id: string) => void;
        context: FormItemContext;
        FormLabelWrap: DefineComponent<{
            isAutoWidth: BooleanConstructor;
            updateAll: BooleanConstructor;
        }, () => JSX.Element | null, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly< ExtractPropTypes<{
            isAutoWidth: BooleanConstructor;
            updateAll: BooleanConstructor;
        }>>, {
            isAutoWidth: boolean;
            updateAll: boolean;
        }, {}>;
    }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, VNodeProps & AllowedComponentProps & ComponentCustomProps & Readonly< ExtractPropTypes<{
        readonly label: StringConstructor;
        readonly labelWidth: EpPropFinalized<readonly [StringConstructor, NumberConstructor], unknown, unknown, "", boolean>;
        readonly prop: {
            readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => FormItemProp) | ((new (...args: any[]) => string | string[]) | (() => FormItemProp))[], unknown, unknown>>;
            readonly required: false;
            readonly validator: ((val: unknown) => boolean) | undefined;
            __epPropKey: true;
        };
        readonly required: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
        readonly rules: {
            readonly type: PropType<EpPropMergeType<(new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>) | ((new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>))[], unknown, unknown>>;
            readonly required: false;
            readonly validator: ((val: unknown) => boolean) | undefined;
            __epPropKey: true;
        };
        readonly error: StringConstructor;
        readonly validateStatus: {
            readonly type: PropType<EpPropMergeType<StringConstructor, "" | "success" | "error" | "validating", unknown>>;
            readonly required: false;
            readonly validator: ((val: unknown) => boolean) | undefined;
            __epPropKey: true;
        };
        readonly for: StringConstructor;
        readonly inlineMessage: EpPropFinalized<readonly [StringConstructor, BooleanConstructor], unknown, unknown, "", boolean>;
        readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
        readonly size: {
            readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", unknown>>;
            readonly required: false;
            readonly validator: ((val: unknown) => boolean) | undefined;
            __epPropKey: true;
        };
    }>>, {
        readonly required: EpPropMergeType<BooleanConstructor, unknown, unknown>;
        readonly labelWidth: EpPropMergeType<readonly [StringConstructor, NumberConstructor], unknown, unknown>;
        readonly showMessage: EpPropMergeType<BooleanConstructor, unknown, unknown>;
        readonly inlineMessage: EpPropMergeType<readonly [StringConstructor, BooleanConstructor], unknown, unknown>;
    }, true, {}, {}, {
        P: {};
        B: {};
        D: {};
        C: {};
        M: {};
        Defaults: {};
    }, Readonly< ExtractPropTypes<{
        readonly label: StringConstructor;
        readonly labelWidth: EpPropFinalized<readonly [StringConstructor, NumberConstructor], unknown, unknown, "", boolean>;
        readonly prop: {
            readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => FormItemProp) | ((new (...args: any[]) => string | string[]) | (() => FormItemProp))[], unknown, unknown>>;
            readonly required: false;
            readonly validator: ((val: unknown) => boolean) | undefined;
            __epPropKey: true;
        };
        readonly required: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
        readonly rules: {
            readonly type: PropType<EpPropMergeType<(new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>) | ((new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>))[], unknown, unknown>>;
            readonly required: false;
            readonly validator: ((val: unknown) => boolean) | undefined;
            __epPropKey: true;
        };
        readonly error: StringConstructor;
        readonly validateStatus: {
            readonly type: PropType<EpPropMergeType<StringConstructor, "" | "success" | "error" | "validating", unknown>>;
            readonly required: false;
            readonly validator: ((val: unknown) => boolean) | undefined;
            __epPropKey: true;
        };
        readonly for: StringConstructor;
        readonly inlineMessage: EpPropFinalized<readonly [StringConstructor, BooleanConstructor], unknown, unknown, "", boolean>;
        readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
        readonly size: {
            readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", unknown>>;
            readonly required: false;
            readonly validator: ((val: unknown) => boolean) | undefined;
            __epPropKey: true;
        };
    }>>, {
        props: Readonly< LooseRequired<Readonly< ExtractPropTypes<{
            readonly label: StringConstructor;
            readonly labelWidth: EpPropFinalized<readonly [StringConstructor, NumberConstructor], unknown, unknown, "", boolean>;
            readonly prop: {
                readonly type: PropType<EpPropMergeType<(new (...args: any[]) => string | string[]) | (() => FormItemProp) | ((new (...args: any[]) => string | string[]) | (() => FormItemProp))[], unknown, unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly required: EpPropFinalized<BooleanConstructor, unknown, unknown, undefined, boolean>;
            readonly rules: {
                readonly type: PropType<EpPropMergeType<(new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>) | ((new (...args: any[]) => FormItemRule | FormItemRule[]) | (() => Arrayable<FormItemRule>))[], unknown, unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly error: StringConstructor;
            readonly validateStatus: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "success" | "error" | "validating", unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
            readonly for: StringConstructor;
            readonly inlineMessage: EpPropFinalized<readonly [StringConstructor, BooleanConstructor], unknown, unknown, "", boolean>;
            readonly showMessage: EpPropFinalized<BooleanConstructor, unknown, unknown, true, boolean>;
            readonly size: {
                readonly type: PropType<EpPropMergeType<StringConstructor, "" | "default" | "small" | "large", unknown>>;
                readonly required: false;
                readonly validator: ((val: unknown) => boolean) | undefined;
                __epPropKey: true;
            };
        }>> & {
            [x: `on${string}`]: ((...args: any[]) => any) | ((...args: unknown[]) => any) | undefined;
        }>>;
        slots: Readonly<{
            [name: string]: Slot<any> | undefined;
        }>;
        formContext: FormContext | undefined;
        parentFormItemContext: FormItemContext | undefined;
        _size: ComputedRef<"" | "default" | "small" | "large">;
        ns: {
            namespace: ComputedRef<string>;
            b: (blockSuffix?: string | undefined) => string;
            e: (element?: string | undefined) => string;
            m: (modifier?: string | undefined) => string;
            be: (blockSuffix?: string | undefined, element?: string | undefined) => string;
            em: (element?: string | undefined, modifier?: string | undefined) => string;
            bm: (blockSuffix?: string | undefined, modifier?: string | undefined) => string;
            bem: (blockSuffix?: string | undefined, element?: string | undefined, modifier?: string | undefined) => string;
            is: {
                (name: string, state: boolean | undefined): string;
                (name: string): string;
            };
            cssVar: (object: Record<string, string>) => Record<string, string>;
            cssVarName: (name: string) => string;
            cssVarBlock: (object: Record<string, string>) => Record<string, string>;
            cssVarBlockName: (name: string) => string;
        };
        labelId: string;
        inputIds: Ref<string[]>;
        validateState: Ref<"" | "success" | "error" | "validating">;
        validateStateDebounced: Readonly< Ref<"" | "success" | "error" | "validating">>;
        validateMessage: Ref<string>;
        formItemRef: Ref<HTMLDivElement | undefined>;
        initialValue: any;
        isResettingField: boolean;
        labelStyle: ComputedRef<CSSProperties>;
        contentStyle: ComputedRef<CSSProperties>;
        formItemClasses: ComputedRef<(string | {
            [x: string]: boolean | undefined;
        })[]>;
        _inlineMessage: ComputedRef<boolean>;
        validateClasses: ComputedRef<(string | {
            [x: string]: boolean;
        })[]>;
        propString: ComputedRef<string>;
        hasLabel: ComputedRef<boolean>;
        labelFor: ComputedRef<string | undefined>;
        isGroup: ComputedRef<boolean>;
        isNested: boolean;
        fieldValue: ComputedRef<any>;
        normalizedRules: ComputedRef< FormItemRule[]>;
        validateEnabled: ComputedRef<boolean>;
        getFilteredRule: (trigger: string) => RuleItem[];
        isRequired: ComputedRef<boolean>;
        shouldShowError: ComputedRef<EpPropMergeType<BooleanConstructor, unknown, unknown>>;
        currentLabel: ComputedRef<string>;
        setValidationState: (state: "" | "success" | "error" | "validating") => void;
        onValidationFailed: (error: FormValidateFailure) => void;
        onValidationSucceeded: () => void;
        doValidate: (rules: RuleItem[]) => Promise<true>;
        validate: (trigger: string, callback?: FormValidateCallback | undefined) => FormValidationResult;
        clearValidate: () => void;
        resetField: () => void;
        addInputId: (id: string) => void;
        removeInputId: (id: string) => void;
        context: FormItemContext;
        FormLabelWrap: DefineComponent<{
            isAutoWidth: BooleanConstructor;
            updateAll: BooleanConstructor;
        }, () => JSX.Element | null, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly< ExtractPropTypes<{
            isAutoWidth: BooleanConstructor;
            updateAll: BooleanConstructor;
        }>>, {
            isAutoWidth: boolean;
            updateAll: boolean;
        }, {}>;
    }, {}, {}, {}, {
        readonly required: EpPropMergeType<BooleanConstructor, unknown, unknown>;
        readonly labelWidth: EpPropMergeType<readonly [StringConstructor, NumberConstructor], unknown, unknown>;
        readonly showMessage: EpPropMergeType<BooleanConstructor, unknown, unknown>;
        readonly inlineMessage: EpPropMergeType<readonly [StringConstructor, BooleanConstructor], unknown, unknown>;
    }> | null | undefined>;
    fieldInstance: Ref<any>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {
    "update:modelValue": (value: FieldValueType) => void;
    change: (value: FieldValueType) => void;
}, string, {
    label: string | ComputedRef<string>;
    index: number;
    tooltip: string | Partial< ElTooltipProps> | ComputedRef<string> | ComputedRef<Partial< ElTooltipProps>>;
    formItemProps: PropsItemType< Mutable<FormItemProps> & {
        [key: string]: any;
        style?: CSSProperties | undefined;
    }>;
    fieldProps: PropsItemType<Partial<{
        [key: string]: any;
        style: CSSProperties;
        rows: number;
        autocomplete: string;
        type: "" | "number" | "default" | "search" | "checkbox" | "radio" | "textarea" | "text" | "circle" | "color" | "button" | "success" | "warning" | "info" | "primary" | "danger" | "reset" | "submit" | "date" | "year" | "years" | "month" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "range" | "line" | "dashboard" | "hidden" | "time" | "image" | "datetime-local" | "email" | "file" | "password" | "tel" | "url";
        loading: EpPropMergeType<BooleanConstructor, unknown, unknown> | EpPropMergeType<StringConstructor, "lazy" | "eager", unknown> | undefined;
        step: string | number;
        format: string | ProgressFn | undefined;
        filterMethod: Function | ((node: CascaderNode, keyword: string) => boolean) | undefined;
        id: string | [string, string];
        effect: string;
        height: string | number;
        autosize: InputAutoSize;
    } & Mutable<Omit< AutocompleteProps, OmitTypes> & Omit< CascaderProps, OmitTypes> & Omit< CheckboxGroupProps, OmitTypes> & Omit< ColorPickerProps, OmitTypes> & Omit< DatePickerProps, OmitTypes> & Omit< InputProps, OmitTypes> & Omit< InputNumberProps, OmitTypes> & Omit< RadioGroupProps, OmitTypes> & Omit< RateProps, OmitTypes> & Omit< ISelectProps, OmitTypes> & Omit< SliderProps, OmitTypes> & Omit< SwitchProps, OmitTypes> & Omit< TimePickerDefaultProps, OmitTypes> & Omit< TimeSelectProps, OmitTypes> & Omit< PlusRadioProps, OmitTypes> & Omit< PlusDatePickerProps, OmitTypes> & Omit< PlusInputTagProps, OmitTypes> & Omit< TextProps, OmitTypes> & Omit< ImageProps, OmitTypes> & Omit< LinkProps, OmitTypes> & Omit< TagProps, OmitTypes> & Omit< ProgressProps, OmitTypes>>>>;
    hasLabel: boolean | Ref<boolean> | ComputedRef<boolean>;
    modelValue: string | number | boolean | RecordType | Date | string[] | boolean[] | number[] | Date[] | [Date, Date] | [number, number] | [string, string] | string[][] | number[][] | null;
    clearable: boolean;
    valueType: TableValueType | "autocomplete" | "cascader" | "checkbox" | "color-picker" | "date-picker" | "input-number" | "radio" | "rate" | "select" | "slider" | "switch" | "time-picker" | "time-select" | "textarea" | "input" | "text" | "plus-radio" | "plus-date-picker" | "plus-input-tag" | "transfer" | "tree-select" | "select-v2";
    options: OptionsType;
    renderField: (value: FieldValueType, onChange: (value: FieldValueType) => void, props: PlusColumn) => RenderTypes;
    renderLabel: (label: string, props: PlusColumn) => RenderTypes;
    fieldSlots: {
        [slotName: string]: (data?: any) => RenderTypes;
    };
    fieldChildrenSlot: (option?: OptionsRow<undefined> | undefined) => RenderTypes;
    optionsMap: {
        label?: string | undefined;
        value?: string | undefined;
    };
}, {}, string, {}> & VNodeProps & AllowedComponentProps & ComponentCustomProps & (new () => {
    $slots: Partial<Record<string, (_: {
        label: string;
        fieldProps: RecordType;
        formItemProps: RecordType;
        options: OptionsRow<undefined>[];
        fieldInstance?: any;
        valueIsReady?: Ref<boolean> | undefined;
        prop: string;
        modelValue: string | number | boolean | RecordType | Date | string[] | boolean[] | number[] | Date[] | [Date, Date] | [number, number] | [string, string] | string[][] | number[][] | null;
        hasLabel: boolean | Ref<boolean> | ComputedRef<boolean>;
        tooltip: string | Partial< ElTooltipProps> | ComputedRef<string> | ComputedRef<Partial< ElTooltipProps>>;
        fieldSlots: {
            [slotName: string]: (data?: any) => RenderTypes;
        };
        valueType: TableValueType | FormItemValueType;
        renderField: ((value: FieldValueType, onChange: (value: FieldValueType) => void, props: PlusColumn) => RenderTypes) | undefined;
        renderLabel: ((label: string, props: PlusColumn) => RenderTypes) | undefined;
        fieldChildrenSlot: ((option?: OptionsRow<undefined> | undefined) => RenderTypes) | undefined;
        optionsMap: {
            label?: string | undefined;
            value?: string | undefined;
        } | undefined;
        clearable: boolean;
        index: number;
    }) => any>> & Partial<Record<string, (_: {
        column: Readonly<Omit< LooseRequired<PlusFormItemProps>, "label" | "index" | "tooltip" | "formItemProps" | "fieldProps" | "hasLabel" | "modelValue" | "clearable" | "valueType" | "options" | "renderField" | "renderLabel" | "fieldSlots" | "fieldChildrenSlot" | "optionsMap">> & {
            readonly label: string | ComputedRef<string>;
            readonly modelValue: string | number | boolean | RecordType | Date | string[] | boolean[] | number[] | Date[] | [Date, Date] | [number, number] | [string, string] | string[][] | number[][] | null;
            readonly hasLabel: boolean | Ref<boolean> | ComputedRef<boolean>;
            readonly tooltip: string | Partial< ElTooltipProps> | ComputedRef<string> | ComputedRef<Partial< ElTooltipProps>>;
            readonly formItemProps: PropsItemType< Mutable<FormItemProps> & {
                [key: string]: any;
                style?: CSSProperties | undefined;
            }>;
            readonly fieldProps: PropsItemType<Partial<{
                [key: string]: any;
                style: CSSProperties;
                rows: number;
                autocomplete: string;
                type: "" | "number" | "default" | "search" | "checkbox" | "radio" | "textarea" | "text" | "circle" | "color" | "button" | "success" | "warning" | "info" | "primary" | "danger" | "reset" | "submit" | "date" | "year" | "years" | "month" | "dates" | "week" | "datetime" | "datetimerange" | "daterange" | "monthrange" | "range" | "line" | "dashboard" | "hidden" | "time" | "image" | "datetime-local" | "email" | "file" | "password" | "tel" | "url";
                loading: EpPropMergeType<BooleanConstructor, unknown, unknown> | EpPropMergeType<StringConstructor, "lazy" | "eager", unknown> | undefined;
                step: string | number;
                format: string | ProgressFn | undefined;
                filterMethod: Function | ((node: CascaderNode, keyword: string) => boolean) | undefined;
                id: string | [string, string];
                effect: string;
                height: string | number;
                autosize: InputAutoSize;
            } & Mutable<Omit< AutocompleteProps, OmitTypes> & Omit< CascaderProps, OmitTypes> & Omit< CheckboxGroupProps, OmitTypes> & Omit< ColorPickerProps, OmitTypes> & Omit< DatePickerProps, OmitTypes> & Omit< InputProps, OmitTypes> & Omit< InputNumberProps, OmitTypes> & Omit< RadioGroupProps, OmitTypes> & Omit< RateProps, OmitTypes> & Omit< ISelectProps, OmitTypes> & Omit< SliderProps, OmitTypes> & Omit< SwitchProps, OmitTypes> & Omit< TimePickerDefaultProps, OmitTypes> & Omit< TimeSelectProps, OmitTypes> & Omit< PlusRadioProps, OmitTypes> & Omit< PlusDatePickerProps, OmitTypes> & Omit< PlusInputTagProps, OmitTypes> & Omit< TextProps, OmitTypes> & Omit< ImageProps, OmitTypes> & Omit< LinkProps, OmitTypes> & Omit< TagProps, OmitTypes> & Omit< ProgressProps, OmitTypes>>>>;
            readonly options: OptionsType;
            readonly fieldSlots: {
                [slotName: string]: (data?: any) => RenderTypes;
            };
            readonly valueType: TableValueType | FormItemValueType;
            readonly renderField: ((value: FieldValueType, onChange: (value: FieldValueType) => void, props: PlusColumn) => RenderTypes) | undefined;
            readonly renderLabel: ((label: string, props: PlusColumn) => RenderTypes) | undefined;
            readonly fieldChildrenSlot: ((option?: OptionsRow<undefined> | undefined) => RenderTypes) | undefined;
            readonly optionsMap: {
                label?: string | undefined;
                value?: string | undefined;
            } | undefined;
            readonly clearable: boolean;
            readonly index: number;
        } & {
            readonly clearable: boolean;
        };
        label: string;
        fieldProps: RecordType;
        formItemProps: RecordType;
        options: OptionsRow<undefined>[];
        fieldInstance?: any;
        valueIsReady?: Ref<boolean> | undefined;
        prop: string;
        modelValue: string | number | boolean | RecordType | Date | string[] | boolean[] | number[] | Date[] | [Date, Date] | [number, number] | [string, string] | string[][] | number[][] | null;
        hasLabel: boolean | Ref<boolean> | ComputedRef<boolean>;
        tooltip: string | Partial< ElTooltipProps> | ComputedRef<string> | ComputedRef<Partial< ElTooltipProps>>;
        fieldSlots: {
            [slotName: string]: (data?: any) => RenderTypes;
        };
        valueType: TableValueType | FormItemValueType;
        renderField: ((value: FieldValueType, onChange: (value: FieldValueType) => void, props: PlusColumn) => RenderTypes) | undefined;
        renderLabel: ((label: string, props: PlusColumn) => RenderTypes) | undefined;
        fieldChildrenSlot: ((option?: OptionsRow<undefined> | undefined) => RenderTypes) | undefined;
        optionsMap: {
            label?: string | undefined;
            value?: string | undefined;
        } | undefined;
        clearable: boolean;
        index: number;
    }) => any>> & {
        "tooltip-icon"?(_: {}): any;
    };
});
