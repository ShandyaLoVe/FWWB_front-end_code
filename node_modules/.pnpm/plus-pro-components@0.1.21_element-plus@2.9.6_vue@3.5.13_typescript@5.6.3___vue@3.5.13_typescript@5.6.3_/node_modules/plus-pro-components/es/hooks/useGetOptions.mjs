import { ref, isRef, isReactive, watch } from 'vue';
import '../components/utils/index.mjs';
import { cloneDeep } from 'lodash-es';
import { isArray, toRawType, isPlainObject, isFunction, isPromise } from '../components/utils/is.mjs';

const throwError = (data) => {
  if (!isArray(data)) {
    console.error("Uncaught TypeError: ", `options expected Array but got ${toRawType(data)}`);
  }
};
const getOptionsByOptionsMap = (options, props) => {
  const optionsMap = props.optionsMap;
  const valueType = props.valueType;
  if (valueType === "cascader" || !isPlainObject(optionsMap)) {
    return options;
  }
  const data = options.map((item) => {
    const temp = cloneDeep(item);
    const label = optionsMap.label || "label";
    const value = optionsMap.value || "value";
    const __origin = {
      [label]: temp[label],
      [value]: temp[value]
    };
    optionsMap.label && Reflect.deleteProperty(temp, label);
    optionsMap.value && Reflect.deleteProperty(temp, value);
    return { ...temp, __origin, label: item[label], value: item[value] };
  });
  return data;
};
const useGetOptions = (props) => {
  const options = ref([]);
  const optionsIsReady = ref(false);
  if (!props.options) {
    options.value = [];
    optionsIsReady.value = true;
  } else if (isRef(props.options) || isReactive(props.options) || isArray(props.options)) {
    watch(
      () => props.options,
      (val) => {
        const value = isRef(val) ? val.value : val;
        options.value = getOptionsByOptionsMap(value, props);
        optionsIsReady.value = true;
      },
      {
        immediate: true,
        deep: true
      }
    );
  } else if (isFunction(props.options)) {
    const getValue = props.options;
    const result = getValue(props);
    if (isPromise(result)) {
      result.then((value) => {
        options.value = getOptionsByOptionsMap(value, props);
        optionsIsReady.value = true;
        throwError(options.value);
      }).catch((err) => {
        throw err;
      });
    } else {
      options.value = getOptionsByOptionsMap(result, props);
      optionsIsReady.value = true;
    }
  } else if (isPromise(props.options)) {
    const getValue = props.options;
    getValue.then((value) => {
      options.value = getOptionsByOptionsMap(value, props);
      optionsIsReady.value = true;
      throwError(options.value);
    }).catch((err) => {
      throw err;
    });
  } else {
    optionsIsReady.value = true;
    throwError(props.options);
  }
  return { customOptions: options, customOptionsIsReady: optionsIsReady };
};

export { getOptionsByOptionsMap, useGetOptions };
