/*! plus-pro-components v0.1.21 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue'), require('element-plus')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue', 'element-plus'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.PlusProComponents = {}, global.Vue, global.ElementPlus));
})(this, (function (exports, vue, elementPlus) { 'use strict';

  const makeInstaller = (components = []) => {
    const install = (app) => {
      components.forEach((component) => app.component(component.name, component));
    };
    return {
      install
    };
  };

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Built-in value references. */
  var Symbol$1 = root.Symbol;

  /** Used for built-in method references. */
  var objectProto$e = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$b = objectProto$e.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$e.toString;

  /** Built-in value references. */
  var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty$b.call(value, symToStringTag$1),
        tag = value[symToStringTag$1];

    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$d = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto$d.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString$1(value) {
    return nativeObjectToString.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? getRawTag(value)
      : objectToString$1(value);
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /** `Object#toString` result references. */
  var symbolTag$3 = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike(value) && baseGetTag(value) == symbolTag$3);
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray$1 = Array.isArray;

  /** Used as references for various `Number` constants. */
  var INFINITY$1 = 1 / 0;

  /** Used to convert symbols to primitives and strings. */
  var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : undefined,
      symbolToString = symbolProto$2 ? symbolProto$2.toString : undefined;

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isArray$1(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return arrayMap(value, baseToString) + '';
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
  }

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
      : string;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject$1(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject$1(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject$1(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex.test(value) ? NAN : +value);
  }

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * 
   * // => true
   */
  function identity(value) {
    return value;
  }

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag$2 = '[object Function]',
      genTag$1 = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$1(value) {
    if (!isObject$1(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
  }

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root['__core-js_shared__'];

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto = Function.prototype,
      objectProto$c = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$a = objectProto$c.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString.call(hasOwnProperty$a).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject$1(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue$1(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue$1(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /* Built-in method references that are verified to be native. */
  var WeakMap = getNative(root, 'WeakMap');

  /** Built-in value references. */
  var objectCreate = Object.create;

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate = (function() {
    function object() {}
    return function(proto) {
      if (!isObject$1(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object;
      object.prototype = undefined;
      return result;
    };
  }());

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
        length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  var defineProperty = (function() {
    try {
      var func = getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }());

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$1 : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty) {
      defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  /** Used for built-in method references. */
  var objectProto$b = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$9 = objectProto$b.hasOwnProperty;

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty$9.call(object, key) && eq(objValue, value)) ||
        (value === undefined && !(key in object))) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});

    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer
        ? customizer(object[key], source[key], key, object, source)
        : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction$1(value);
  }

  /** Used for built-in method references. */
  var objectProto$a = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$a;

    return value === proto;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /** `Object#toString` result references. */
  var argsTag$3 = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag$3;
  }

  /** Used for built-in method references. */
  var objectProto$9 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$8 = objectProto$9.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty$8.call(value, 'callee') &&
      !propertyIsEnumerable$1.call(value, 'callee');
  };

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  /** Detect free variable `exports`. */
  var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

  /** Built-in value references. */
  var Buffer$1 = moduleExports$2 ? root.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  /** `Object#toString` result references. */
  var argsTag$2 = '[object Arguments]',
      arrayTag$2 = '[object Array]',
      boolTag$3 = '[object Boolean]',
      dateTag$3 = '[object Date]',
      errorTag$2 = '[object Error]',
      funcTag$1 = '[object Function]',
      mapTag$5 = '[object Map]',
      numberTag$4 = '[object Number]',
      objectTag$3 = '[object Object]',
      regexpTag$3 = '[object RegExp]',
      setTag$5 = '[object Set]',
      stringTag$3 = '[object String]',
      weakMapTag$2 = '[object WeakMap]';

  var arrayBufferTag$3 = '[object ArrayBuffer]',
      dataViewTag$4 = '[object DataView]',
      float32Tag$2 = '[object Float32Array]',
      float64Tag$2 = '[object Float64Array]',
      int8Tag$2 = '[object Int8Array]',
      int16Tag$2 = '[object Int16Array]',
      int32Tag$2 = '[object Int32Array]',
      uint8Tag$2 = '[object Uint8Array]',
      uint8ClampedTag$2 = '[object Uint8ClampedArray]',
      uint16Tag$2 = '[object Uint16Array]',
      uint32Tag$2 = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
  typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
  typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
  typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
  typedArrayTags[uint32Tag$2] = true;
  typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] =
  typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] =
  typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] =
  typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] =
  typedArrayTags[mapTag$5] = typedArrayTags[numberTag$4] =
  typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$3] =
  typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] =
  typedArrayTags[weakMapTag$2] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike(value) &&
      isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /** Detect free variable `exports`. */
  var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports$1 && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  /** Used for built-in method references. */
  var objectProto$8 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray$1(value),
        isArg = !isArr && isArguments(value),
        isBuff = !isArr && !isArg && isBuffer(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$7.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeKeys = overArg(Object.keys, Object);

  /** Used for built-in method references. */
  var objectProto$7 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$6.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$6 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeysIn(object) {
    if (!isObject$1(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty$5.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;

  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */
  function isKey(value, object) {
    if (isArray$1(value)) {
      return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' ||
        value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
      (object != null && value in Object(object));
  }

  /* Built-in method references that are verified to be native. */
  var nativeCreate = getNative(Object, 'create');

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED$2 ? undefined : result;
    }
    return hasOwnProperty$4.call(data, key) ? data[key] : undefined;
  }

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$3.call(data, key);
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
    return this;
  }

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /* Built-in method references that are verified to be native. */
  var Map = getNative(root, 'Map');

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash,
      'map': new (Map || ListCache),
      'string': new Hash
    };
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /** Error message constants. */
  var FUNC_ERROR_TEXT$1 = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    var memoized = function() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
  }

  // Expose `MapCache`.
  memoize.Cache = MapCache;

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped(func) {
    var result = memoize(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });

    var cache = result.cache;
    return result;
  }

  /** Used to match property names within property paths. */
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
      result.push('');
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
    });
    return result;
  });

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */
  function castPath(value, object) {
    if (isArray$1(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
  }

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0;

  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */
  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
  }

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */
  function baseGet(object, path) {
    path = castPath(path, object);

    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return (index && index == length) ? object : undefined;
  }

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */
  function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /** Built-in value references. */
  var getPrototype = overArg(Object.getPrototypeOf, Object);

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new ListCache;
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  /**
   * The base implementation of `_.assign` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */
  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }

  /**
   * The base implementation of `_.assignIn` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */
  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
  }

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Built-in value references. */
  var Buffer = moduleExports ? root.Buffer : undefined,
      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

    buffer.copy(result);
    return result;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * 
   * // => [[], []]
   *
   * 
   * // => false
   */
  function stubArray() {
    return [];
  }

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };

  /**
   * Copies own symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols = Object.getOwnPropertySymbols;

  /**
   * Creates an array of the own and inherited enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
    var result = [];
    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }
    return result;
  };

  /**
   * Copies own and inherited symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */
  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
  }

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }

  /**
   * Creates an array of own and inherited enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  }

  /* Built-in method references that are verified to be native. */
  var DataView = getNative(root, 'DataView');

  /* Built-in method references that are verified to be native. */
  var Promise$1 = getNative(root, 'Promise');

  /* Built-in method references that are verified to be native. */
  var Set = getNative(root, 'Set');

  /** `Object#toString` result references. */
  var mapTag$4 = '[object Map]',
      objectTag$2 = '[object Object]',
      promiseTag = '[object Promise]',
      setTag$4 = '[object Set]',
      weakMapTag$1 = '[object WeakMap]';

  var dataViewTag$3 = '[object DataView]';

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map),
      promiseCtorString = toSource(Promise$1),
      setCtorString = toSource(Set),
      weakMapCtorString = toSource(WeakMap);

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$3) ||
      (Map && getTag(new Map) != mapTag$4) ||
      (Promise$1 && getTag(Promise$1.resolve()) != promiseTag) ||
      (Set && getTag(new Set) != setTag$4) ||
      (WeakMap && getTag(new WeakMap) != weakMapTag$1)) {
    getTag = function(value) {
      var result = baseGetTag(value),
          Ctor = result == objectTag$2 ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString: return dataViewTag$3;
          case mapCtorString: return mapTag$4;
          case promiseCtorString: return promiseTag;
          case setCtorString: return setTag$4;
          case weakMapCtorString: return weakMapTag$1;
        }
      }
      return result;
    };
  }

  var getTag$1 = getTag;

  /** Used for built-in method references. */
  var objectProto$2 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

  /**
   * Initializes an array clone.
   *
   * @private
   * @param {Array} array The array to clone.
   * @returns {Array} Returns the initialized clone.
   */
  function initCloneArray(array) {
    var length = array.length,
        result = new array.constructor(length);

    // Add properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == 'string' && hasOwnProperty$2.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }

  /** Built-in value references. */
  var Uint8Array = root.Uint8Array;

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }

  /**
   * Creates a clone of `dataView`.
   *
   * @private
   * @param {Object} dataView The data view to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned data view.
   */
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /**
   * Creates a clone of `regexp`.
   *
   * @private
   * @param {Object} regexp The regexp to clone.
   * @returns {Object} Returns the cloned regexp.
   */
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }

  /** Used to convert symbols to primitives and strings. */
  var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
      symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined;

  /**
   * Creates a clone of the `symbol` object.
   *
   * @private
   * @param {Object} symbol The symbol object to clone.
   * @returns {Object} Returns the cloned symbol object.
   */
  function cloneSymbol(symbol) {
    return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
  }

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  /** `Object#toString` result references. */
  var boolTag$2 = '[object Boolean]',
      dateTag$2 = '[object Date]',
      mapTag$3 = '[object Map]',
      numberTag$3 = '[object Number]',
      regexpTag$2 = '[object RegExp]',
      setTag$3 = '[object Set]',
      stringTag$2 = '[object String]',
      symbolTag$2 = '[object Symbol]';

  var arrayBufferTag$2 = '[object ArrayBuffer]',
      dataViewTag$2 = '[object DataView]',
      float32Tag$1 = '[object Float32Array]',
      float64Tag$1 = '[object Float64Array]',
      int8Tag$1 = '[object Int8Array]',
      int16Tag$1 = '[object Int16Array]',
      int32Tag$1 = '[object Int32Array]',
      uint8Tag$1 = '[object Uint8Array]',
      uint8ClampedTag$1 = '[object Uint8ClampedArray]',
      uint16Tag$1 = '[object Uint16Array]',
      uint32Tag$1 = '[object Uint32Array]';

  /**
   * Initializes an object clone based on its `toStringTag`.
   *
   * **Note:** This function only supports cloning values with tags of
   * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {string} tag The `toStringTag` of the object to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag$2:
        return cloneArrayBuffer(object);

      case boolTag$2:
      case dateTag$2:
        return new Ctor(+object);

      case dataViewTag$2:
        return cloneDataView(object, isDeep);

      case float32Tag$1: case float64Tag$1:
      case int8Tag$1: case int16Tag$1: case int32Tag$1:
      case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
        return cloneTypedArray(object, isDeep);

      case mapTag$3:
        return new Ctor;

      case numberTag$3:
      case stringTag$2:
        return new Ctor(object);

      case regexpTag$2:
        return cloneRegExp(object);

      case setTag$3:
        return new Ctor;

      case symbolTag$2:
        return cloneSymbol(object);
    }
  }

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject(object) {
    return (typeof object.constructor == 'function' && !isPrototype(object))
      ? baseCreate(getPrototype(object))
      : {};
  }

  /** `Object#toString` result references. */
  var mapTag$2 = '[object Map]';

  /**
   * The base implementation of `_.isMap` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   */
  function baseIsMap(value) {
    return isObjectLike(value) && getTag$1(value) == mapTag$2;
  }

  /* Node.js helper references. */
  var nodeIsMap = nodeUtil && nodeUtil.isMap;

  /**
   * Checks if `value` is classified as a `Map` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   * @example
   *
   * _.isMap(new Map);
   * // => true
   *
   * _.isMap(new WeakMap);
   * // => false
   */
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

  /** `Object#toString` result references. */
  var setTag$2 = '[object Set]';

  /**
   * The base implementation of `_.isSet` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   */
  function baseIsSet(value) {
    return isObjectLike(value) && getTag$1(value) == setTag$2;
  }

  /* Node.js helper references. */
  var nodeIsSet = nodeUtil && nodeUtil.isSet;

  /**
   * Checks if `value` is classified as a `Set` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   * @example
   *
   * _.isSet(new Set);
   * // => true
   *
   * _.isSet(new WeakSet);
   * // => false
   */
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG$1 = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG$1 = 4;

  /** `Object#toString` result references. */
  var argsTag$1 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      boolTag$1 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      errorTag$1 = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag$1 = '[object Map]',
      numberTag$2 = '[object Number]',
      objectTag$1 = '[object Object]',
      regexpTag$1 = '[object RegExp]',
      setTag$1 = '[object Set]',
      stringTag$1 = '[object String]',
      symbolTag$1 = '[object Symbol]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$1 = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] =
  cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] =
  cloneableTags[boolTag$1] = cloneableTags[dateTag$1] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag$1] =
  cloneableTags[numberTag$2] = cloneableTags[objectTag$1] =
  cloneableTags[regexpTag$1] = cloneableTags[setTag$1] =
  cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag$1] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /**
   * The base implementation of `_.clone` and `_.cloneDeep` which tracks
   * traversed objects.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Deep clone
   *  2 - Flatten inherited properties
   *  4 - Clone symbols
   * @param {Function} [customizer] The function to customize cloning.
   * @param {string} [key] The key of `value`.
   * @param {Object} [object] The parent object of `value`.
   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
   * @returns {*} Returns the cloned value.
   */
  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result,
        isDeep = bitmask & CLONE_DEEP_FLAG$1,
        isFlat = bitmask & CLONE_FLAT_FLAG,
        isFull = bitmask & CLONE_SYMBOLS_FLAG$1;

    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== undefined) {
      return result;
    }
    if (!isObject$1(value)) {
      return value;
    }
    var isArr = isArray$1(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag$1(value),
          isFunc = tag == funcTag || tag == genTag;

      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag$1 || tag == argsTag$1 || (isFunc && !object)) {
        result = (isFlat || isFunc) ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat
            ? copySymbolsIn(value, baseAssignIn(result, value))
            : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack);
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);

    if (isSet(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap(value)) {
      value.forEach(function(subValue, key) {
        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
    }

    var keysFunc = isFull
      ? (isFlat ? getAllKeysIn : getAllKeys)
      : (isFlat ? keysIn : keys);

    var props = isArr ? undefined : keysFunc(value);
    arrayEach(props || value, function(subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      }
      // Recursively populate clone (susceptible to call stack limits).
      assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
  }

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_SYMBOLS_FLAG = 4;

  /**
   * This method is like `_.clone` except that it recursively clones `value`.
   *
   * @static
   * @memberOf _
   * @since 1.0.0
   * @category Lang
   * @param {*} value The value to recursively clone.
   * @returns {*} Returns the deep cloned value.
   * @see _.clone
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var deep = _.cloneDeep(objects);
   * 
   * // => false
   */
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */
  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;

    this.__data__ = new MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }

  // Add methods to `SetCache`.
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$5 = 1,
      COMPARE_UNORDERED_FLAG$3 = 2;

  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    // Check that cyclic values are equal.
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index = -1,
        result = true,
        seen = (bitmask & COMPARE_UNORDERED_FLAG$3) ? new SetCache : undefined;

    stack.set(array, other);
    stack.set(other, array);

    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, arrValue, index, other, array, stack)
          : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (seen) {
        if (!arraySome(other, function(othValue, othIndex) {
              if (!cacheHas(seen, othIndex) &&
                  (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
          result = false;
          break;
        }
      } else if (!(
            arrValue === othValue ||
              equalFunc(arrValue, othValue, bitmask, customizer, stack)
          )) {
        result = false;
        break;
      }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$4 = 1,
      COMPARE_UNORDERED_FLAG$2 = 2;

  /** `Object#toString` result references. */
  var boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      mapTag = '[object Map]',
      numberTag$1 = '[object Number]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]';

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if ((object.byteLength != other.byteLength) ||
            (object.byteOffset != other.byteOffset)) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag:
        if ((object.byteLength != other.byteLength) ||
            !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }
        return true;

      case boolTag:
      case dateTag:
      case numberTag$1:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq(+object, +other);

      case errorTag:
        return object.name == other.name && object.message == other.message;

      case regexpTag:
      case stringTag:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == (other + '');

      case mapTag:
        var convert = mapToArray;

      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
        convert || (convert = setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG$2;

        // Recursively compare objects (susceptible to call stack limits).
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$3 = 1;

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
        objProps = getAllKeys(object),
        objLength = objProps.length,
        othProps = getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
        return false;
      }
    }
    // Check that cyclic values are equal.
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);

    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, objValue, key, other, object, stack)
          : customizer(objValue, othValue, key, object, other, stack);
      }
      // Recursively compare objects (susceptible to call stack limits).
      if (!(compared === undefined
            ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
            : compared
          )) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor &&
          ('constructor' in object && 'constructor' in other) &&
          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$2 = 1;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      objectTag = '[object Object]';

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray$1(object),
        othIsArr = isArray$1(other),
        objTag = objIsArr ? arrayTag : getTag$1(object),
        othTag = othIsArr ? arrayTag : getTag$1(other);

    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;

    var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack);
      return (objIsArr || isTypedArray(object))
        ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
        : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;

        stack || (stack = new Stack);
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack);
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$1 = 1,
      COMPARE_UNORDERED_FLAG$1 = 2;

  /**
   * The base implementation of `_.isMatch` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Object} source The object of property values to match.
   * @param {Array} matchData The property names, values, and compare flags to match.
   * @param {Function} [customizer] The function to customize comparisons.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;

    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if ((noCustomizer && data[2])
            ? data[1] !== object[data[0]]
            : !(data[0] in object)
          ) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];

      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack;
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === undefined
              ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)
              : result
            )) {
          return false;
        }
      }
    }
    return true;
  }

  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */
  function isStrictComparable(value) {
    return value === value && !isObject$1(value);
  }

  /**
   * Gets the property names, values, and compare flags of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the match data of `object`.
   */
  function getMatchData(object) {
    var result = keys(object),
        length = result.length;

    while (length--) {
      var key = result[length],
          value = object[key];

      result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
  }

  /**
   * A specialized version of `matchesProperty` for source values suitable
   * for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue &&
        (srcValue !== undefined || (key in Object(object)));
    };
  }

  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }

  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */
  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);

    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) &&
      (isArray$1(object) || isArguments(object));
  }

  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */
  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /**
   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
   *
   * @private
   * @param {string} path The path of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get(object, path);
      return (objValue === undefined && objValue === srcValue)
        ? hasIn(object, path)
        : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * A specialized version of `baseProperty` which supports deep paths.
   *
   * @private
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyDeep(path) {
    return function(object) {
      return baseGet(object, path);
    };
  }

  /**
   * Creates a function that returns the value at `path` of a given object.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   * @example
   *
   * var objects = [
   *   { 'a': { 'b': 2 } },
   *   { 'a': { 'b': 1 } }
   * ];
   *
   * _.map(objects, _.property('a.b'));
   * // => [2, 1]
   *
   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
   * // => [1, 2]
   */
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }

  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */
  function baseIteratee(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') {
      return value;
    }
    if (value == null) {
      return identity;
    }
    if (typeof value == 'object') {
      return isArray$1(value)
        ? baseMatchesProperty(value[0], value[1])
        : baseMatches(value);
    }
    return property(value);
  }

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseFor = createBaseFor();

  /**
   * The base implementation of `_.forOwn` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */
  function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
  }

  /**
   * Creates a `baseEach` or `baseEachRight` function.
   *
   * @private
   * @param {Function} eachFunc The function to iterate over a collection.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while ((fromRight ? index-- : ++index < length)) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }

  /**
   * The base implementation of `_.forEach` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   */
  var baseEach = createBaseEach(baseForOwn);

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now = function() {
    return root.Date.now();
  };

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max,
      nativeMin = Math.min;

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject$1(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          timeWaiting = wait - timeSinceLastCall;

      return maxing
        ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
        : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
    }

    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }

    function debounced() {
      var time = now(),
          isInvoking = shouldInvoke(time);

      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  /**
   * The base implementation of `_.map` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function baseMap(collection, iteratee) {
    var index = -1,
        result = isArrayLike(collection) ? Array(collection.length) : [];

    baseEach(collection, function(value, key, collection) {
      result[++index] = iteratee(value, key, collection);
    });
    return result;
  }

  /** `Object#toString` result references. */
  var numberTag = '[object Number]';

  /**
   * Checks if `value` is classified as a `Number` primitive or object.
   *
   * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
   * classified as numbers, use the `_.isFinite` method.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a number, else `false`.
   * @example
   *
   * _.isNumber(3);
   * // => true
   *
   * _.isNumber(Number.MIN_VALUE);
   * // => true
   *
   * _.isNumber(Infinity);
   * // => true
   *
   * _.isNumber('3');
   * // => false
   */
  function isNumber(value) {
    return typeof value == 'number' ||
      (isObjectLike(value) && baseGetTag(value) == numberTag);
  }

  /**
   * The base implementation of `_.set`.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @param {Function} [customizer] The function to customize path creation.
   * @returns {Object} Returns `object`.
   */
  function baseSet(object, path, value, customizer) {
    if (!isObject$1(object)) {
      return object;
    }
    path = castPath(path, object);

    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        nested = object;

    while (nested != null && ++index < length) {
      var key = toKey(path[index]),
          newValue = value;

      if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
        return object;
      }

      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : undefined;
        if (newValue === undefined) {
          newValue = isObject$1(objValue)
            ? objValue
            : (isIndex(path[index + 1]) ? [] : {});
        }
      }
      assignValue(nested, key, newValue);
      nested = nested[key];
    }
    return object;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * Compares values to sort them in ascending order.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== undefined,
          valIsNull = value === null,
          valIsReflexive = value === value,
          valIsSymbol = isSymbol(value);

      var othIsDefined = other !== undefined,
          othIsNull = other === null,
          othIsReflexive = other === other,
          othIsSymbol = isSymbol(other);

      if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
          (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
          (valIsNull && othIsDefined && othIsReflexive) ||
          (!valIsDefined && othIsReflexive) ||
          !valIsReflexive) {
        return 1;
      }
      if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
          (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
          (othIsNull && valIsDefined && valIsReflexive) ||
          (!othIsDefined && valIsReflexive) ||
          !othIsReflexive) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * Used by `_.orderBy` to compare multiple properties of a value to another
   * and stable sort them.
   *
   * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
   * specify an order of "desc" for descending or "asc" for ascending sort order
   * of corresponding values.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {boolean[]|string[]} orders The order to sort by for each property.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = compareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        var order = orders[index];
        return result * (order == 'desc' ? -1 : 1);
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * The base implementation of `_.orderBy` without param guards.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
   * @param {string[]} orders The sort orders of `iteratees`.
   * @returns {Array} Returns the new sorted array.
   */
  function baseOrderBy(collection, iteratees, orders) {
    if (iteratees.length) {
      iteratees = arrayMap(iteratees, function(iteratee) {
        if (isArray$1(iteratee)) {
          return function(value) {
            return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
          }
        }
        return iteratee;
      });
    } else {
      iteratees = [identity];
    }

    var index = -1;
    iteratees = arrayMap(iteratees, baseUnary(baseIteratee));

    var result = baseMap(collection, function(value, key, collection) {
      var criteria = arrayMap(iteratees, function(iteratee) {
        return iteratee(value);
      });
      return { 'criteria': criteria, 'index': ++index, 'value': value };
    });

    return baseSortBy(result, function(object, other) {
      return compareMultiple(object, other, orders);
    });
  }

  /**
   * This method is like `_.sortBy` except that it allows specifying the sort
   * orders of the iteratees to sort by. If `orders` is unspecified, all values
   * are sorted in ascending order. Otherwise, specify an order of "desc" for
   * descending or "asc" for ascending sort order of corresponding values.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
   *  The iteratees to sort by.
   * @param {string[]} [orders] The sort orders of `iteratees`.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
   * @returns {Array} Returns the new sorted array.
   * @example
   *
   * var users = [
   *   { 'user': 'fred',   'age': 48 },
   *   { 'user': 'barney', 'age': 34 },
   *   { 'user': 'fred',   'age': 40 },
   *   { 'user': 'barney', 'age': 36 }
   * ];
   *
   * // Sort by `user` in ascending order and by `age` in descending order.
   * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
   * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
   */
  function orderBy(collection, iteratees, orders, guard) {
    if (collection == null) {
      return [];
    }
    if (!isArray$1(iteratees)) {
      iteratees = iteratees == null ? [] : [iteratees];
    }
    orders = guard ? undefined : orders;
    if (!isArray$1(orders)) {
      orders = orders == null ? [] : [orders];
    }
    return baseOrderBy(collection, iteratees, orders);
  }

  /**
   * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
   * it's created. Arrays are created for missing index properties while objects
   * are created for all other missing properties. Use `_.setWith` to customize
   * `path` creation.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.set(object, 'a[0].b.c', 4);
   * 
   * // => 4
   *
   * _.set(object, ['x', '0', 'y', 'z'], 5);
   * 
   * // => 5
   */
  function set(object, path, value) {
    return object == null ? object : baseSet(object, path, value);
  }

  const objectToString = Object.prototype.toString;
  const toTypeString = (value) => objectToString.call(value);
  const toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  const isArray = Array.isArray;
  const isDate = (val) => toTypeString(val) === "[object Date]";
  const isFunction = (val) => typeof val === "function";
  const isString = (val) => typeof val === "string";
  const isBoolean = (val) => typeof val === "boolean";
  const isObject = (val) => val !== null && typeof val === "object";
  const isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
  };
  const isPlainObject = (val) => toTypeString(val) === "[object Object]";
  function isUrl(url) {
    const regex = new RegExp(
      "^(https?:\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$",
      "i"
    );
    return regex.test(url);
  }
  const isSVGElement = (tag) => typeof SVGElement !== "undefined" && tag instanceof SVGElement;

  function formatDate(date, format = "YYYY-MM-DD HH:mm:ss") {
    if (!date) return "";
    return elementPlus.dayjs(date || /* @__PURE__ */ new Date()).format(format);
  }
  function formatMoney(val, format = "\uFFE5", decimal = 2) {
    if (!val) return "";
    return `${format}${Number(val).toFixed(decimal)}`;
  }

  const getTableKey = (item, hasEditable = false) => hasEditable && isBoolean(item.editable) ? item.label + item.prop + item.editable : item.label + item.prop;
  const getTooltip = (tooltip) => {
    const tooltipData = vue.unref(tooltip);
    if (isString(tooltipData)) {
      return { content: tooltipData };
    }
    if (isPlainObject(tooltipData)) {
      return tooltipData;
    }
    return { content: "" };
  };
  const throwError$1 = (data, type) => {
    if (!isPlainObject(data)) {
      throw new Error(`${type} expected Object but got ${toRawType(data)}`);
    }
  };
  const getCustomProps = async (props, value, row, index, type) => {
    try {
      let data = {};
      const params = { row, index };
      if (!props) {
        data = {};
      } else if (vue.isRef(props)) {
        data = props.value;
      } else if (isPlainObject(props)) {
        data = { ...props };
      } else if (isFunction(props)) {
        data = await props(value, params);
      } else if (isPromise(props)) {
        data = await props;
      } else {
        data = props;
      }
      throwError$1(data, type);
      return data;
    } catch (error) {
      return Promise.reject(error);
    }
  };
  const getSlotName = (type, prop) => {
    return prop ? `plus-${type}-${prop}` : `plus-${type}`;
  };
  const getFieldSlotName = (prop) => {
    return `${getSlotName("field", prop)}`;
  };
  const getLabelSlotName = (prop) => {
    return `${getSlotName("label", prop)}`;
  };
  const getExtraSlotName = (prop) => {
    return `${getSlotName("extra", prop)}`;
  };
  const getTableHeaderSlotName = (prop) => {
    return `${getSlotName("header", prop)}`;
  };
  const getTableCellSlotName = (prop) => {
    return `${getSlotName("cell", prop)}`;
  };
  const getDescSlotName = (prop) => {
    return `${getSlotName("desc", prop)}`;
  };
  const getDescLabelSlotName = (prop) => {
    return `${getSlotName("desc-label", prop)}`;
  };
  const filterSlots = (slots, name) => {
    const data = {};
    Object.keys(slots || {}).forEach((key) => {
      if (key.startsWith(name)) {
        data[key] = slots[key];
      }
    });
    return data;
  };
  const getValue = (target, key) => {
    return get(target, key);
  };
  const setValue = (target, key, value) => {
    return set(target, key, value);
  };
  const compareVersion = (version1, version2) => {
    const arr1 = version1.split(".").map((item) => Number(item));
    const arr2 = version2.split(".").map((item) => Number(item));
    const length = Math.max(arr1.length, arr2.length);
    for (let i = 0; i < length; i++) {
      if ((arr1[i] || 0) > (arr2[i] || 0)) return 1;
      if ((arr1[i] || 0) < (arr2[i] || 0)) return -1;
    }
    return 0;
  };
  const versionIsLessThan260 = compareVersion(elementPlus.version, "2.6.0") < 0;
  const getLabel = (label) => label ? vue.unref(label) : "";
  const removeChildrenField = (item) => {
    const { children, ...rest } = item;
    const data = { ...rest, __children: children };
    return data;
  };

  const throwError = (data) => {
    if (!isArray(data)) {
      console.error("Uncaught TypeError: ", `options expected Array but got ${toRawType(data)}`);
    }
  };
  const getOptionsByOptionsMap = (options, props) => {
    const optionsMap = props.optionsMap;
    const valueType = props.valueType;
    if (valueType === "cascader" || !isPlainObject(optionsMap)) {
      return options;
    }
    const data = options.map((item) => {
      const temp = cloneDeep(item);
      const label = optionsMap.label || "label";
      const value = optionsMap.value || "value";
      const __origin = {
        [label]: temp[label],
        [value]: temp[value]
      };
      optionsMap.label && Reflect.deleteProperty(temp, label);
      optionsMap.value && Reflect.deleteProperty(temp, value);
      return { ...temp, __origin, label: item[label], value: item[value] };
    });
    return data;
  };
  const useGetOptions = (props) => {
    const options = vue.ref([]);
    const optionsIsReady = vue.ref(false);
    if (!props.options) {
      options.value = [];
      optionsIsReady.value = true;
    } else if (vue.isRef(props.options) || vue.isReactive(props.options) || isArray(props.options)) {
      vue.watch(
        () => props.options,
        (val) => {
          const value = vue.isRef(val) ? val.value : val;
          options.value = getOptionsByOptionsMap(value, props);
          optionsIsReady.value = true;
        },
        {
          immediate: true,
          deep: true
        }
      );
    } else if (isFunction(props.options)) {
      const getValue = props.options;
      const result = getValue(props);
      if (isPromise(result)) {
        result.then((value) => {
          options.value = getOptionsByOptionsMap(value, props);
          optionsIsReady.value = true;
          throwError(options.value);
        }).catch((err) => {
          throw err;
        });
      } else {
        options.value = getOptionsByOptionsMap(result, props);
        optionsIsReady.value = true;
      }
    } else if (isPromise(props.options)) {
      const getValue = props.options;
      getValue.then((value) => {
        options.value = getOptionsByOptionsMap(value, props);
        optionsIsReady.value = true;
        throwError(options.value);
      }).catch((err) => {
        throw err;
      });
    } else {
      optionsIsReady.value = true;
      throwError(props.options);
    }
    return { customOptions: options, customOptionsIsReady: optionsIsReady };
  };

  var English = {
    name: "en",
    plus: {
      dialog: {
        confirmText: "Yes",
        cancelText: "No",
        title: "Dialog"
      },
      datepicker: {
        startPlaceholder: "Please select start time",
        endPlaceholder: "Please select end time"
      },
      dialogForm: {
        title: "Dialog form"
      },
      drawerForm: {
        title: "Drawer form",
        confirmText: "Yes",
        cancelText: "No"
      },
      form: {
        submitText: "Submit",
        resetText: "Reset",
        errorTip: "Please complete the form and submit again!"
      },
      field: {
        pleaseEnter: "Please enter ",
        pleaseSelect: "Please select "
      },
      popover: {
        confirmText: "Yes",
        cancelText: "No"
      },
      search: {
        searchText: "Search",
        resetText: "Reset",
        expand: "Expand",
        retract: "Retract"
      },
      table: {
        title: "Table",
        density: "Density",
        refresh: "Refresh",
        columnSettings: "Column settings",
        selectAll: "Select all",
        default: "Default",
        loose: "Loose",
        compact: "Compact",
        action: "Action",
        more: "More",
        confirmToPerformThisOperation: "Confirm to perform this operation?",
        prompt: "Prompt",
        sort: "Sort"
      },
      stepsForm: {
        nextText: "Next step",
        preText: "Previous step",
        submitText: "Submit"
      },
      inputTag: {
        placeholder: "Please enter keywords and press enter or space key"
      },
      header: {
        logout: "logout"
      }
    }
  };

  const buildTranslator = (locale) => (path, option) => translate(path, option, vue.unref(locale));
  const translate = (path, option, locale) => get(locale, path, path).replace(
    /\{(\w+)\}/g,
    (_, key) => {
      var _a;
      return `${(_a = option == null ? void 0 : option[key]) != null ? _a : `{${key}}`}`;
    }
  );
  const buildLocaleContext = (locale) => {
    const lang = vue.computed(() => vue.unref(locale).name);
    const localeRef = vue.isRef(locale) ? locale : vue.ref(locale);
    return {
      lang,
      locale: localeRef,
      t: buildTranslator(locale)
    };
  };
  const useLocale = (localeOverrides) => {
    const locale = localeOverrides || vue.inject(elementPlus.localeContextKey, vue.ref());
    return buildLocaleContext(vue.computed(() => {
      var _a;
      return ((_a = locale.value) == null ? void 0 : _a.plus) ? locale.value : English;
    }));
  };

  const DefaultPageSizeList = [10, 20, 30, 40, 50, 100, 200, 300, 400, 500];
  const DefaultPageInfo = {
    page: 1,
    pageSize: 10
  };

  const TableFormRefInjectionKey = Symbol("tableFormRefInjectionKey");
  const TableFormFieldRefInjectionKey = Symbol("tableFormFieldRefInjectionKey");
  const TableFormRowInfoInjectionKey = Symbol("tableFormRowInfoInjectionKey");
  const DatePickerValueIsArrayList = ["datetimerange", "daterange", "monthrange"];
  const ValueIsNumberList = ["rate", "input-number", "slider"];
  const ValueIsBooleanList = ["switch"];
  const ValueIsArrayList = [
    "checkbox",
    "cascader",
    "plus-date-picker",
    "plus-input-tag",
    "transfer"
  ];

  function useTable(_pageInfo) {
    const defaultPageInfo = vue.unref(_pageInfo) || DefaultPageInfo;
    const tableData = vue.ref([]);
    const pageInfo = vue.ref({ ...defaultPageInfo });
    const total = vue.ref(0);
    const loadingStatus = vue.ref(false);
    const buttons = vue.shallowRef([]);
    return {
      tableData,
      pageInfo,
      total,
      loadingStatus,
      buttons
    };
  }

  const _hoisted_1$j = { class: "plus-dialog-body" };
  var _sfc_main$u = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusDialog",
      inheritAttrs: false
    },
    __name: "index",
    props: {
      modelValue: { type: Boolean, default: false },
      confirmText: { default: "" },
      cancelText: { default: "" },
      confirmLoading: { type: Boolean, default: false },
      hasFooter: { type: Boolean, default: true },
      footerAlign: { default: "right" },
      top: { default: "15vh" },
      width: { default: "460px" },
      title: { default: "" }
    },
    emits: ["update:modelValue", "cancel", "confirm"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const style = vue.computed(() => ({
        justifyContent: props.footerAlign === "left" ? "flex-start" : props.footerAlign === "center" ? "center" : "flex-end"
      }));
      const subVisible = vue.ref(false);
      const { t } = useLocale();
      vue.watchEffect(() => {
        subVisible.value = props.modelValue;
      });
      const handleConfirm = () => {
        emit("confirm");
      };
      const handleCancel = () => {
        emit("update:modelValue", false);
        emit("cancel");
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElDialog), vue.mergeProps({
          modelValue: subVisible.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => subVisible.value = $event),
          top: _ctx.top,
          width: _ctx.width,
          title: _ctx.title || vue.unref(t)("plus.dialog.title"),
          "close-on-click-modal": false,
          "close-on-press-escape": false,
          "append-to-body": false,
          "before-close": handleCancel,
          class: "plus-dialog"
        }, _ctx.$attrs), vue.createSlots({
          default: vue.withCtx(() => [
            vue.createElementVNode("div", _hoisted_1$j, [
              vue.renderSlot(_ctx.$slots, "default")
            ])
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          _ctx.$slots.header ? {
            name: "header",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "header")
            ]),
            key: "0"
          } : void 0,
          _ctx.hasFooter ? {
            name: "footer",
            fn: vue.withCtx(() => [
              vue.createElementVNode(
                "div",
                {
                  class: "plus-dialog-footer",
                  style: vue.normalizeStyle(style.value)
                },
                [
                  vue.renderSlot(_ctx.$slots, "footer", {}, () => [
                    vue.createVNode(vue.unref(elementPlus.ElButton), { onClick: handleCancel }, {
                      default: vue.withCtx(() => [
                        vue.createTextVNode(
                          vue.toDisplayString(_ctx.cancelText || vue.unref(t)("plus.dialog.cancelText")),
                          1
                          /* TEXT */
                        )
                      ]),
                      _: 1
                      /* STABLE */
                    }),
                    vue.createVNode(vue.unref(elementPlus.ElButton), {
                      type: "primary",
                      loading: _ctx.confirmLoading,
                      onClick: handleConfirm
                    }, {
                      default: vue.withCtx(() => [
                        vue.createTextVNode(
                          vue.toDisplayString(_ctx.confirmText || vue.unref(t)("plus.dialog.confirmText")),
                          1
                          /* TEXT */
                        )
                      ]),
                      _: 1
                      /* STABLE */
                    }, 8, ["loading"])
                  ])
                ],
                4
                /* STYLE */
              )
            ]),
            key: "1"
          } : void 0
        ]), 1040, ["modelValue", "top", "width", "title"]);
      };
    }
  });

  var _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };

  var Dialog = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__file", "index.vue"]]);

  const PlusDialog = Dialog;

  const _hoisted_1$i = { class: "plus-pagination" };
  const _hoisted_2$7 = /* @__PURE__ */ vue.createElementVNode(
    "span",
    null,
    null,
    -1
    /* HOISTED */
  );
  const _hoisted_3$4 = /* @__PURE__ */ vue.createElementVNode(
    "span",
    null,
    null,
    -1
    /* HOISTED */
  );
  var _sfc_main$t = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusPagination"
    },
    __name: "index",
    props: {
      modelValue: { default: () => ({ ...DefaultPageInfo }) },
      total: { default: 0 },
      pageSizeList: { default: () => [...DefaultPageSizeList] },
      align: { default: "right" }
    },
    emits: ["update:modelValue", "change", "size-change", "current-change"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const pageInfo = vue.ref({ ...DefaultPageInfo });
      vue.watchEffect(() => {
        pageInfo.value = { ...props.modelValue };
      });
      const handleEmit = () => {
        emit("update:modelValue", pageInfo.value);
        emit("change", pageInfo.value);
      };
      const handleSizeChange = (pageSize) => {
        pageInfo.value.pageSize = pageSize;
        pageInfo.value.page = 1;
        handleEmit();
        emit("size-change", pageSize);
      };
      const handleCurrentChange = (page) => {
        pageInfo.value.page = page;
        handleEmit();
        emit("current-change", page);
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$i, [
          _ctx.align === "right" ? vue.renderSlot(_ctx.$slots, "pagination-left", { key: 0 }, () => [
            _hoisted_2$7
          ]) : vue.createCommentVNode("v-if", true),
          vue.createVNode(vue.unref(elementPlus.ElPagination), vue.mergeProps({
            layout: "total, sizes, prev, pager, next, jumper",
            background: false,
            "current-page": pageInfo.value.page,
            "page-size": pageInfo.value.pageSize,
            total: _ctx.total,
            "page-sizes": _ctx.pageSizeList
          }, _ctx.$attrs, {
            onSizeChange: handleSizeChange,
            onCurrentChange: handleCurrentChange
          }), null, 16, ["current-page", "page-size", "total", "page-sizes"]),
          _ctx.align === "left" ? vue.renderSlot(_ctx.$slots, "pagination-right", { key: 1 }, () => [
            _hoisted_3$4
          ]) : vue.createCommentVNode("v-if", true)
        ]);
      };
    }
  });

  var Pagination = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__file", "index.vue"]]);

  const PlusPagination = Pagination;

  /*! Element Plus Icons Vue v2.3.1 */

  var arrow_down_bold_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "ArrowDownBold",
    __name: "arrow-down-bold",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M104.704 338.752a64 64 0 0 1 90.496 0l316.8 316.8 316.8-316.8a64 64 0 0 1 90.496 90.496L557.248 791.296a64 64 0 0 1-90.496 0L104.704 429.248a64 64 0 0 1 0-90.496z"
        })
      ]));
    }
  });

  // src/components/arrow-down-bold.vue
  var arrow_down_bold_default = arrow_down_bold_vue_vue_type_script_setup_true_lang_default;
  var arrow_down_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "ArrowDown",
    __name: "arrow-down",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
        })
      ]));
    }
  });

  // src/components/arrow-down.vue
  var arrow_down_default = arrow_down_vue_vue_type_script_setup_true_lang_default;
  var arrow_up_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "ArrowUp",
    __name: "arrow-up",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
        })
      ]));
    }
  });

  // src/components/arrow-up.vue
  var arrow_up_default = arrow_up_vue_vue_type_script_setup_true_lang_default;
  var document_copy_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "DocumentCopy",
    __name: "document-copy",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M128 320v576h576V320zm-32-64h640a32 32 0 0 1 32 32v640a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V288a32 32 0 0 1 32-32M960 96v704a32 32 0 0 1-32 32h-96v-64h64V128H384v64h-64V96a32 32 0 0 1 32-32h576a32 32 0 0 1 32 32M256 672h320v64H256zm0-192h320v64H256z"
        })
      ]));
    }
  });

  // src/components/document-copy.vue
  var document_copy_default = document_copy_vue_vue_type_script_setup_true_lang_default;
  var expand_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "Expand",
    __name: "expand",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M128 192h768v128H128zm0 256h512v128H128zm0 256h768v128H128zm576-352 192 160-192 128z"
        })
      ]));
    }
  });

  // src/components/expand.vue
  var expand_default = expand_vue_vue_type_script_setup_true_lang_default;
  var fold_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "Fold",
    __name: "fold",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M896 192H128v128h768zm0 256H384v128h512zm0 256H128v128h768zM320 384 128 512l192 128z"
        })
      ]));
    }
  });

  // src/components/fold.vue
  var fold_default = fold_vue_vue_type_script_setup_true_lang_default;
  var question_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "QuestionFilled",
    __name: "question-filled",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z"
        })
      ]));
    }
  });

  // src/components/question-filled.vue
  var question_filled_default = question_filled_vue_vue_type_script_setup_true_lang_default;
  var refresh_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "RefreshRight",
    __name: "refresh-right",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
        })
      ]));
    }
  });

  // src/components/refresh-right.vue
  var refresh_right_default = refresh_right_vue_vue_type_script_setup_true_lang_default;
  var search_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "Search",
    __name: "search",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704"
        })
      ]));
    }
  });

  // src/components/search.vue
  var search_default = search_vue_vue_type_script_setup_true_lang_default;
  var select_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "Select",
    __name: "select",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M77.248 415.04a64 64 0 0 1 90.496 0l226.304 226.304L846.528 188.8a64 64 0 1 1 90.56 90.496l-543.04 543.04-316.8-316.8a64 64 0 0 1 0-90.496z"
        })
      ]));
    }
  });

  // src/components/select.vue
  var select_default = select_vue_vue_type_script_setup_true_lang_default;
  var setting_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "Setting",
    __name: "setting",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M600.704 64a32 32 0 0 1 30.464 22.208l35.2 109.376c14.784 7.232 28.928 15.36 42.432 24.512l112.384-24.192a32 32 0 0 1 34.432 15.36L944.32 364.8a32 32 0 0 1-4.032 37.504l-77.12 85.12a357.12 357.12 0 0 1 0 49.024l77.12 85.248a32 32 0 0 1 4.032 37.504l-88.704 153.6a32 32 0 0 1-34.432 15.296L708.8 803.904c-13.44 9.088-27.648 17.28-42.368 24.512l-35.264 109.376A32 32 0 0 1 600.704 960H423.296a32 32 0 0 1-30.464-22.208L357.696 828.48a351.616 351.616 0 0 1-42.56-24.64l-112.32 24.256a32 32 0 0 1-34.432-15.36L79.68 659.2a32 32 0 0 1 4.032-37.504l77.12-85.248a357.12 357.12 0 0 1 0-48.896l-77.12-85.248A32 32 0 0 1 79.68 364.8l88.704-153.6a32 32 0 0 1 34.432-15.296l112.32 24.256c13.568-9.152 27.776-17.408 42.56-24.64l35.2-109.312A32 32 0 0 1 423.232 64H600.64zm-23.424 64H446.72l-36.352 113.088-24.512 11.968a294.113 294.113 0 0 0-34.816 20.096l-22.656 15.36-116.224-25.088-65.28 113.152 79.68 88.192-1.92 27.136a293.12 293.12 0 0 0 0 40.192l1.92 27.136-79.808 88.192 65.344 113.152 116.224-25.024 22.656 15.296a294.113 294.113 0 0 0 34.816 20.096l24.512 11.968L446.72 896h130.688l36.48-113.152 24.448-11.904a288.282 288.282 0 0 0 34.752-20.096l22.592-15.296 116.288 25.024 65.28-113.152-79.744-88.192 1.92-27.136a293.12 293.12 0 0 0 0-40.256l-1.92-27.136 79.808-88.128-65.344-113.152-116.288 24.96-22.592-15.232a287.616 287.616 0 0 0-34.752-20.096l-24.448-11.904L577.344 128zM512 320a192 192 0 1 1 0 384 192 192 0 0 1 0-384m0 64a128 128 0 1 0 0 256 128 128 0 0 0 0-256"
        })
      ]));
    }
  });

  // src/components/setting.vue
  var setting_default = setting_vue_vue_type_script_setup_true_lang_default;
  var user_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
    name: "User",
    __name: "user",
    setup(__props) {
      return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        vue.createElementVNode("path", {
          fill: "currentColor",
          d: "M512 512a192 192 0 1 0 0-384 192 192 0 0 0 0 384m0 64a256 256 0 1 1 0-512 256 256 0 0 1 0 512m320 320v-96a96 96 0 0 0-96-96H288a96 96 0 0 0-96 96v96a32 32 0 1 1-64 0v-96a160 160 0 0 1 160-160h448a160 160 0 0 1 160 160v96a32 32 0 1 1-64 0"
        })
      ]));
    }
  });

  // src/components/user.vue
  var user_default = user_vue_vue_type_script_setup_true_lang_default;

  const _hoisted_1$h = { class: "plus-table-action-bar__dropdown__link" };
  const _hoisted_2$6 = { class: "plus-table-action-bar__more-text" };
  var _sfc_main$s = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusTableActionBar"
    },
    __name: "table-action-bar",
    props: {
      label: { default: "" },
      fixed: { default: "right" },
      showNumber: { default: 3 },
      showLimitIncludeMore: { type: Boolean, default: false },
      type: { default: "link" },
      buttons: { default: () => [] },
      width: { default: 200 },
      actionBarTableColumnProps: { default: () => ({}) },
      confirmType: { default: "messageBox" }
    },
    emits: ["clickAction", "clickActionConfirmCancel"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const { t } = useLocale();
      const hideOnClick = vue.ref(true);
      const formRefs = vue.inject(TableFormRefInjectionKey);
      const getSubButtons = (row, index) => {
        const data = props.buttons.filter((item) => {
          if (isFunction(item.show)) {
            const tempFunction = item.show;
            const isShow = tempFunction(row, index, item);
            return vue.unref(isShow) !== false;
          }
          return vue.unref(item.show) !== false;
        });
        const showMore = data.length > props.showNumber;
        if (!showMore) {
          return {
            showMore,
            preButtons: data,
            nextButtons: []
          };
        }
        if (props.showLimitIncludeMore) {
          return {
            showMore,
            preButtons: data.slice(0, props.showNumber - 1),
            nextButtons: data.slice(props.showNumber - 1)
          };
        }
        return {
          showMore,
          preButtons: data.slice(0, props.showNumber),
          nextButtons: data.slice(props.showNumber)
        };
      };
      const getConfirmParams = (params, e) => {
        var _a, _b;
        const { row, buttonRow, index, rest, text } = params;
        const callbackParams = {
          /**
           * text
           * @version v0.1.17
           */
          text,
          row,
          buttonRow,
          index,
          rowIndex: index,
          e,
          formRefs: formRefs.value[index],
          ...rest
        };
        let message = t("plus.table.confirmToPerformThisOperation");
        let title = t("plus.table.prompt");
        let options = void 0;
        let appContext = null;
        if (isPlainObject(buttonRow.confirm)) {
          const tempTitle = isFunction(buttonRow.confirm.title) ? buttonRow.confirm.title(callbackParams) : buttonRow.confirm.title;
          if (tempTitle) {
            title = tempTitle;
          }
          const tempMessage = isFunction(buttonRow.confirm.message) ? buttonRow.confirm.message(callbackParams) : buttonRow.confirm.message;
          if (tempMessage) {
            message = tempMessage;
          }
          options = (_a = buttonRow.confirm) == null ? void 0 : _a.options;
          appContext = (_b = buttonRow.confirm) == null ? void 0 : _b.appContext;
        }
        return { msg: { message, title, options, appContext }, callbackParams };
      };
      const render = (row, buttonRow, index, rest) => {
        var _a;
        const buttonRowProps = isFunction(buttonRow.props) ? buttonRow.props(row, index, buttonRow) : vue.unref(buttonRow.props);
        const text = isFunction(buttonRow.text) ? vue.unref(buttonRow.text(row, index, buttonRow)) : vue.unref(buttonRow.text);
        const params = {
          text,
          row,
          buttonRow,
          index,
          rest
        };
        const { msg, callbackParams } = getConfirmParams(params);
        if (props.type === "icon") {
          return vue.h(
            elementPlus.ElTooltip,
            { placement: "top", content: text, ...buttonRow.tooltipProps },
            () => {
              var _a2;
              return props.confirmType === "popconfirm" && buttonRow.confirm ? vue.h(
                "span",
                {
                  class: "el-icon"
                },
                vue.h(
                  elementPlus.ElPopconfirm,
                  {
                    trigger: "click",
                    ...isPlainObject(buttonRow.confirm) ? (_a2 = buttonRow.confirm) == null ? void 0 : _a2.popconfirmProps : {},
                    title: msg.message,
                    onConfirm: (event) => handleConfirm({ ...callbackParams, e: event }),
                    onCancel: (event) => handleCancel({ ...callbackParams, e: event })
                  },
                  {
                    reference: () => vue.withDirectives(
                      vue.h(
                        elementPlus.ElIcon,
                        {
                          size: 16,
                          style: { margin: 0 },
                          ...buttonRowProps,
                          onClick: () => {
                            hideOnClick.value = false;
                            if (isFunction(buttonRow.onClick)) {
                              buttonRow.onClick(callbackParams);
                            }
                          }
                        },
                        () => buttonRow.icon ? vue.h(buttonRow.icon) : ""
                      ),
                      buttonRow.directives || []
                    )
                  }
                )
              ) : vue.withDirectives(
                vue.h(
                  elementPlus.ElIcon,
                  {
                    size: 16,
                    ...buttonRowProps,
                    onClick: (event) => handleClickAction({ ...callbackParams, e: event }, msg)
                  },
                  () => buttonRow.icon ? vue.h(buttonRow.icon) : ""
                ),
                buttonRow.directives || []
              );
            }
          );
        } else {
          const Tag = props.type === "button" ? elementPlus.ElButton : elementPlus.ElLink;
          const defaultProps = props.type === "link" ? { href: "javaScript:;" } : {};
          return props.confirmType === "popconfirm" && buttonRow.confirm ? vue.h(
            elementPlus.ElPopconfirm,
            {
              trigger: "click",
              ...isPlainObject(buttonRow.confirm) ? (_a = buttonRow.confirm) == null ? void 0 : _a.popconfirmProps : {},
              title: msg.message,
              onConfirm: (event) => handleConfirm({ ...callbackParams, e: event }),
              onCancel: (event) => handleCancel({ ...callbackParams, e: event })
            },
            {
              reference: () => vue.withDirectives(
                vue.h(
                  Tag,
                  {
                    size: "small",
                    ...defaultProps,
                    ...buttonRowProps,
                    onClick: () => {
                      hideOnClick.value = false;
                      if (isFunction(buttonRow.onClick)) {
                        buttonRow.onClick(callbackParams);
                      }
                    }
                  },
                  () => text
                ),
                buttonRow.directives || []
              )
            }
          ) : vue.withDirectives(
            vue.h(
              Tag,
              {
                size: "small",
                ...defaultProps,
                ...buttonRowProps,
                onClick: (event) => handleClickAction({ ...callbackParams, e: event }, msg)
              },
              () => text
            ),
            buttonRow.directives || []
          );
        }
      };
      const handleConfirm = (callbackParams) => {
        if (isFunction(callbackParams.buttonRow.onConfirm)) {
          callbackParams.buttonRow.onConfirm(callbackParams);
        }
        emit("clickAction", callbackParams);
      };
      const handleCancel = (callbackParams) => {
        if (isFunction(callbackParams.buttonRow.onCancel)) {
          callbackParams.buttonRow.onCancel(callbackParams);
        }
        emit("clickActionConfirmCancel", callbackParams);
      };
      const handleClickAction = (callbackParams, msg) => {
        hideOnClick.value = true;
        const { buttonRow } = callbackParams;
        if (isFunction(buttonRow.onClick)) {
          buttonRow.onClick(callbackParams);
        }
        if (buttonRow.confirm) {
          if (props.confirmType === "messageBox") {
            const { message, title, options, appContext } = msg;
            elementPlus.ElMessageBox.confirm(message, title, options, appContext).then(() => {
              if (isFunction(buttonRow.onConfirm)) {
                buttonRow.onConfirm(callbackParams);
              }
              emit("clickAction", callbackParams);
            }).catch(() => {
              if (isFunction(buttonRow.onCancel)) {
                buttonRow.onCancel(callbackParams);
              }
              emit("clickActionConfirmCancel", callbackParams);
            });
          }
        } else {
          emit("clickAction", callbackParams);
        }
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElTableColumn), vue.mergeProps({
          key: "actionBar",
          "class-name": "plus-table-action-bar",
          label: vue.unref(_ctx.label) || vue.unref(t)("plus.table.action"),
          fixed: _ctx.fixed || "right",
          width: _ctx.width || 200
        }, _ctx.actionBarTableColumnProps), {
          default: vue.withCtx(({ row, $index, ...rest }) => [
            vue.createCommentVNode(" \u663E\u793A\u51FA\u6765\u7684\u6309\u94AE "),
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList(getSubButtons(row, $index).preButtons, (buttonRow) => {
                return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(render(row, buttonRow, $index, rest)), {
                  key: buttonRow.text
                });
              }),
              128
              /* KEYED_FRAGMENT */
            )),
            vue.createCommentVNode(" \u9690\u85CF\u7684\u6309\u94AE "),
            getSubButtons(row, $index).showMore ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElDropdown), {
              key: 0,
              trigger: "click",
              class: "plus-table-action-bar__dropdown",
              "hide-on-click": hideOnClick.value
            }, {
              dropdown: vue.withCtx(() => [
                vue.createVNode(
                  vue.unref(elementPlus.ElDropdownMenu),
                  null,
                  {
                    default: vue.withCtx(() => [
                      (vue.openBlock(true), vue.createElementBlock(
                        vue.Fragment,
                        null,
                        vue.renderList(getSubButtons(row, $index).nextButtons, (buttonRow) => {
                          return vue.openBlock(), vue.createBlock(
                            vue.unref(elementPlus.ElDropdownItem),
                            {
                              key: vue.unref(buttonRow.text)
                            },
                            {
                              default: vue.withCtx(() => [
                                (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(render(row, buttonRow, $index, rest))))
                              ]),
                              _: 2
                              /* DYNAMIC */
                            },
                            1024
                            /* DYNAMIC_SLOTS */
                          );
                        }),
                        128
                        /* KEYED_FRAGMENT */
                      ))
                    ]),
                    _: 2
                    /* DYNAMIC */
                  },
                  1024
                  /* DYNAMIC_SLOTS */
                )
              ]),
              default: vue.withCtx(() => [
                vue.createElementVNode("span", _hoisted_1$h, [
                  vue.createElementVNode(
                    "span",
                    _hoisted_2$6,
                    vue.toDisplayString(vue.unref(t)("plus.table.more")),
                    1
                    /* TEXT */
                  ),
                  vue.renderSlot(_ctx.$slots, "action-bar-more-icon", {}, () => [
                    vue.createVNode(vue.unref(elementPlus.ElIcon), null, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(arrow_down_bold_default))
                      ]),
                      _: 1
                      /* STABLE */
                    })
                  ])
                ])
              ]),
              _: 2
              /* DYNAMIC */
            }, 1032, ["hide-on-click"])) : vue.createCommentVNode("v-if", true)
          ]),
          _: 3
          /* FORWARDED */
        }, 16, ["label", "fixed", "width"]);
      };
    }
  });

  var PlusTableActionBar = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__file", "table-action-bar.vue"]]);

  var _sfc_main$r = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusRender"
    },
    __name: "index",
    props: {
      renderType: { default: void 0 },
      callbackValue: { default: "" },
      customFieldProps: { default: () => ({}) },
      render: {},
      params: { default: () => ({}) },
      handleChange: {}
    },
    setup(__props) {
      const props = __props;
      const state = vue.ref();
      vue.watch(
        () => props.callbackValue,
        (val) => {
          state.value = val;
        },
        {
          flush: "post",
          immediate: true
        }
      );
      const renderComponent = () => {
        if (!props.render) return;
        const params = { ...props.params };
        const dynamicComponent = props.renderType === "form" ? props.render(
          state.value,
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          props.handleChange,
          params
        ) : props.render(state.value, params);
        if (vue.isVNode(dynamicComponent)) {
          const payload = props.renderType === "form" ? {
            modelValue: state.value,
            ...props.customFieldProps,
            ...dynamicComponent.props
          } : {
            ...props.customFieldProps,
            ...dynamicComponent.props
          };
          return {
            ...dynamicComponent,
            props: payload
          };
        } else if (isString(dynamicComponent)) {
          return dynamicComponent;
        }
      };
      return (_ctx, _cache) => {
        return _ctx.renderType === "form" ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(renderComponent), vue.mergeProps({
          key: 0,
          modelValue: state.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.value = $event)
        }, _ctx.customFieldProps), null, 16, ["modelValue"])) : (vue.openBlock(), vue.createBlock(
          vue.resolveDynamicComponent(renderComponent),
          vue.normalizeProps(vue.mergeProps({ key: 1 }, _ctx.customFieldProps)),
          null,
          16
          /* FULL_PROPS */
        ));
      };
    }
  });

  var Render = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__file", "index.vue"]]);

  const PlusRender = Render;

  var _sfc_main$q = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusRadio"
    },
    __name: "index",
    props: {
      modelValue: { type: [String, Number, Boolean], default: "" },
      options: { default: () => [] },
      isCancel: { type: Boolean, default: true },
      fieldSlots: { default: void 0 },
      fieldChildrenSlot: { default: void 0 }
    },
    emits: ["change", "update:modelValue"],
    setup(__props, { expose: __expose, emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const radioInstance = vue.ref();
      const radioGroupInstance = vue.ref();
      const state = vue.reactive({ radio: "" });
      vue.watch(
        () => props.modelValue,
        (val) => {
          state.radio = val;
        },
        { immediate: true }
      );
      const attrs = vue.useAttrs();
      const radioClick = (e, val, fieldItemProps) => {
        if (Reflect.has(attrs, "disabled") || (fieldItemProps == null ? void 0 : fieldItemProps.disabled)) {
          return;
        }
        if (!props.isCancel) {
          return;
        } else {
          e.preventDefault();
        }
        state.radio = state.radio === val ? "" : val;
        emit("update:modelValue", state.radio);
        emit("change", state.radio);
      };
      const change = (val) => {
        if (props.isCancel) return;
        emit("update:modelValue", val);
        emit("change", val);
      };
      __expose({
        radioInstance,
        radioGroupInstance
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElRadioGroup), vue.mergeProps({
          ref_key: "radioGroupInstance",
          ref: radioGroupInstance,
          modelValue: state.radio,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.radio = $event),
          class: "plus-radio"
        }, _ctx.$attrs), vue.createSlots({
          default: vue.withCtx(() => [
            vue.unref(versionIsLessThan260) ? (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              { key: 0 },
              vue.renderList(_ctx.options, (item) => {
                return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElRadio), vue.mergeProps({
                  key: `${item.label}${item.value}`,
                  ref_for: true,
                  ref_key: "radioInstance",
                  ref: radioInstance,
                  label: item.value
                }, item.fieldItemProps, {
                  onClick: ($event) => radioClick($event, item.value, item.fieldItemProps),
                  onChange: ($event) => change(item.value)
                }), {
                  default: vue.withCtx(() => [
                    vue.unref(isFunction)(item.fieldSlot) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(item.fieldSlot), vue.mergeProps({
                      key: 0,
                      "model-value": state.radio,
                      column: props
                    }, item), null, 16, ["model-value"])) : vue.unref(isFunction)(_ctx.fieldChildrenSlot) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.fieldChildrenSlot), vue.mergeProps({
                      key: 1,
                      "model-value": state.radio,
                      column: props
                    }, item), null, 16, ["model-value"])) : (vue.openBlock(), vue.createElementBlock(
                      vue.Fragment,
                      { key: 2 },
                      [
                        vue.createTextVNode(
                          vue.toDisplayString(item == null ? void 0 : item.label),
                          1
                          /* TEXT */
                        )
                      ],
                      64
                      /* STABLE_FRAGMENT */
                    ))
                  ]),
                  _: 2
                  /* DYNAMIC */
                }, 1040, ["label", "onClick", "onChange"]);
              }),
              128
              /* KEYED_FRAGMENT */
            )) : (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 1 },
              [
                vue.createCommentVNode(" element-plus \u7248\u672C\u53F7\u5927\u4E8E\u7B49\u4E8E2.6.0 "),
                (vue.openBlock(true), vue.createElementBlock(
                  vue.Fragment,
                  null,
                  vue.renderList(_ctx.options, (item) => {
                    return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElRadio), vue.mergeProps({
                      key: `${item.label}${item.value}`,
                      ref_for: true,
                      ref_key: "radioInstance",
                      ref: radioInstance,
                      value: item.value
                    }, item.fieldItemProps, {
                      onClick: ($event) => radioClick($event, item.value, item.fieldItemProps),
                      onChange: ($event) => change(item.value)
                    }), {
                      default: vue.withCtx(() => [
                        vue.unref(isFunction)(item.fieldSlot) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(item.fieldSlot), vue.mergeProps({
                          key: 0,
                          "model-value": state.radio,
                          column: props
                        }, item), null, 16, ["model-value"])) : vue.unref(isFunction)(_ctx.fieldChildrenSlot) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.fieldChildrenSlot), vue.mergeProps({
                          key: 1,
                          "model-value": state.radio,
                          column: props
                        }, item), null, 16, ["model-value"])) : (vue.openBlock(), vue.createElementBlock(
                          vue.Fragment,
                          { key: 2 },
                          [
                            vue.createTextVNode(
                              vue.toDisplayString(item == null ? void 0 : item.label),
                              1
                              /* TEXT */
                            )
                          ],
                          64
                          /* STABLE_FRAGMENT */
                        ))
                      ]),
                      _: 2
                      /* DYNAMIC */
                    }, 1040, ["value", "onClick", "onChange"]);
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ],
              64
              /* STABLE_FRAGMENT */
            ))
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          vue.renderList(_ctx.fieldSlots, (fieldSlot, key) => {
            return {
              name: key,
              fn: vue.withCtx((data) => [
                (vue.openBlock(), vue.createBlock(
                  vue.resolveDynamicComponent(fieldSlot),
                  vue.normalizeProps(vue.guardReactiveProps(data)),
                  null,
                  16
                  /* FULL_PROPS */
                ))
              ])
            };
          })
        ]), 1040, ["modelValue"]);
      };
    }
  });

  var Radio = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__file", "index.vue"]]);

  const PlusRadio = Radio;

  const _hoisted_1$g = { class: "plus-date-picker__middle" };
  var _sfc_main$p = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusDatePicker"
    },
    __name: "index",
    props: {
      modelValue: { default: () => [] },
      rangeSeparator: { default: "/" },
      valueFormat: { default: "YYYY-MM-DD HH:mm:ss" },
      type: { default: "datetime" },
      startProps: { default: () => ({}) },
      endProps: { default: () => ({}) },
      disabled: { type: Boolean, default: false },
      startDisabledDate: { type: Function, default: (startTime, endValue) => {
        if (!endValue) return false;
        return startTime.getTime() > new Date(endValue).getTime();
      } },
      endDisabledDate: { type: Function, default: (endTime, startValue) => {
        if (!startValue) return false;
        return endTime.getTime() < new Date(startValue).getTime();
      } }
    },
    emits: ["change", "focus", "update:modelValue"],
    setup(__props, { expose: __expose, emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const { t } = useLocale();
      const attrs = vue.useAttrs();
      const computedStartProps = vue.computed(() => ({ ...attrs, ...props.startProps }));
      const computedEndProps = vue.computed(() => ({ ...attrs, ...props.endProps }));
      const startPickerInstance = vue.ref();
      const endPickerInstance = vue.ref();
      const state = vue.reactive({
        start: "",
        end: ""
      });
      const formDisabled = elementPlus.useFormDisabled();
      const isFocus = vue.ref(false);
      const handleFocus = (event) => {
        isFocus.value = true;
        emit("focus", event);
      };
      const onClickOutside = () => {
        isFocus.value = false;
      };
      const subStartDisabledDate = (time) => {
        if (props.startDisabledDate && isFunction(props.startDisabledDate)) {
          return props.startDisabledDate(time, state.end);
        }
        return false;
      };
      const subEndDisabledDate = (time) => {
        if (props.endDisabledDate && isFunction(props.endDisabledDate)) {
          return props.endDisabledDate(time, state.start);
        }
        return false;
      };
      vue.watch(
        () => props.modelValue,
        (val) => {
          const [start, end] = val;
          state.start = start;
          state.end = end;
        },
        {
          immediate: true
        }
      );
      const handleChange = () => {
        const res = [state.start, state.end];
        emit("update:modelValue", res);
        emit("change", res);
      };
      __expose({
        startPickerInstance,
        endPickerInstance
      });
      return (_ctx, _cache) => {
        return vue.withDirectives((vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass(["plus-date-picker", {
              "is-focus": isFocus.value,
              "is-disabled": vue.unref(formDisabled)
            }])
          },
          [
            vue.createVNode(vue.unref(elementPlus.ElDatePicker), vue.mergeProps({
              ref_key: "startPickerInstance",
              ref: startPickerInstance,
              modelValue: state.start,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.start = $event),
              type: _ctx.type,
              "value-format": _ctx.valueFormat,
              placeholder: vue.unref(t)("plus.datepicker.startPlaceholder"),
              "disabled-date": subStartDisabledDate,
              class: "plus-date-picker__start",
              clearable: "",
              disabled: vue.unref(formDisabled)
            }, computedStartProps.value, {
              onChange: handleChange,
              onFocus: handleFocus
            }), null, 16, ["modelValue", "type", "value-format", "placeholder", "disabled"]),
            vue.createElementVNode(
              "span",
              _hoisted_1$g,
              vue.toDisplayString(_ctx.rangeSeparator),
              1
              /* TEXT */
            ),
            vue.createVNode(vue.unref(elementPlus.ElDatePicker), vue.mergeProps({
              ref_key: "endPickerInstance",
              ref: endPickerInstance,
              modelValue: state.end,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => state.end = $event),
              "value-format": _ctx.valueFormat,
              type: _ctx.type,
              placeholder: vue.unref(t)("plus.datepicker.endPlaceholder"),
              "disabled-date": subEndDisabledDate,
              class: "plus-date-picker__end",
              clearable: "",
              disabled: vue.unref(formDisabled)
            }, computedEndProps.value, {
              onChange: handleChange,
              onFocus: handleFocus
            }), null, 16, ["modelValue", "value-format", "type", "placeholder", "disabled"])
          ],
          2
          /* CLASS */
        )), [
          [vue.unref(elementPlus.ClickOutside), onClickOutside]
        ]);
      };
    }
  });

  var DatePicker = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__file", "index.vue"]]);

  const PlusDatePicker = DatePicker;

  var _sfc_main$o = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusInputTag"
    },
    __name: "index",
    props: {
      modelValue: { default: () => [] },
      trigger: { default: () => ["blur", "enter", "space"] },
      inputProps: { default: () => ({}) },
      tagProps: { default: () => ({}) },
      limit: { default: Infinity },
      formatTag: { type: Function, default: void 0 },
      retainInputValue: { type: Boolean, default: false },
      disabled: { type: Boolean, default: false }
    },
    emits: ["update:modelValue", "change", "remove", "blur", "enter", "space"],
    setup(__props, { expose: __expose, emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const inputInstance = vue.ref();
      const tagInstance = vue.ref();
      const plusInputTagInstance = vue.ref();
      const state = vue.reactive({
        tags: [],
        inputValue: "",
        isFocus: false
      });
      const formDisabled = elementPlus.useFormDisabled();
      const { t } = useLocale();
      vue.watch(
        () => props.modelValue,
        (val) => {
          state.tags = val.slice(0, props.limit);
        },
        { immediate: true }
      );
      const onClickOutside = () => {
        state.isFocus = false;
      };
      const handleClick = () => {
        var _a;
        state.isFocus = true;
        (_a = inputInstance.value) == null ? void 0 : _a.focus();
      };
      const handleClose = (tag) => {
        if (formDisabled.value) return;
        state.tags = state.tags.filter((item) => item !== tag);
        emit("remove", tag);
        emit("update:modelValue", state.tags);
        emit("change", state.tags);
      };
      const handleValue = () => {
        if (state.inputValue.trim() && !state.tags.includes(state.inputValue.trim()) && state.tags.length < props.limit) {
          state.tags.push(state.inputValue.trim());
        }
        if (!props.retainInputValue) {
          state.inputValue = "";
        }
        emit("update:modelValue", state.tags);
        emit("change", state.tags);
      };
      const handle = (event, type) => {
        emit(type, state.inputValue, event);
        const triggerList = isArray(props.trigger) ? props.trigger : isString(props.trigger) ? [props.trigger] : ["blur", "enter", "space"];
        if (triggerList.includes(type)) {
          handleValue();
        }
      };
      __expose({ inputInstance, tagInstance });
      return (_ctx, _cache) => {
        return vue.withDirectives((vue.openBlock(), vue.createElementBlock(
          "div",
          {
            ref_key: "plusInputTagInstance",
            ref: plusInputTagInstance,
            class: vue.normalizeClass(["plus-input-tag", {
              "is-focus": state.isFocus,
              "is-disabled": vue.unref(formDisabled)
            }]),
            onClick: handleClick
          },
          [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList(state.tags, (tag) => {
                return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElTag), vue.mergeProps({
                  ref_for: true,
                  ref_key: "tagInstance",
                  ref: tagInstance,
                  key: tag,
                  class: "plus-input-tag__tag"
                }, _ctx.tagProps, {
                  closable: "",
                  onClose: ($event) => handleClose(tag)
                }), {
                  default: vue.withCtx(() => [
                    vue.createTextVNode(
                      vue.toDisplayString(_ctx.formatTag && vue.unref(isFunction)(_ctx.formatTag) ? _ctx.formatTag(tag) : tag),
                      1
                      /* TEXT */
                    )
                  ]),
                  _: 2
                  /* DYNAMIC */
                }, 1040, ["onClose"]);
              }),
              128
              /* KEYED_FRAGMENT */
            )),
            state.tags.length < _ctx.limit ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElInput), vue.mergeProps({
              key: 0,
              ref_key: "inputInstance",
              ref: inputInstance,
              modelValue: state.inputValue,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.inputValue = $event),
              class: "plus-input-tag__input",
              placeholder: state.tags.length ? "" : vue.unref(t)("plus.inputTag.placeholder"),
              disabled: vue.unref(formDisabled) || state.tags.length >= _ctx.limit
            }, _ctx.inputProps, {
              clearable: "",
              onBlur: _cache[1] || (_cache[1] = ($event) => handle($event, "blur")),
              onKeyup: [
                _cache[2] || (_cache[2] = vue.withKeys(vue.withModifiers(($event) => handle($event, "enter"), ["exact"]), ["enter"])),
                _cache[3] || (_cache[3] = vue.withKeys(vue.withModifiers(($event) => handle($event, "space"), ["exact"]), ["space"]))
              ]
            }), null, 16, ["modelValue", "placeholder", "disabled"])) : vue.createCommentVNode("v-if", true)
          ],
          2
          /* CLASS */
        )), [
          [vue.unref(elementPlus.ClickOutside), onClickOutside]
        ]);
      };
    }
  });

  var InputTag = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__file", "index.vue"]]);

  const PlusInputTag = InputTag;

  const FieldComponentMap = {
    // plus
    "plus-radio": {
      component: PlusRadio,
      hasOptions: true
    },
    "plus-date-picker": {
      component: PlusDatePicker
    },
    "plus-input-tag": {
      component: PlusInputTag
    },
    // el
    autocomplete: {
      component: elementPlus.ElAutocomplete,
      props: { placeholder: "plus.field.pleaseEnter" },
      hasSelectEvent: true
    },
    cascader: {
      component: elementPlus.ElCascader,
      hasOptions: true
    },
    checkbox: {
      component: elementPlus.ElCheckboxGroup,
      children: elementPlus.ElCheckbox,
      hasVersionCompatibility: true
    },
    "color-picker": {
      component: elementPlus.ElColorPicker
    },
    "date-picker": {
      component: elementPlus.ElDatePicker,
      props: {
        startPlaceholder: "plus.datepicker.startPlaceholder",
        endPlaceholder: "plus.datepicker.endPlaceholder"
      }
    },
    "input-number": {
      component: elementPlus.ElInputNumber,
      props: { placeholder: "plus.field.pleaseEnter" }
    },
    radio: {
      component: elementPlus.ElRadioGroup,
      children: elementPlus.ElRadio,
      hasVersionCompatibility: true
    },
    rate: {
      component: elementPlus.ElRate
    },
    select: {
      component: elementPlus.ElSelect,
      children: elementPlus.ElOption
    },
    slider: {
      component: elementPlus.ElSlider
    },
    switch: {
      component: elementPlus.ElSwitch
    },
    "time-picker": {
      component: elementPlus.ElTimePicker
    },
    "time-select": {
      component: elementPlus.ElTimeSelect
    },
    transfer: {
      component: elementPlus.ElTransfer
    },
    input: {
      component: elementPlus.ElInput,
      props: { placeholder: "plus.field.pleaseEnter" }
    },
    textarea: {
      component: elementPlus.ElInput,
      props: { type: "textarea", placeholder: "plus.field.pleaseEnter" }
    },
    "tree-select": {
      component: elementPlus.ElTreeSelect
    },
    "select-v2": {
      component: elementPlus.ElSelectV2,
      hasOptions: true
    }
  };
  const hasFieldComponent = (valueType) => Object.keys(FieldComponentMap).includes(
    valueType
  );
  const getFieldComponent = (valueType) => Reflect.get(FieldComponentMap, valueType) || {};

  const _hoisted_1$f = { class: "plus-form-item__label" };
  var _sfc_main$n = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusFormItem"
    },
    __name: "index",
    props: {
      modelValue: { default: "" },
      hasLabel: { default: true },
      label: { default: "" },
      prop: {},
      fieldProps: { default: () => ({}) },
      valueType: { default: void 0 },
      options: { default: () => [] },
      formItemProps: { default: () => ({}) },
      renderField: { default: void 0 },
      renderLabel: { default: void 0 },
      tooltip: { default: "" },
      fieldSlots: { default: () => ({}) },
      fieldChildrenSlot: { default: void 0 },
      optionsMap: { default: void 0 },
      index: { default: 0 },
      clearable: { type: Boolean, default: true }
    },
    emits: ["update:modelValue", "change"],
    setup(__props, { expose: __expose, emit: __emit }) {
      const ElFormItem = elementPlus.ElFormItem;
      const ElTooltip = elementPlus.ElTooltip;
      const ElIcon = elementPlus.ElIcon;
      const ElInput = elementPlus.ElInput;
      const ElSelect = elementPlus.ElSelect;
      const ElOption = elementPlus.ElOption;
      const props = __props;
      const emit = __emit;
      const { t } = useLocale();
      const { customOptions, customOptionsIsReady } = useGetOptions(props);
      const formItemInstance = vue.ref();
      const fieldInstance = vue.ref();
      const customFormItemProps = vue.ref({});
      const customFieldProps = vue.ref({});
      const state = vue.ref();
      const customFieldPropsIsReady = vue.ref(false);
      const valueIsReady = vue.ref(false);
      const labelValue = vue.computed(() => getLabel(props.label));
      const formFieldRefs = vue.inject(TableFormFieldRefInjectionKey, {});
      const tableRowInfo = vue.inject(TableFormRowInfoInjectionKey, {});
      const params = vue.computed(() => ({
        ...props,
        ...vue.unref(tableRowInfo),
        label: labelValue.value,
        fieldProps: customFieldProps.value,
        formItemProps: customFormItemProps.value,
        options: customOptions.value
      }));
      const isArrayValue = vue.computed(() => {
        var _a, _b, _c, _d, _e, _f;
        if (props.valueType === "cascader" && ((_b = (_a = customFieldProps.value) == null ? void 0 : _a.props) == null ? void 0 : _b.emitPath) === false) {
          return false;
        }
        if (ValueIsArrayList.includes(props.valueType)) {
          return true;
        }
        if (props.valueType === "select" && ((_c = customFieldProps.value) == null ? void 0 : _c.multiple) === true) {
          return true;
        }
        if (props.valueType === "date-picker" && DatePickerValueIsArrayList.includes((_d = customFieldProps.value) == null ? void 0 : _d.type)) {
          return true;
        }
        if (props.valueType === "time-picker" && ((_e = customFieldProps.value) == null ? void 0 : _e.isRange) === true) {
          return true;
        }
        if (props.valueType === "tree-select" && ((_f = customFieldProps.value) == null ? void 0 : _f.multiple) === true) {
          return true;
        }
        return false;
      });
      const isNumberValue = vue.computed(() => {
        if (ValueIsNumberList.includes(props.valueType)) {
          return true;
        }
        return false;
      });
      const setValue = (val) => {
        if (isArrayValue.value) {
          if (isArray(val)) {
            const [start, end] = val;
            if (isDate(start) || isDate(end)) {
              state.value = [String(start), String(end)];
            } else {
              state.value = val;
            }
          } else {
            state.value = [];
          }
        } else if (isNumberValue.value) {
          state.value = val === null || val === void 0 || val === "" ? null : typeof val === "string" ? Number(val) : val;
        } else if (isDate(val)) {
          state.value = String(val);
        } else {
          state.value = val;
        }
        valueIsReady.value = true;
      };
      const commonProps = vue.computed(() => {
        const { hasOptions, hasSelectEvent, props: componentProps } = getFieldComponent(props.valueType);
        return {
          ...hasOptions ? {
            options: customOptions.value
          } : null,
          ...hasSelectEvent ? {
            onSelect: handleSelect
          } : null,
          ...componentProps,
          placeholder: (componentProps == null ? void 0 : componentProps.placeholder) ? t(componentProps == null ? void 0 : componentProps.placeholder) + labelValue.value : t("plus.field.pleaseSelect") + labelValue.value,
          ...props.valueType === "date-picker" ? {
            startPlaceholder: (componentProps == null ? void 0 : componentProps.startPlaceholder) ? t(componentProps == null ? void 0 : componentProps.startPlaceholder) : "",
            endPlaceholder: (componentProps == null ? void 0 : componentProps.startPlaceholder) ? t(componentProps == null ? void 0 : componentProps.endPlaceholder) : ""
          } : null,
          ...customFieldProps.value
        };
      });
      const getChildrenProps = (item) => {
        return {
          ...props.valueType === "select" ? {
            label: item.label,
            value: item.value
          } : versionIsLessThan260 ? {
            label: item.value
          } : {
            label: item.label,
            value: item.value
          },
          ...item.fieldItemProps
        };
      };
      const index = vue.computed(() => {
        var _a;
        return (_a = params.value.index) != null ? _a : props.index;
      });
      vue.watch(
        () => [props.formItemProps, state.value],
        () => {
          getCustomProps(props.formItemProps, state.value, vue.unref(params), vue.unref(index), "formItemProps").then((data) => {
            customFormItemProps.value = data;
          }).catch((err) => {
            throw err;
          });
        },
        {
          immediate: true,
          deep: true,
          flush: "post"
        }
      );
      vue.watch(
        () => [props.fieldProps, state.value],
        () => {
          getCustomProps(props.fieldProps, state.value, vue.unref(params), vue.unref(index), "fieldProps").then((data) => {
            customFieldProps.value = data;
            customFieldPropsIsReady.value = true;
          }).catch((err) => {
            throw err;
          });
        },
        {
          immediate: true,
          deep: true,
          flush: "post"
        }
      );
      vue.watch(
        vue.computed(() => [props.modelValue, customFieldPropsIsReady.value, customOptionsIsReady.value]),
        ([val, fieldPropsIsReady, optionsIsReady]) => {
          if (fieldPropsIsReady && optionsIsReady) {
            setValue(val);
          }
        },
        {
          immediate: true,
          flush: "post"
        }
      );
      const handleChange = (val) => {
        emit("update:modelValue", val);
        emit("change", val);
      };
      const handleSelect = ({ value }) => {
        handleChange(value);
      };
      vue.watch(fieldInstance, () => {
        formFieldRefs.value = {
          fieldInstance: fieldInstance.value,
          valueIsReady
        };
      });
      __expose({
        formItemInstance,
        fieldInstance
      });
      return (_ctx, _cache) => {
        var _a;
        return valueIsReady.value ? (vue.openBlock(), vue.createBlock(vue.unref(ElFormItem), vue.mergeProps({
          key: 0,
          ref_key: "formItemInstance",
          ref: formItemInstance,
          label: _ctx.hasLabel ? labelValue.value : "",
          prop: _ctx.prop,
          class: "plus-form-item"
        }, customFormItemProps.value, {
          "label-width": _ctx.hasLabel ? (_a = customFormItemProps.value) == null ? void 0 : _a.labelWidth : "0px"
        }), vue.createSlots({
          default: vue.withCtx(() => [
            _ctx.renderField && vue.unref(isFunction)(_ctx.renderField) ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 0 },
              [
                valueIsReady.value ? (vue.openBlock(), vue.createBlock(vue.unref(PlusRender), {
                  key: 0,
                  render: _ctx.renderField,
                  params: params.value,
                  "callback-value": state.value,
                  "custom-field-props": customFieldProps.value,
                  "render-type": "form",
                  "handle-change": handleChange
                }, null, 8, ["render", "params", "callback-value", "custom-field-props"])) : vue.createCommentVNode("v-if", true)
              ],
              64
              /* STABLE_FRAGMENT */
            )) : _ctx.$slots[vue.unref(getFieldSlotName)(_ctx.prop)] ? vue.renderSlot(_ctx.$slots, vue.unref(getFieldSlotName)(_ctx.prop), vue.mergeProps({ key: 1 }, params.value, { column: props })) : _ctx.valueType === "select" && customFieldProps.value.multiple === true ? (vue.openBlock(), vue.createBlock(vue.unref(ElSelect), vue.mergeProps({
              key: 2,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.value = $event),
              placeholder: vue.unref(t)("plus.field.pleaseSelect") + labelValue.value,
              class: "plus-form-item-field",
              clearable: _ctx.clearable
            }, customFieldProps.value, { "onUpdate:modelValue": handleChange }), vue.createSlots({
              default: vue.withCtx(() => [
                (vue.openBlock(true), vue.createElementBlock(
                  vue.Fragment,
                  null,
                  vue.renderList(vue.unref(customOptions), (item) => {
                    return vue.openBlock(), vue.createBlock(vue.unref(ElOption), vue.mergeProps({
                      key: item.label,
                      label: item.label,
                      value: item.value
                    }, item.fieldItemProps), {
                      default: vue.withCtx(() => [
                        vue.unref(isFunction)(item.fieldSlot) ? (vue.openBlock(), vue.createBlock(
                          vue.resolveDynamicComponent(item.fieldSlot),
                          vue.normalizeProps(vue.mergeProps({ key: 0 }, item)),
                          null,
                          16
                          /* FULL_PROPS */
                        )) : vue.unref(isFunction)(_ctx.fieldChildrenSlot) ? (vue.openBlock(), vue.createBlock(
                          vue.resolveDynamicComponent(_ctx.fieldChildrenSlot),
                          vue.normalizeProps(vue.mergeProps({ key: 1 }, item)),
                          null,
                          16
                          /* FULL_PROPS */
                        )) : (vue.openBlock(), vue.createElementBlock(
                          vue.Fragment,
                          { key: 2 },
                          [
                            vue.createTextVNode(
                              vue.toDisplayString(item.label),
                              1
                              /* TEXT */
                            )
                          ],
                          64
                          /* STABLE_FRAGMENT */
                        ))
                      ]),
                      _: 2
                      /* DYNAMIC */
                    }, 1040, ["label", "value"]);
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ]),
              _: 2
              /* DYNAMIC */
            }, [
              vue.renderList(_ctx.fieldSlots, (fieldSlot, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    (vue.openBlock(), vue.createBlock(
                      vue.resolveDynamicComponent(fieldSlot),
                      vue.normalizeProps(vue.guardReactiveProps(data)),
                      null,
                      16
                      /* FULL_PROPS */
                    ))
                  ])
                };
              })
            ]), 1040, ["modelValue", "placeholder", "clearable"])) : vue.unref(hasFieldComponent)(_ctx.valueType) ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 3 },
              [
                vue.createCommentVNode(" \u7EDF\u4E00\u5904\u7406 "),
                vue.createCommentVNode(" has-children  "),
                vue.unref(getFieldComponent)(_ctx.valueType).children ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(getFieldComponent)(_ctx.valueType).component), vue.mergeProps({
                  key: 0,
                  ref_key: "fieldInstance",
                  ref: fieldInstance,
                  modelValue: state.value,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => state.value = $event),
                  class: "plus-form-item-field",
                  clearable: _ctx.clearable
                }, commonProps.value, { "onUpdate:modelValue": handleChange }), vue.createSlots({
                  default: vue.withCtx(() => [
                    (vue.openBlock(true), vue.createElementBlock(
                      vue.Fragment,
                      null,
                      vue.renderList(vue.unref(customOptions), (item) => {
                        return vue.openBlock(), vue.createBlock(
                          vue.resolveDynamicComponent(vue.unref(getFieldComponent)(_ctx.valueType).children),
                          vue.mergeProps({
                            key: item.label
                          }, getChildrenProps(item)),
                          {
                            default: vue.withCtx(() => [
                              vue.unref(isFunction)(item.fieldSlot) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(item.fieldSlot), vue.mergeProps({
                                key: 0,
                                "model-value": state.value,
                                column: params.value
                              }, item), null, 16, ["model-value", "column"])) : vue.unref(isFunction)(_ctx.fieldChildrenSlot) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.fieldChildrenSlot), vue.mergeProps({
                                key: 1,
                                "model-value": state.value,
                                column: params.value
                              }, item), null, 16, ["model-value", "column"])) : (vue.openBlock(), vue.createElementBlock(
                                vue.Fragment,
                                { key: 2 },
                                [
                                  vue.createTextVNode(
                                    vue.toDisplayString(item.label),
                                    1
                                    /* TEXT */
                                  )
                                ],
                                64
                                /* STABLE_FRAGMENT */
                              ))
                            ]),
                            _: 2
                            /* DYNAMIC */
                          },
                          1040
                          /* FULL_PROPS, DYNAMIC_SLOTS */
                        );
                      }),
                      128
                      /* KEYED_FRAGMENT */
                    ))
                  ]),
                  _: 2
                  /* DYNAMIC */
                }, [
                  vue.renderList(_ctx.fieldSlots, (fieldSlot, key) => {
                    return {
                      name: key,
                      fn: vue.withCtx((data) => [
                        (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(fieldSlot), vue.mergeProps({
                          value: state.value,
                          column: params.value
                        }, data), null, 16, ["value", "column"]))
                      ])
                    };
                  })
                ]), 1040, ["modelValue", "clearable"])) : (vue.openBlock(), vue.createElementBlock(
                  vue.Fragment,
                  { key: 1 },
                  [
                    vue.createCommentVNode(" no-children  "),
                    (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(getFieldComponent)(_ctx.valueType).component), vue.mergeProps({
                      ref_key: "fieldInstance",
                      ref: fieldInstance,
                      modelValue: state.value,
                      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => state.value = $event),
                      class: "plus-form-item-field",
                      clearable: _ctx.clearable,
                      "field-children-slot": _ctx.fieldChildrenSlot
                    }, commonProps.value, { "onUpdate:modelValue": handleChange }), vue.createSlots({
                      _: 2
                      /* DYNAMIC */
                    }, [
                      vue.renderList(_ctx.fieldSlots, (fieldSlot, key) => {
                        return {
                          name: key,
                          fn: vue.withCtx((data) => [
                            (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(fieldSlot), vue.mergeProps({
                              "model-value": state.value,
                              column: params.value
                            }, data), null, 16, ["model-value", "column"]))
                          ])
                        };
                      })
                    ]), 1040, ["modelValue", "clearable", "field-children-slot"]))
                  ],
                  2112
                  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                ))
              ],
              64
              /* STABLE_FRAGMENT */
            )) : _ctx.valueType === "text" ? (vue.openBlock(), vue.createBlock(
              vue.unref(elementPlus.ElText),
              vue.mergeProps({
                key: 4,
                ref_key: "fieldInstance",
                ref: fieldInstance,
                class: "plus-form-item-field"
              }, customFieldProps.value),
              {
                default: vue.withCtx(() => [
                  vue.createTextVNode(
                    vue.toDisplayString(state.value),
                    1
                    /* TEXT */
                  )
                ]),
                _: 1
                /* STABLE */
              },
              16
              /* FULL_PROPS */
            )) : _ctx.valueType === "divider" ? (vue.openBlock(), vue.createBlock(
              vue.unref(elementPlus.ElDivider),
              vue.mergeProps({
                key: 5,
                ref_key: "fieldInstance",
                ref: fieldInstance,
                class: "plus-form-item-field"
              }, customFieldProps.value),
              {
                default: vue.withCtx(() => [
                  vue.createTextVNode(
                    vue.toDisplayString(state.value),
                    1
                    /* TEXT */
                  )
                ]),
                _: 1
                /* STABLE */
              },
              16
              /* FULL_PROPS */
            )) : (vue.openBlock(), vue.createBlock(vue.unref(ElInput), vue.mergeProps({
              key: 6,
              ref_key: "fieldInstance",
              ref: fieldInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => state.value = $event),
              class: "plus-form-item-field",
              placeholder: vue.unref(t)("plus.field.pleaseEnter") + labelValue.value,
              autocomplete: "off",
              clearable: _ctx.clearable
            }, customFieldProps.value, { "onUpdate:modelValue": handleChange }), vue.createSlots({
              _: 2
              /* DYNAMIC */
            }, [
              vue.renderList(_ctx.fieldSlots, (fieldSlot, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(fieldSlot), vue.mergeProps({
                      "model-value": state.value,
                      column: params.value
                    }, data), null, 16, ["model-value", "column"]))
                  ])
                };
              })
            ]), 1040, ["modelValue", "placeholder", "clearable"]))
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          _ctx.hasLabel ? {
            name: "label",
            fn: vue.withCtx(({ label: currentLabel }) => [
              vue.createElementVNode("span", _hoisted_1$f, [
                _ctx.renderLabel && vue.unref(isFunction)(_ctx.renderLabel) ? (vue.openBlock(), vue.createElementBlock(
                  vue.Fragment,
                  { key: 0 },
                  [
                    valueIsReady.value ? (vue.openBlock(), vue.createBlock(vue.unref(PlusRender), {
                      key: 0,
                      render: _ctx.renderLabel,
                      params: params.value,
                      "callback-value": currentLabel,
                      "custom-field-props": customFieldProps.value
                    }, null, 8, ["render", "params", "callback-value", "custom-field-props"])) : vue.createCommentVNode("v-if", true)
                  ],
                  64
                  /* STABLE_FRAGMENT */
                )) : vue.renderSlot(_ctx.$slots, vue.unref(getLabelSlotName)(_ctx.prop), vue.normalizeProps(vue.mergeProps({ key: 1 }, params.value)), () => [
                  vue.createTextVNode(
                    vue.toDisplayString(currentLabel),
                    1
                    /* TEXT */
                  )
                ]),
                _ctx.tooltip ? (vue.openBlock(), vue.createBlock(
                  vue.unref(ElTooltip),
                  vue.mergeProps({
                    key: 2,
                    placement: "top"
                  }, vue.unref(getTooltip)(_ctx.tooltip)),
                  {
                    default: vue.withCtx(() => [
                      vue.renderSlot(_ctx.$slots, "tooltip-icon", {}, () => [
                        vue.createVNode(vue.unref(ElIcon), {
                          class: "plus-table-column__label__icon",
                          size: 16
                        }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(vue.unref(question_filled_default))
                          ]),
                          _: 1
                          /* STABLE */
                        })
                      ])
                    ]),
                    _: 3
                    /* FORWARDED */
                  },
                  16
                  /* FULL_PROPS */
                )) : vue.createCommentVNode("v-if", true)
              ])
            ]),
            key: "0"
          } : void 0
        ]), 1040, ["label", "prop", "label-width"])) : vue.createCommentVNode("v-if", true);
      };
    }
  });

  var FormItem = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__file", "index.vue"]]);

  const PlusFormItem = FormItem;

  var _sfc_main$m = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusCollapseTransition"
    },
    __name: "collapse-transition",
    props: {
      collapseDuration: { default: 300 },
      collapseTransition: { type: Boolean, default: true }
    },
    setup(__props) {
      const props = __props;
      const on = {
        beforeEnter(el) {
          el.style.opacity = 0;
        },
        enter(el, done) {
          requestAnimationFrame(() => {
            el.style.transition = `opacity ${props.collapseDuration}ms linear`;
            el.style.opacity = 1;
            done();
          });
        },
        leave(el, done) {
          el.style.opacity = 0;
          setTimeout(() => {
            done();
          }, props.collapseDuration / 3 * 2);
        }
      };
      return (_ctx, _cache) => {
        return _ctx.collapseTransition ? (vue.openBlock(), vue.createBlock(
          vue.TransitionGroup,
          vue.mergeProps({
            key: 0,
            name: "plus-collapse-transition",
            css: false
          }, vue.toHandlers(on)),
          {
            default: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
            /* FORWARDED */
          },
          16
          /* FULL_PROPS */
        )) : vue.renderSlot(_ctx.$slots, "default", { key: 1 });
      };
    }
  });

  var PlusCollapseTransition = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__file", "collapse-transition.vue"]]);

  const _hoisted_1$e = {
    key: 0,
    class: "plus-form-item-extra"
  };
  var _sfc_main$l = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusFormContent"
    },
    __name: "form-content",
    props: {
      modelValue: { default: () => ({}) },
      hasLabel: { type: Boolean, default: true },
      columns: { default: () => [] },
      rowProps: { default: () => ({}) },
      colProps: { default: () => ({}) },
      collapseDuration: { default: void 0 },
      collapseTransition: { type: Boolean, default: void 0 },
      clearable: { type: Boolean, default: true }
    },
    emits: ["update:modelValue", "change"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const values = vue.ref({});
      const getHasLabel = (hasLabel) => {
        const has = vue.unref(hasLabel);
        if (isBoolean(has)) {
          return has;
        }
        return props.hasLabel;
      };
      vue.watch(
        () => props.modelValue,
        (val) => {
          values.value = val;
        },
        {
          immediate: true
        }
      );
      const getModelValue = (prop) => getValue(values.value, prop);
      const handleChange = (value, column) => {
        setValue(values.value, column.prop, value);
        emit("update:modelValue", values.value);
        emit("change", values.value, column);
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(
          vue.unref(elementPlus.ElRow),
          vue.mergeProps(_ctx.rowProps, { class: "plus-form__row" }),
          {
            default: vue.withCtx(() => [
              vue.createVNode(PlusCollapseTransition, {
                "collapse-duration": _ctx.collapseDuration,
                "collapse-transition": _ctx.collapseTransition
              }, {
                default: vue.withCtx(() => [
                  (vue.openBlock(true), vue.createElementBlock(
                    vue.Fragment,
                    null,
                    vue.renderList(_ctx.columns, (item) => {
                      return vue.openBlock(), vue.createBlock(
                        vue.unref(elementPlus.ElCol),
                        vue.mergeProps({
                          key: item.prop
                        }, item.colProps || _ctx.colProps),
                        {
                          default: vue.withCtx(() => [
                            vue.createVNode(vue.unref(PlusFormItem), vue.mergeProps({
                              "model-value": getModelValue(item.prop)
                            }, item, {
                              clearable: _ctx.clearable,
                              "has-label": getHasLabel(item.hasLabel),
                              onChange: (value) => handleChange(value, item)
                            }), vue.createSlots({
                              _: 2
                              /* DYNAMIC */
                            }, [
                              _ctx.$slots[vue.unref(getLabelSlotName)(item.prop)] ? {
                                name: vue.unref(getLabelSlotName)(item.prop),
                                fn: vue.withCtx((data) => [
                                  vue.renderSlot(_ctx.$slots, vue.unref(getLabelSlotName)(item.prop), vue.normalizeProps(vue.guardReactiveProps(data)))
                                ]),
                                key: "0"
                              } : void 0,
                              _ctx.$slots[vue.unref(getFieldSlotName)(item.prop)] ? {
                                name: vue.unref(getFieldSlotName)(item.prop),
                                fn: vue.withCtx((data) => [
                                  vue.renderSlot(_ctx.$slots, vue.unref(getFieldSlotName)(item.prop), vue.normalizeProps(vue.guardReactiveProps(data)))
                                ]),
                                key: "1"
                              } : void 0,
                              _ctx.$slots["tooltip-icon"] ? {
                                name: "tooltip-icon",
                                fn: vue.withCtx(() => [
                                  vue.renderSlot(_ctx.$slots, "tooltip-icon")
                                ]),
                                key: "2"
                              } : void 0
                            ]), 1040, ["model-value", "clearable", "has-label", "onChange"]),
                            vue.createCommentVNode(" el-form-item \u4E0B\u4E00\u884C\u989D\u5916\u7684\u5185\u5BB9 "),
                            item.renderExtra || _ctx.$slots[vue.unref(getExtraSlotName)(item.prop)] ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$e, [
                              item.renderExtra && vue.unref(isFunction)(item.renderExtra) ? (vue.openBlock(), vue.createBlock(
                                vue.resolveDynamicComponent(item.renderExtra),
                                vue.normalizeProps(vue.mergeProps({ key: 0 }, item)),
                                null,
                                16
                                /* FULL_PROPS */
                              )) : _ctx.$slots[vue.unref(getExtraSlotName)(item.prop)] ? vue.renderSlot(_ctx.$slots, vue.unref(getExtraSlotName)(item.prop), vue.normalizeProps(vue.mergeProps({ key: 1 }, item))) : vue.createCommentVNode("v-if", true)
                            ])) : vue.createCommentVNode("v-if", true)
                          ]),
                          _: 2
                          /* DYNAMIC */
                        },
                        1040
                        /* FULL_PROPS, DYNAMIC_SLOTS */
                      );
                    }),
                    128
                    /* KEYED_FRAGMENT */
                  ))
                ]),
                _: 3
                /* FORWARDED */
              }, 8, ["collapse-duration", "collapse-transition"]),
              vue.createCommentVNode(" \u641C\u7D22\u7684footer\u63D2\u69FD  "),
              vue.renderSlot(_ctx.$slots, "search-footer")
            ]),
            _: 3
            /* FORWARDED */
          },
          16
          /* FULL_PROPS */
        );
      };
    }
  });

  var PlusFormContent = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__file", "form-content.vue"]]);

  const _hoisted_1$d = { class: "plus-form__group__item__icon" };
  var _sfc_main$k = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusForm",
      inheritAttrs: false
    },
    __name: "index",
    props: {
      modelValue: { default: () => ({}) },
      defaultValues: { default: () => ({}) },
      columns: { default: () => [] },
      labelWidth: { default: "80px" },
      labelPosition: { default: "left" },
      rowProps: { default: () => ({}) },
      colProps: { default: () => ({}) },
      labelSuffix: { default: ":" },
      hasErrorTip: { type: Boolean, default: true },
      hasFooter: { type: Boolean, default: true },
      hasReset: { type: Boolean, default: true },
      hasLabel: { type: Boolean, default: true },
      submitText: { default: "" },
      resetText: { default: "" },
      submitLoading: { type: Boolean, default: false },
      footerAlign: { default: "left" },
      rules: { default: () => ({}) },
      group: { type: [Boolean, Array], default: false },
      cardProps: { default: () => ({}) },
      prevent: { type: Boolean, default: false },
      collapseDuration: { default: void 0 },
      collapseTransition: { type: Boolean, default: void 0 },
      clearable: { type: Boolean, default: true }
    },
    emits: ["update:modelValue", "submit", "change", "reset", "submitError", "validate"],
    setup(__props, { expose: __expose, emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const { t } = useLocale();
      const formInstance = vue.ref(null);
      const values = vue.ref({});
      const filterHide = (columns) => {
        return columns.filter((item) => vue.unref(item.hideInForm) !== true);
      };
      const model = vue.computed(() => values.value);
      const style = vue.computed(() => ({
        justifyContent: props.footerAlign === "left" ? "flex-start" : props.footerAlign === "center" ? "center" : "flex-end"
      }));
      const subColumns = vue.computed(() => filterHide(props.columns));
      const subGroup = vue.computed(
        () => {
          var _a;
          return isArray(props.group) ? (_a = props.group) == null ? void 0 : _a.filter((item) => vue.unref(item.hideInGroup) !== true) : props.group;
        }
      );
      const originAttrs = vue.useAttrs();
      const attrs = vue.computed(() => ({
        ...originAttrs,
        ...props.prevent ? {
          onSubmit: vue.withModifiers(
            (...arg) => {
              if ((originAttrs == null ? void 0 : originAttrs.onSubmit) && isFunction(originAttrs == null ? void 0 : originAttrs.onSubmit)) {
                originAttrs.onSubmit(...arg);
              }
            },
            ["prevent"]
          )
        } : {}
      }));
      const slots = vue.useSlots();
      const labelSlots = filterSlots(slots, getLabelSlotName());
      const fieldSlots = filterSlots(slots, getFieldSlotName());
      const extraSlots = filterSlots(slots, getExtraSlotName());
      vue.watch(
        () => props.modelValue,
        (val) => {
          values.value = val;
        },
        {
          immediate: true
        }
      );
      const handleChange = (_, column) => {
        emit("update:modelValue", values.value);
        emit("change", values.value, column);
      };
      const clearValidate = () => {
        var _a;
        (_a = formInstance.value) == null ? void 0 : _a.clearValidate();
      };
      const handleSubmit = async () => {
        var _a, _b, _c;
        try {
          const valid = await ((_a = formInstance.value) == null ? void 0 : _a.validate());
          if (valid) {
            emit("submit", values.value);
            return true;
          }
        } catch (errors) {
          if (props.hasErrorTip) {
            elementPlus.ElMessage.closeAll();
            const values2 = isPlainObject(errors) && Object.values(errors);
            const message = values2 ? (_c = (_b = values2[0]) == null ? void 0 : _b[0]) == null ? void 0 : _c.message : void 0;
            elementPlus.ElMessage.warning(message || t("plus.form.errorTip"));
          }
          emit("submitError", errors);
        }
        return false;
      };
      const handleReset = () => {
        clearValidate();
        values.value = { ...props.defaultValues };
        emit("update:modelValue", values.value);
        emit("reset", values.value);
      };
      const handleValidate = (...args) => {
        emit("validate", ...args);
      };
      __expose({
        formInstance,
        handleSubmit,
        handleReset
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElForm), vue.mergeProps({
          ref_key: "formInstance",
          ref: formInstance,
          rules: _ctx.rules,
          "label-width": _ctx.hasLabel ? _ctx.labelWidth : 0,
          class: ["plus-form", _ctx.hasLabel ? "" : "no-has-label"],
          "label-position": _ctx.labelPosition,
          "validate-on-rule-change": false,
          "label-suffix": _ctx.hasLabel ? _ctx.labelSuffix : ""
        }, attrs.value, {
          model: model.value,
          onValidate: handleValidate
        }), {
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "default", {}, () => [
              vue.createCommentVNode(" \u5206\u7EC4\u8868\u5355 "),
              subGroup.value ? (vue.openBlock(true), vue.createElementBlock(
                vue.Fragment,
                { key: 0 },
                vue.renderList(subGroup.value, (groupItem, index) => {
                  return vue.openBlock(), vue.createBlock(
                    vue.unref(elementPlus.ElCard),
                    vue.mergeProps({
                      key: vue.unref(groupItem.title)
                    }, groupItem.cardProps || _ctx.cardProps, { class: "plus-form__group__item" }),
                    {
                      header: vue.withCtx(() => [
                        vue.renderSlot(_ctx.$slots, "group-header", {
                          title: vue.unref(groupItem.title),
                          columns: groupItem.columns,
                          icon: groupItem.icon,
                          index
                        }, () => [
                          vue.createElementVNode("div", _hoisted_1$d, [
                            groupItem.icon ? (vue.openBlock(), vue.createBlock(
                              vue.unref(elementPlus.ElIcon),
                              { key: 0 },
                              {
                                default: vue.withCtx(() => [
                                  (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(groupItem.icon)))
                                ]),
                                _: 2
                                /* DYNAMIC */
                              },
                              1024
                              /* DYNAMIC_SLOTS */
                            )) : vue.createCommentVNode("v-if", true),
                            vue.createTextVNode(
                              " " + vue.toDisplayString(vue.unref(groupItem.title)),
                              1
                              /* TEXT */
                            )
                          ])
                        ])
                      ]),
                      default: vue.withCtx(() => [
                        vue.createVNode(PlusFormContent, {
                          modelValue: values.value,
                          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => values.value = $event),
                          "row-props": _ctx.rowProps,
                          "col-props": _ctx.colProps,
                          columns: filterHide(groupItem.columns),
                          "has-label": _ctx.hasLabel,
                          "collapse-transition": _ctx.collapseTransition,
                          "collapse-duration": _ctx.collapseDuration,
                          clearable: _ctx.clearable,
                          onChange: handleChange
                        }, vue.createSlots({
                          _: 2
                          /* DYNAMIC */
                        }, [
                          vue.renderList(vue.unref(labelSlots), (_, key) => {
                            return {
                              name: key,
                              fn: vue.withCtx((data) => [
                                vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                              ])
                            };
                          }),
                          vue.renderList(vue.unref(fieldSlots), (_, key) => {
                            return {
                              name: key,
                              fn: vue.withCtx((data) => [
                                vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                              ])
                            };
                          }),
                          vue.renderList(vue.unref(extraSlots), (_, key) => {
                            return {
                              name: key,
                              fn: vue.withCtx((data) => [
                                vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                              ])
                            };
                          }),
                          _ctx.$slots["tooltip-icon"] ? {
                            name: "tooltip-icon",
                            fn: vue.withCtx(() => [
                              vue.renderSlot(_ctx.$slots, "tooltip-icon")
                            ]),
                            key: "0"
                          } : void 0
                        ]), 1032, ["modelValue", "row-props", "col-props", "columns", "has-label", "collapse-transition", "collapse-duration", "clearable"])
                      ]),
                      _: 2
                      /* DYNAMIC */
                    },
                    1040
                    /* FULL_PROPS, DYNAMIC_SLOTS */
                  );
                }),
                128
                /* KEYED_FRAGMENT */
              )) : (vue.openBlock(), vue.createElementBlock(
                vue.Fragment,
                { key: 1 },
                [
                  vue.createCommentVNode(" \u666E\u901A\u8868\u5355 "),
                  vue.createVNode(PlusFormContent, {
                    modelValue: values.value,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => values.value = $event),
                    "row-props": _ctx.rowProps,
                    "col-props": _ctx.colProps,
                    columns: subColumns.value,
                    "has-label": _ctx.hasLabel,
                    "collapse-transition": _ctx.collapseTransition,
                    "collapse-duration": _ctx.collapseDuration,
                    clearable: _ctx.clearable,
                    onChange: handleChange
                  }, vue.createSlots({
                    _: 2
                    /* DYNAMIC */
                  }, [
                    vue.renderList(vue.unref(labelSlots), (_, key) => {
                      return {
                        name: key,
                        fn: vue.withCtx((data) => [
                          vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                        ])
                      };
                    }),
                    vue.renderList(vue.unref(fieldSlots), (_, key) => {
                      return {
                        name: key,
                        fn: vue.withCtx((data) => [
                          vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                        ])
                      };
                    }),
                    vue.renderList(vue.unref(extraSlots), (_, key) => {
                      return {
                        name: key,
                        fn: vue.withCtx((data) => [
                          vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                        ])
                      };
                    }),
                    _ctx.$slots["search-footer"] ? {
                      name: "search-footer",
                      fn: vue.withCtx(() => [
                        vue.renderSlot(_ctx.$slots, "search-footer")
                      ]),
                      key: "0"
                    } : void 0,
                    _ctx.$slots["tooltip-icon"] ? {
                      name: "tooltip-icon",
                      fn: vue.withCtx(() => [
                        vue.renderSlot(_ctx.$slots, "tooltip-icon")
                      ]),
                      key: "1"
                    } : void 0
                  ]), 1032, ["modelValue", "row-props", "col-props", "columns", "has-label", "collapse-transition", "collapse-duration", "clearable"])
                ],
                64
                /* STABLE_FRAGMENT */
              ))
            ]),
            _ctx.hasFooter ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: "plus-form__footer",
                style: vue.normalizeStyle(style.value)
              },
              [
                vue.renderSlot(_ctx.$slots, "footer", vue.normalizeProps(vue.guardReactiveProps({ handleReset, handleSubmit })), () => [
                  _ctx.hasReset ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElButton), {
                    key: 0,
                    onClick: handleReset
                  }, {
                    default: vue.withCtx(() => [
                      vue.createCommentVNode(" \u91CD\u7F6E "),
                      vue.createTextVNode(
                        " " + vue.toDisplayString(_ctx.resetText || vue.unref(t)("plus.form.resetText")),
                        1
                        /* TEXT */
                      )
                    ]),
                    _: 1
                    /* STABLE */
                  })) : vue.createCommentVNode("v-if", true),
                  vue.createVNode(vue.unref(elementPlus.ElButton), {
                    type: "primary",
                    loading: _ctx.submitLoading,
                    onClick: handleSubmit
                  }, {
                    default: vue.withCtx(() => [
                      vue.createCommentVNode(" \u63D0\u4EA4 "),
                      vue.createTextVNode(
                        " " + vue.toDisplayString(_ctx.submitText || vue.unref(t)("plus.form.submitText")),
                        1
                        /* TEXT */
                      )
                    ]),
                    _: 1
                    /* STABLE */
                  }, 8, ["loading"])
                ])
              ],
              4
              /* STYLE */
            )) : vue.createCommentVNode("v-if", true)
          ]),
          _: 3
          /* FORWARDED */
        }, 16, ["rules", "label-width", "class", "label-position", "label-suffix", "model"]);
      };
    }
  });

  var Form = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__file", "index.vue"]]);

  const PlusForm = Form;

  const DisplayComponentMap = {
    img: {
      component: elementPlus.ElImage,
      class: "plus-display-item__image",
      hasSlots: true
    },
    link: {
      component: elementPlus.ElLink,
      class: "plus-display-item__link",
      hasSlots: true
    },
    tag: {
      component: elementPlus.ElTag,
      hasSlots: true
    },
    progress: {
      component: elementPlus.ElProgress,
      hasSlots: true
    },
    avatar: {
      component: elementPlus.ElAvatar,
      hasSlots: true
    },
    "date-picker": {
      component: "span",
      format: formatDate
    },
    money: {
      component: "span",
      format: formatMoney
    },
    code: {
      component: "span",
      class: "plus-display-item__pre"
    }
  };
  const hasDisplayComponent = (valueType) => Object.keys(DisplayComponentMap).includes(valueType);
  const getDisplayComponent = (valueType) => Reflect.get(DisplayComponentMap, valueType) || {};

  const _hoisted_1$c = ["innerHTML"];
  const _hoisted_2$5 = { class: "plus-display-item" };
  const _hoisted_3$3 = /* @__PURE__ */ vue.createElementVNode(
    "svg",
    {
      fill: "none",
      viewBox: "0 0 24 24",
      width: "1em",
      height: "1em",
      class: "t-icon t-icon-edit-1",
      "pointer-events": "none"
    },
    [
      /* @__PURE__ */ vue.createElementVNode("path", {
        fill: "currentColor",
        d: "M16.83 1.42l5.75 5.75L7.75 22H2v-5.75L16.83 1.42zm0 8.68l2.92-2.93-2.92-2.93-2.93 2.93 2.93 2.93zm-4.34-1.51L4 17.07V20h2.93l8.48-8.49L12.5 8.6z"
      })
    ],
    -1
    /* HOISTED */
  );
  var _sfc_main$j = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusDisplayItem"
    },
    __name: "index",
    props: {
      column: { default: () => ({ prop: "", label: "" }) },
      row: { default: () => ({}) },
      index: { default: 0 },
      editable: { type: [Boolean, String], default: false },
      rest: { default: () => ({}) },
      formProps: { default: () => ({}) }
    },
    emits: ["change"],
    setup(__props, { expose: __expose, emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const customFieldProps = vue.ref({});
      const customFieldPropsIsReady = vue.ref(false);
      const customFormProps = vue.ref({});
      const customFormPropsIsReady = vue.ref(false);
      const formInstance = vue.ref();
      const { customOptions: options } = useGetOptions(props.column);
      const columns = vue.ref([]);
      const subRow = vue.ref(cloneDeep(props.row));
      const isEdit = vue.ref(false);
      const falseArray = [false, "click", "dblclick"];
      const statusValueTypes = ["select", "radio", "checkbox"];
      vue.watch(
        () => props.row,
        (val) => {
          subRow.value = cloneDeep(val);
        },
        {
          deep: true
        }
      );
      vue.watch(
        () => [props.editable, props.column.editable],
        () => {
          if (props.column.editable === true) {
            isEdit.value = true;
            return;
          }
          if (props.column.editable === false) {
            isEdit.value = false;
            return;
          }
          if (props.editable === true) {
            isEdit.value = true;
            return;
          }
          if (falseArray.includes(props.editable)) {
            isEdit.value = false;
            return;
          }
        },
        {
          immediate: true
        }
      );
      const hasEditIcon = vue.computed(
        () => (props.editable === "click" || props.editable === "dblclick") && props.column.editable !== false
      );
      const displayValue = vue.computed({
        get() {
          return getValue(subRow.value, props.column.prop);
        },
        set(value) {
          setValue(subRow.value, props.column.prop, value);
        }
      });
      const formatterValue = vue.computed(() => {
        const value = props.column.valueType === "link" ? props.column.linkText || displayValue.value : displayValue.value;
        if (!statusValueTypes.includes(props.column.valueType) && !isEdit.value) {
          if (props.column.formatter && isFunction(props.column.formatter)) {
            return props.column.formatter(value, renderParams.value);
          }
          if (displayComponent.value.format && isFunction(displayComponent.value.format)) {
            return displayComponent.value.format(
              value,
              customFieldProps.value.format || customFieldProps.value.valueFormat
            );
          }
        }
        return value;
      });
      const modelValues = vue.computed({
        get() {
          return { [props.column.prop]: displayValue.value };
        },
        set(values) {
          displayValue.value = values[props.column.prop];
        }
      });
      const isTagAndNoValue = vue.computed(
        () => props.column.valueType === "tag" && (displayValue.value === void 0 || displayValue.value === null || displayValue.value === "")
      );
      const renderParams = vue.computed(() => ({
        prop: props.column.prop,
        valueType: props.column.valueType,
        row: subRow.value,
        index: props.index,
        rowIndex: props.index,
        fieldProps: customFieldProps.value,
        options: options.value,
        ...props.rest,
        column: { ...props.rest.column, ...props.column }
      }));
      const tableRowInfo = vue.computed(() => ({
        row: subRow.value,
        index: props.index,
        rowIndex: props.index,
        ...props.rest,
        column: { ...props.rest.column, ...props.column }
      }));
      vue.provide(TableFormRowInfoInjectionKey, tableRowInfo);
      const imageUrl = vue.computed(() => {
        const option = formatterValue.value;
        if (option && isString(option)) {
          return { options: [option], url: option };
        }
        if (isArray(option)) {
          return { options: option, url: option[0] };
        }
        return { options: [], url: "" };
      });
      const getStatus = vue.computed(() => {
        var _a, _b, _c, _d, _e;
        if (((_a = props.column) == null ? void 0 : _a.customGetStatus) && isFunction((_b = props.column) == null ? void 0 : _b.customGetStatus)) {
          const option2 = (_c = props.column) == null ? void 0 : _c.customGetStatus({
            options: options.value,
            value: displayValue.value,
            row: subRow.value
          });
          return option2 || { label: "", value: "" };
        }
        if (
          // select 
          props.column.valueType === "select" && customFieldProps.value.multiple === true || // checkbox
          props.column.valueType === "checkbox"
        ) {
          const option2 = ((_d = options.value) == null ? void 0 : _d.filter((i) => {
            var _a2;
            return (_a2 = displayValue.value) == null ? void 0 : _a2.includes(i.value);
          })) || [];
          return option2;
        }
        const option = ((_e = options.value) == null ? void 0 : _e.find(
          (i) => i.value === displayValue.value
        )) || { label: "", value: "" };
        return option;
      });
      const displayComponent = vue.computed(() => getDisplayComponent(props.column.valueType));
      const displayComponentProps = vue.computed(() => {
        return {
          // img
          ...props.column.valueType === "img" ? {
            fit: "cover",
            previewTeleported: true,
            src: imageUrl.value.url,
            previewSrcList: props.column.preview !== false ? imageUrl.value.options : []
          } : null,
          // progress
          ...props.column.valueType === "progress" ? {
            percentage: formatterValue.value
          } : null,
          // link
          ...props.column.valueType === "link" ? {
            type: "primary"
          } : null,
          // avatar
          ...props.column.valueType === "avatar" ? {
            src: formatterValue.value
          } : null,
          ...customFieldProps.value
        };
      });
      vue.watch(
        () => props.column,
        (val) => {
          if (val) {
            columns.value = [val];
          }
        },
        {
          immediate: true,
          deep: true
        }
      );
      vue.watch(
        () => props.column.fieldProps,
        (val) => {
          getCustomProps(val, displayValue.value, subRow.value, props.index, "fieldProps").then((data) => {
            customFieldProps.value = data;
            customFieldPropsIsReady.value = true;
          }).catch((err) => {
            throw err;
          });
        },
        {
          immediate: true,
          deep: true
        }
      );
      vue.watch(
        () => [props.column.formProps, subRow.value],
        () => {
          getCustomProps(
            props.column.formProps,
            displayValue.value,
            subRow.value,
            props.index,
            "formProps"
          ).then((data) => {
            customFormProps.value = data;
            customFormPropsIsReady.value = true;
          }).catch((err) => {
            throw err;
          });
        },
        {
          immediate: true,
          deep: true
        }
      );
      vue.watch(
        () => props.row,
        (val) => {
          subRow.value = { ...val };
        },
        {
          deep: true
        }
      );
      const copy = (data) => {
        const url = data;
        const textarea = document.createElement("textarea");
        textarea.readOnly = true;
        textarea.style.position = "absolute";
        textarea.style.left = "-9999px";
        textarea.value = url;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand("Copy");
        textarea.remove();
      };
      const handelClickCopy = (item, row) => {
        copy(formatterValue.value);
        row.isCopy = true;
        setTimeout(() => {
          row.isCopy = false;
        }, 3e3);
      };
      const handleChange = (values) => {
        emit("change", {
          value: values[props.column.prop],
          prop: props.column.prop,
          //  value 
          row: { value: subRow.value, ...subRow.value }
        });
      };
      const startCellEdit = () => {
        if (props.column.editable === false) {
          isEdit.value = false;
          return;
        }
        isEdit.value = true;
      };
      const stopCellEdit = () => {
        if (props.column.editable === true) {
          isEdit.value = true;
          return;
        }
        isEdit.value = false;
      };
      const getDisplayItemInstance = () => {
        return {
          isEdit,
          index: props.index,
          rowIndex: props.index,
          cellIndex: props.rest.cellIndex,
          prop: props.column.prop,
          formInstance: vue.computed(() => {
            var _a;
            return (_a = formInstance.value) == null ? void 0 : _a.formInstance;
          })
        };
      };
      __expose({
        startCellEdit,
        stopCellEdit,
        getDisplayItemInstance
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          vue.Fragment,
          null,
          [
            vue.createCommentVNode(" \u8868\u5355\u7B2C\u4E00\u4F18\u5148\u7EA7 "),
            isEdit.value ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 0 },
              [
                customFormPropsIsReady.value ? (vue.openBlock(), vue.createBlock(vue.unref(PlusForm), vue.mergeProps({
                  key: 0,
                  ref_key: "formInstance",
                  ref: formInstance,
                  modelValue: modelValues.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => modelValues.value = $event),
                  model: modelValues.value,
                  columns: columns.value,
                  "has-footer": false,
                  "has-label": false
                }, { ...customFormProps.value, ..._ctx.formProps }, {
                  class: "plus-display-item__form",
                  onChange: handleChange
                }), vue.createSlots({
                  _: 2
                  /* DYNAMIC */
                }, [
                  _ctx.$slots[vue.unref(getFieldSlotName)(_ctx.column.prop)] ? {
                    name: vue.unref(getFieldSlotName)(_ctx.column.prop),
                    fn: vue.withCtx((scoped) => [
                      vue.renderSlot(_ctx.$slots, vue.unref(getFieldSlotName)(_ctx.column.prop), vue.normalizeProps(vue.guardReactiveProps(scoped)))
                    ]),
                    key: "0"
                  } : void 0,
                  _ctx.$slots[vue.unref(getExtraSlotName)(_ctx.column.prop)] ? {
                    name: vue.unref(getExtraSlotName)(_ctx.column.prop),
                    fn: vue.withCtx((scoped) => [
                      vue.renderSlot(_ctx.$slots, vue.unref(getExtraSlotName)(_ctx.column.prop), vue.normalizeProps(vue.guardReactiveProps(scoped)))
                    ]),
                    key: "1"
                  } : void 0
                ]), 1040, ["modelValue", "model", "columns"])) : vue.createCommentVNode("v-if", true)
              ],
              64
              /* STABLE_FRAGMENT */
            )) : _ctx.column.render && vue.unref(isFunction)(_ctx.column.render) ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 1 },
              [
                vue.createCommentVNode(" \u81EA\u5B9A\u4E49\u663E\u793A "),
                customFieldPropsIsReady.value ? (vue.openBlock(), vue.createBlock(vue.unref(PlusRender), {
                  key: 0,
                  render: _ctx.column.render,
                  params: renderParams.value,
                  "callback-value": displayValue.value,
                  "custom-field-props": customFieldProps.value
                }, null, 8, ["render", "params", "callback-value", "custom-field-props"])) : vue.createCommentVNode("v-if", true)
              ],
              64
              /* STABLE_FRAGMENT */
            )) : _ctx.$slots[vue.unref(getTableCellSlotName)(_ctx.column.prop)] ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 2 },
              [
                vue.createCommentVNode(" \u63D2\u69FD "),
                vue.renderSlot(_ctx.$slots, vue.unref(getTableCellSlotName)(_ctx.column.prop), vue.mergeProps({ value: displayValue.value }, renderParams.value))
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : _ctx.column.renderHTML && vue.unref(isFunction)(_ctx.column.renderHTML) ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 3 },
              [
                vue.createCommentVNode("\u663E\u793AHTML "),
                vue.createElementVNode("span", {
                  class: "plus-display-item",
                  innerHTML: _ctx.column.renderHTML(displayValue.value, renderParams.value)
                }, null, 8, _hoisted_1$c)
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : statusValueTypes.includes(_ctx.column.valueType) ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 4 },
              [
                vue.createCommentVNode(" \u72B6\u6001\u663E\u793A `select`, `radio`, `checkbox`"),
                vue.createElementVNode(
                  "span",
                  vue.mergeProps({ class: "plus-display-item plus-display-item__badge" }, customFieldProps.value, {
                    class: { "is-list": vue.unref(isArray)(getStatus.value) }
                  }),
                  [
                    vue.createCommentVNode(" \u591A\u9009 "),
                    vue.unref(isArray)(getStatus.value) ? (vue.openBlock(), vue.createElementBlock(
                      vue.Fragment,
                      { key: 0 },
                      [
                        vue.unref(isFunction)(_ctx.column.formatter) ? (vue.openBlock(), vue.createElementBlock(
                          vue.Fragment,
                          { key: 0 },
                          [
                            vue.createTextVNode(
                              vue.toDisplayString(_ctx.column.formatter(displayValue.value, renderParams.value)),
                              1
                              /* TEXT */
                            )
                          ],
                          64
                          /* STABLE_FRAGMENT */
                        )) : (vue.openBlock(true), vue.createElementBlock(
                          vue.Fragment,
                          { key: 1 },
                          vue.renderList(getStatus.value, (item) => {
                            return vue.openBlock(), vue.createElementBlock("span", {
                              key: String(item.value),
                              class: "plus-display-item__badge__item"
                            }, [
                              vue.createElementVNode(
                                "i",
                                {
                                  class: vue.normalizeClass([
                                    "plus-display-item__badge__dot",
                                    item.type && !item.color ? "plus-display-item__badge__dot--" + item.type : ""
                                  ]),
                                  style: vue.normalizeStyle({ backgroundColor: item.color })
                                },
                                null,
                                6
                                /* CLASS, STYLE */
                              ),
                              vue.createTextVNode(
                                " " + vue.toDisplayString(item.label),
                                1
                                /* TEXT */
                              )
                            ]);
                          }),
                          128
                          /* KEYED_FRAGMENT */
                        ))
                      ],
                      64
                      /* STABLE_FRAGMENT */
                    )) : (vue.openBlock(), vue.createElementBlock(
                      vue.Fragment,
                      { key: 1 },
                      [
                        vue.createCommentVNode(" \u5355\u9009 "),
                        getStatus.value.color || getStatus.value.type ? (vue.openBlock(), vue.createElementBlock(
                          "i",
                          {
                            key: 0,
                            class: vue.normalizeClass([
                              "plus-display-item__badge__dot",
                              getStatus.value.type && !getStatus.value.color ? "plus-display-item__badge__dot--" + getStatus.value.type : ""
                            ]),
                            style: vue.normalizeStyle({ backgroundColor: getStatus.value.color })
                          },
                          null,
                          6
                          /* CLASS, STYLE */
                        )) : vue.createCommentVNode("v-if", true),
                        vue.createTextVNode(
                          " " + vue.toDisplayString(vue.unref(isFunction)(_ctx.column.formatter) ? _ctx.column.formatter(displayValue.value, renderParams.value) : getStatus.value.label),
                          1
                          /* TEXT */
                        )
                      ],
                      64
                      /* STABLE_FRAGMENT */
                    ))
                  ],
                  16
                  /* FULL_PROPS */
                )
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : _ctx.column.valueType === "copy" ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 5 },
              [
                vue.createCommentVNode(" \u590D\u5236 "),
                vue.createElementVNode("span", _hoisted_2$5, [
                  vue.createTextVNode(
                    vue.toDisplayString(formatterValue.value) + " ",
                    1
                    /* TEXT */
                  ),
                  displayValue.value ? (vue.openBlock(), vue.createBlock(
                    vue.unref(elementPlus.ElIcon),
                    vue.mergeProps({
                      key: 0,
                      size: "16",
                      class: "plus-display-item__icon__copy"
                    }, customFieldProps.value, {
                      onClick: _cache[1] || (_cache[1] = ($event) => handelClickCopy(_ctx.column, subRow.value))
                    }),
                    {
                      default: vue.withCtx(() => [
                        !subRow.value.isCopy ? (vue.openBlock(), vue.createBlock(vue.unref(document_copy_default), { key: 0 })) : (vue.openBlock(), vue.createBlock(vue.unref(select_default), { key: 1 }))
                      ]),
                      _: 1
                      /* STABLE */
                    },
                    16
                    /* FULL_PROPS */
                  )) : vue.createCommentVNode("v-if", true)
                ])
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : vue.unref(hasDisplayComponent)(_ctx.column.valueType) ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 6 },
              [
                vue.createCommentVNode(" \u7EDF\u4E00\u5904\u7406 "),
                vue.createCommentVNode("has slots  "),
                displayComponent.value.hasSlots ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(isTagAndNoValue.value ? "span" : displayComponent.value.component), vue.mergeProps({
                  key: 0,
                  class: ["plus-display-item", displayComponent.value.class]
                }, { ...renderParams.value, ...displayComponentProps.value }), vue.createSlots({
                  default: vue.withCtx(() => [
                    vue.createTextVNode(
                      " " + vue.toDisplayString(formatterValue.value),
                      1
                      /* TEXT */
                    )
                  ]),
                  _: 2
                  /* DYNAMIC */
                }, [
                  vue.renderList(_ctx.column.fieldSlots, (fieldSlot, key) => {
                    return {
                      name: key,
                      fn: vue.withCtx((data) => [
                        (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(fieldSlot), vue.mergeProps({ value: displayValue.value }, { ...renderParams.value, ...data }), null, 16, ["value"]))
                      ])
                    };
                  })
                ]), 1040, ["class"])) : (vue.openBlock(), vue.createElementBlock(
                  vue.Fragment,
                  { key: 1 },
                  [
                    vue.createCommentVNode("no slots  "),
                    (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(displayComponent.value.component), vue.mergeProps({
                      class: ["plus-display-item", displayComponent.value.class]
                    }, { ...renderParams.value, ...displayComponentProps.value }), {
                      default: vue.withCtx(() => [
                        vue.createTextVNode(
                          vue.toDisplayString(formatterValue.value),
                          1
                          /* TEXT */
                        )
                      ]),
                      _: 1
                      /* STABLE */
                    }, 16, ["class"]))
                  ],
                  2112
                  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                ))
              ],
              64
              /* STABLE_FRAGMENT */
            )) : _ctx.column.valueType === "divider" ? (vue.openBlock(), vue.createBlock(
              vue.unref(elementPlus.ElDivider),
              vue.mergeProps({
                key: 7,
                ref: "fieldInstance",
                class: "plus-form-item-field"
              }, customFieldProps.value),
              {
                default: vue.withCtx(() => [
                  vue.createTextVNode(
                    vue.toDisplayString(formatterValue.value),
                    1
                    /* TEXT */
                  )
                ]),
                _: 1
                /* STABLE */
              },
              16
              /* FULL_PROPS */
            )) : (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 8 },
              [
                vue.createCommentVNode(" \u6CA1\u6709format "),
                vue.createElementVNode(
                  "span",
                  vue.mergeProps({ class: "plus-display-item" }, customFieldProps.value),
                  vue.toDisplayString(formatterValue.value),
                  17
                  /* TEXT, FULL_PROPS */
                )
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )),
            vue.renderSlot(_ctx.$slots, "edit-icon", {}, () => [
              hasEditIcon.value && !isEdit.value ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElIcon), {
                key: 0,
                size: 16,
                class: "plus-display-item__edit-icon",
                "pointer-events": "none"
              }, {
                default: vue.withCtx(() => [
                  _hoisted_3$3
                ]),
                _: 1
                /* STABLE */
              })) : vue.createCommentVNode("v-if", true)
            ])
          ],
          64
          /* STABLE_FRAGMENT */
        );
      };
    }
  });

  var DisplayItem = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__file", "index.vue"]]);

  const PlusDisplayItem = DisplayItem;

  const _hoisted_1$b = { class: "plus-table-column__header" };
  var _sfc_main$i = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusTableColumn"
    },
    __name: "table-column",
    props: {
      columns: { default: () => [] },
      editable: { type: [Boolean, String], default: false }
    },
    emits: ["formChange"],
    setup(__props, { expose: __expose, emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const plusDisplayItemInstance = vue.ref();
      const formRefs = vue.inject(TableFormRefInjectionKey);
      const setFormRef = () => {
        var _a, _b;
        if (!((_a = plusDisplayItemInstance.value) == null ? void 0 : _a.length)) return;
        const list = ((_b = plusDisplayItemInstance.value) == null ? void 0 : _b.map((item) => ({ ...item, ...item == null ? void 0 : item.getDisplayItemInstance() }))) || [];
        list.forEach((item) => {
          if (!formRefs.value[item.index]) {
            formRefs.value[item.index] = [];
          }
          set(formRefs.value[item.rowIndex], item.cellIndex, item);
        });
      };
      vue.watch(
        plusDisplayItemInstance,
        () => {
          setFormRef();
        },
        {
          deep: true,
          flush: "post"
        }
      );
      const hasPropsEditIcon = vue.computed(() => props.editable === "click" || props.editable === "dblclick");
      const getKey = (item) => getTableKey(item, true);
      const handleChange = (data, index, column, item, rest) => {
        const formChangeCallBackParams = {
          ...data,
          index,
          column: { ...column, ...item },
          rowIndex: index,
          ...rest
        };
        emit("formChange", formChangeCallBackParams);
      };
      const handleFormChange = (data) => {
        emit("formChange", data);
      };
      __expose({
        plusDisplayItemInstance
      });
      return (_ctx, _cache) => {
        const _component_PlusTableColumn = vue.resolveComponent("PlusTableColumn");
        return vue.openBlock(true), vue.createElementBlock(
          vue.Fragment,
          null,
          vue.renderList(_ctx.columns, (item, index) => {
            return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElTableColumn), vue.mergeProps({
              key: getKey(item),
              "class-name": "plus-table-column " + (hasPropsEditIcon.value ? "plus-table-column__edit" : ""),
              index
            }, item.tableColumnProps, {
              prop: item.prop,
              width: item.width,
              "min-width": item.minWidth
            }), {
              header: vue.withCtx((scoped) => [
                vue.createElementVNode("span", _hoisted_1$b, [
                  item.renderHeader && vue.unref(isFunction)(item.renderHeader) ? (vue.openBlock(), vue.createBlock(vue.unref(PlusRender), {
                    key: 0,
                    render: item.renderHeader,
                    params: { ...scoped, ...item, cellIndex: index },
                    "callback-value": vue.unref(getLabel)(item.label)
                  }, null, 8, ["render", "params", "callback-value"])) : (vue.openBlock(), vue.createElementBlock(
                    vue.Fragment,
                    { key: 1 },
                    [
                      vue.createCommentVNode("\u8868\u683C\u5355\u5143\u683CHeader\u7684\u63D2\u69FD "),
                      vue.renderSlot(_ctx.$slots, vue.unref(getTableHeaderSlotName)(item.prop), vue.mergeProps({
                        prop: item.prop,
                        label: vue.unref(getLabel)(item.label),
                        fieldProps: item.fieldProps,
                        valueType: item.valueType,
                        cellIndex: index
                      }, scoped, {
                        column: { ...scoped, ...item }
                      }), () => [
                        vue.createTextVNode(
                          vue.toDisplayString(vue.unref(getLabel)(item.label)),
                          1
                          /* TEXT */
                        )
                      ])
                    ],
                    2112
                    /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                  )),
                  item.tooltip ? (vue.openBlock(), vue.createBlock(
                    vue.unref(elementPlus.ElTooltip),
                    vue.mergeProps({
                      key: 2,
                      placement: "top"
                    }, vue.unref(getTooltip)(item.tooltip)),
                    {
                      default: vue.withCtx(() => [
                        vue.renderSlot(_ctx.$slots, "tooltip-icon", {}, () => [
                          vue.createVNode(vue.unref(elementPlus.ElIcon), {
                            class: "plus-table-column__header__icon",
                            size: 16
                          }, {
                            default: vue.withCtx(() => [
                              vue.createVNode(vue.unref(question_filled_default))
                            ]),
                            _: 1
                            /* STABLE */
                          })
                        ])
                      ]),
                      _: 2
                      /* DYNAMIC */
                    },
                    1040
                    /* FULL_PROPS, DYNAMIC_SLOTS */
                  )) : vue.createCommentVNode("v-if", true)
                ])
              ]),
              default: vue.withCtx(({ row, column, $index, ...rest }) => {
                var _a;
                return [
                  ((_a = item.children) == null ? void 0 : _a.length) ? (vue.openBlock(), vue.createElementBlock(
                    vue.Fragment,
                    { key: 0 },
                    [
                      vue.createVNode(_component_PlusTableColumn, {
                        columns: item.children,
                        editable: _ctx.editable,
                        onFormChange: handleFormChange
                      }, null, 8, ["columns", "editable"]),
                      vue.createTextVNode(
                        " " + vue.toDisplayString(item.label),
                        1
                        /* TEXT */
                      )
                    ],
                    64
                    /* STABLE_FRAGMENT */
                  )) : (vue.openBlock(), vue.createBlock(vue.unref(PlusDisplayItem), {
                    key: 1,
                    ref_for: true,
                    ref_key: "plusDisplayItemInstance",
                    ref: plusDisplayItemInstance,
                    column: item,
                    row,
                    index: $index,
                    editable: _ctx.editable,
                    rest: { column, ...rest },
                    onChange: (data) => handleChange(data, $index, column, item, rest)
                  }, vue.createSlots({
                    _: 2
                    /* DYNAMIC */
                  }, [
                    _ctx.$slots[vue.unref(getFieldSlotName)(item.prop)] ? {
                      name: vue.unref(getFieldSlotName)(item.prop),
                      fn: vue.withCtx((data) => [
                        vue.renderSlot(_ctx.$slots, vue.unref(getFieldSlotName)(item.prop), vue.normalizeProps(vue.guardReactiveProps(data)))
                      ]),
                      key: "0"
                    } : void 0,
                    _ctx.$slots[vue.unref(getExtraSlotName)(item.prop)] ? {
                      name: vue.unref(getExtraSlotName)(item.prop),
                      fn: vue.withCtx((data) => [
                        vue.renderSlot(_ctx.$slots, vue.unref(getExtraSlotName)(item.prop), vue.normalizeProps(vue.guardReactiveProps(data)))
                      ]),
                      key: "1"
                    } : void 0,
                    _ctx.$slots[vue.unref(getTableCellSlotName)(item.prop)] ? {
                      name: vue.unref(getTableCellSlotName)(item.prop),
                      fn: vue.withCtx((data) => [
                        vue.renderSlot(_ctx.$slots, vue.unref(getTableCellSlotName)(item.prop), vue.normalizeProps(vue.guardReactiveProps(data)))
                      ]),
                      key: "2"
                    } : void 0,
                    _ctx.$slots["edit-icon"] ? {
                      name: "edit-icon",
                      fn: vue.withCtx(() => [
                        vue.renderSlot(_ctx.$slots, "edit-icon")
                      ]),
                      key: "3"
                    } : void 0
                  ]), 1032, ["column", "row", "index", "editable", "rest", "onChange"]))
                ];
              }),
              _: 2
              /* DYNAMIC */
            }, 1040, ["class-name", "index", "prop", "width", "min-width"]);
          }),
          128
          /* KEYED_FRAGMENT */
        );
      };
    }
  });

  var PlusTableColumn = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__file", "table-column.vue"]]);

  var _sfc_main$h = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusTableTableColumnIndex"
    },
    __name: "table-column-index",
    props: {
      pageInfo: { default: () => ({ ...DefaultPageInfo }) },
      indexTableColumnProps: { default: () => ({}) },
      indexContentStyle: { type: [Object, Function], default: () => ({}) }
    },
    setup(__props) {
      var _a, _b, _c;
      const props = __props;
      const getTableIndex = isNumber((_a = props.indexTableColumnProps) == null ? void 0 : _a.index) ? vue.computed(() => {
        var _a2;
        return (_a2 = props.indexTableColumnProps) == null ? void 0 : _a2.index;
      }) : isFunction((_b = props.indexTableColumnProps) == null ? void 0 : _b.index) ? (_c = props.indexTableColumnProps) == null ? void 0 : _c.index : (index) => {
        var _a2, _b2;
        const i = ((((_a2 = props.pageInfo) == null ? void 0 : _a2.page) || DefaultPageInfo.page) - 1) * (((_b2 = props.pageInfo) == null ? void 0 : _b2.pageSize) || DefaultPageInfo.page) + index + 1;
        return +i;
      };
      const indexContentStyle = (row, index) => {
        if (isFunction(props.indexContentStyle)) {
          return props.indexContentStyle(
            row,
            index
          );
        } else if (isPlainObject(props.indexContentStyle)) {
          return props.indexContentStyle;
        } else {
          return {};
        }
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElTableColumn), vue.mergeProps({
          key: "index",
          label: "#",
          fixed: "left",
          type: "index",
          "class-name": "plus-table-column-index",
          width: "60",
          align: "center",
          index: vue.unref(getTableIndex)
        }, _ctx.indexTableColumnProps), {
          default: vue.withCtx(({ row, $index }) => [
            vue.unref(isFunction)(vue.unref(getTableIndex)) ? (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 0,
                class: "plus-table-column-index__content",
                style: vue.normalizeStyle(indexContentStyle(row, $index))
              },
              vue.toDisplayString(vue.unref(getTableIndex)($index)),
              5
              /* TEXT, STYLE */
            )) : (vue.openBlock(), vue.createElementBlock(
              "div",
              {
                key: 1,
                class: "plus-table-column-index__content",
                style: vue.normalizeStyle(indexContentStyle(row, $index))
              },
              vue.toDisplayString(vue.unref(getTableIndex)),
              5
              /* TEXT, STYLE */
            ))
          ]),
          _: 1
          /* STABLE */
        }, 16, ["index"]);
      };
    }
  });

  var PlusTableTableColumnIndex = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__file", "table-column-index.vue"]]);

  /**!
   * Sortable 1.15.0
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   */
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);

      if (enumerableOnly) {
        symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }

      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  var version$1 = "1.15.0";

  function userAgent(pattern) {
    if (typeof window !== 'undefined' && window.navigator) {
      return !! /*@__PURE__*/navigator.userAgent.match(pattern);
    }
  }

  var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
  var Edge = userAgent(/Edge/i);
  var FireFox = userAgent(/firefox/i);
  var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
  var IOS = userAgent(/iP(ad|od|hone)/i);
  var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

  var captureMode = {
    capture: false,
    passive: false
  };

  function on(el, event, fn) {
    el.addEventListener(event, fn, !IE11OrLess && captureMode);
  }

  function off(el, event, fn) {
    el.removeEventListener(event, fn, !IE11OrLess && captureMode);
  }

  function matches(
  /**HTMLElement*/
  el,
  /**String*/
  selector) {
    if (!selector) return;
    selector[0] === '>' && (selector = selector.substring(1));

    if (el) {
      try {
        if (el.matches) {
          return el.matches(selector);
        } else if (el.msMatchesSelector) {
          return el.msMatchesSelector(selector);
        } else if (el.webkitMatchesSelector) {
          return el.webkitMatchesSelector(selector);
        }
      } catch (_) {
        return false;
      }
    }

    return false;
  }

  function getParentOrHost(el) {
    return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
  }

  function closest(
  /**HTMLElement*/
  el,
  /**String*/
  selector,
  /**HTMLElement*/
  ctx, includeCTX) {
    if (el) {
      ctx = ctx || document;

      do {
        if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
          return el;
        }

        if (el === ctx) break;
        /* jshint boss:true */
      } while (el = getParentOrHost(el));
    }

    return null;
  }

  var R_SPACE = /\s+/g;

  function toggleClass(el, name, state) {
    if (el && name) {
      if (el.classList) {
        el.classList[state ? 'add' : 'remove'](name);
      } else {
        var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
        el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
      }
    }
  }

  function css(el, prop, val) {
    var style = el && el.style;

    if (style) {
      if (val === void 0) {
        if (document.defaultView && document.defaultView.getComputedStyle) {
          val = document.defaultView.getComputedStyle(el, '');
        } else if (el.currentStyle) {
          val = el.currentStyle;
        }

        return prop === void 0 ? val : val[prop];
      } else {
        if (!(prop in style) && prop.indexOf('webkit') === -1) {
          prop = '-webkit-' + prop;
        }

        style[prop] = val + (typeof val === 'string' ? '' : 'px');
      }
    }
  }

  function matrix(el, selfOnly) {
    var appliedTransforms = '';

    if (typeof el === 'string') {
      appliedTransforms = el;
    } else {
      do {
        var transform = css(el, 'transform');

        if (transform && transform !== 'none') {
          appliedTransforms = transform + ' ' + appliedTransforms;
        }
        /* jshint boss:true */

      } while (!selfOnly && (el = el.parentNode));
    }

    var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
    /*jshint -W056 */

    return matrixFn && new matrixFn(appliedTransforms);
  }

  function find(ctx, tagName, iterator) {
    if (ctx) {
      var list = ctx.getElementsByTagName(tagName),
          i = 0,
          n = list.length;

      if (iterator) {
        for (; i < n; i++) {
          iterator(list[i], i);
        }
      }

      return list;
    }

    return [];
  }

  function getWindowScrollingElement() {
    var scrollingElement = document.scrollingElement;

    if (scrollingElement) {
      return scrollingElement;
    } else {
      return document.documentElement;
    }
  }
  /**
   * Returns the "bounding client rect" of given element
   * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
   * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
   * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
   * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
   * @param  {[HTMLElement]} container              The parent the element will be placed in
   * @return {Object}                               The boundingClientRect of el, with specified adjustments
   */


  function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
    if (!el.getBoundingClientRect && el !== window) return;
    var elRect, top, left, bottom, right, height, width;

    if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
      elRect = el.getBoundingClientRect();
      top = elRect.top;
      left = elRect.left;
      bottom = elRect.bottom;
      right = elRect.right;
      height = elRect.height;
      width = elRect.width;
    } else {
      top = 0;
      left = 0;
      bottom = window.innerHeight;
      right = window.innerWidth;
      height = window.innerHeight;
      width = window.innerWidth;
    }

    if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
      // Adjust for translate()
      container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
      // Not needed on <= IE11

      if (!IE11OrLess) {
        do {
          if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
            var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

            top -= containerRect.top + parseInt(css(container, 'border-top-width'));
            left -= containerRect.left + parseInt(css(container, 'border-left-width'));
            bottom = top + elRect.height;
            right = left + elRect.width;
            break;
          }
          /* jshint boss:true */

        } while (container = container.parentNode);
      }
    }

    if (undoScale && el !== window) {
      // Adjust for scale()
      var elMatrix = matrix(container || el),
          scaleX = elMatrix && elMatrix.a,
          scaleY = elMatrix && elMatrix.d;

      if (elMatrix) {
        top /= scaleY;
        left /= scaleX;
        width /= scaleX;
        height /= scaleY;
        bottom = top + height;
        right = left + width;
      }
    }

    return {
      top: top,
      left: left,
      bottom: bottom,
      right: right,
      width: width,
      height: height
    };
  }
  /**
   * Checks if a side of an element is scrolled past a side of its parents
   * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
   * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
   * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
   * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
   */


  function isScrolledPast(el, elSide, parentSide) {
    var parent = getParentAutoScrollElement(el, true),
        elSideVal = getRect(el)[elSide];
    /* jshint boss:true */

    while (parent) {
      var parentSideVal = getRect(parent)[parentSide],
          visible = void 0;

      if (parentSide === 'top' || parentSide === 'left') {
        visible = elSideVal >= parentSideVal;
      } else {
        visible = elSideVal <= parentSideVal;
      }

      if (!visible) return parent;
      if (parent === getWindowScrollingElement()) break;
      parent = getParentAutoScrollElement(parent, false);
    }

    return false;
  }
  /**
   * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
   * and non-draggable elements
   * @param  {HTMLElement} el       The parent element
   * @param  {Number} childNum      The index of the child
   * @param  {Object} options       Parent Sortable's options
   * @return {HTMLElement}          The child at index childNum, or null if not found
   */


  function getChild(el, childNum, options, includeDragEl) {
    var currentChild = 0,
        i = 0,
        children = el.children;

    while (i < children.length) {
      if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
        if (currentChild === childNum) {
          return children[i];
        }

        currentChild++;
      }

      i++;
    }

    return null;
  }
  /**
   * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
   * @param  {HTMLElement} el       Parent element
   * @param  {selector} selector    Any other elements that should be ignored
   * @return {HTMLElement}          The last child, ignoring ghostEl
   */


  function lastChild(el, selector) {
    var last = el.lastElementChild;

    while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
      last = last.previousElementSibling;
    }

    return last || null;
  }
  /**
   * Returns the index of an element within its parent for a selected set of
   * elements
   * @param  {HTMLElement} el
   * @param  {selector} selector
   * @return {number}
   */


  function index(el, selector) {
    var index = 0;

    if (!el || !el.parentNode) {
      return -1;
    }
    /* jshint boss:true */


    while (el = el.previousElementSibling) {
      if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
        index++;
      }
    }

    return index;
  }
  /**
   * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
   * The value is returned in real pixels.
   * @param  {HTMLElement} el
   * @return {Array}             Offsets in the format of [left, top]
   */


  function getRelativeScrollOffset(el) {
    var offsetLeft = 0,
        offsetTop = 0,
        winScroller = getWindowScrollingElement();

    if (el) {
      do {
        var elMatrix = matrix(el),
            scaleX = elMatrix.a,
            scaleY = elMatrix.d;
        offsetLeft += el.scrollLeft * scaleX;
        offsetTop += el.scrollTop * scaleY;
      } while (el !== winScroller && (el = el.parentNode));
    }

    return [offsetLeft, offsetTop];
  }
  /**
   * Returns the index of the object within the given array
   * @param  {Array} arr   Array that may or may not hold the object
   * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
   * @return {Number}      The index of the object in the array, or -1
   */


  function indexOfObject(arr, obj) {
    for (var i in arr) {
      if (!arr.hasOwnProperty(i)) continue;

      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
      }
    }

    return -1;
  }

  function getParentAutoScrollElement(el, includeSelf) {
    // skip to window
    if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
    var elem = el;
    var gotSelf = false;

    do {
      // we don't need to get elem css if it isn't even overflowing in the first place (performance)
      if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
        var elemCSS = css(elem);

        if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
          if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
          if (gotSelf || includeSelf) return elem;
          gotSelf = true;
        }
      }
      /* jshint boss:true */

    } while (elem = elem.parentNode);

    return getWindowScrollingElement();
  }

  function extend(dst, src) {
    if (dst && src) {
      for (var key in src) {
        if (src.hasOwnProperty(key)) {
          dst[key] = src[key];
        }
      }
    }

    return dst;
  }

  function isRectEqual(rect1, rect2) {
    return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
  }

  var _throttleTimeout;

  function throttle(callback, ms) {
    return function () {
      if (!_throttleTimeout) {
        var args = arguments,
            _this = this;

        if (args.length === 1) {
          callback.call(_this, args[0]);
        } else {
          callback.apply(_this, args);
        }

        _throttleTimeout = setTimeout(function () {
          _throttleTimeout = void 0;
        }, ms);
      }
    };
  }

  function cancelThrottle() {
    clearTimeout(_throttleTimeout);
    _throttleTimeout = void 0;
  }

  function scrollBy(el, x, y) {
    el.scrollLeft += x;
    el.scrollTop += y;
  }

  function clone(el) {
    var Polymer = window.Polymer;
    var $ = window.jQuery || window.Zepto;

    if (Polymer && Polymer.dom) {
      return Polymer.dom(el).cloneNode(true);
    } else if ($) {
      return $(el).clone(true)[0];
    } else {
      return el.cloneNode(true);
    }
  }

  var expando = 'Sortable' + new Date().getTime();

  function AnimationStateManager() {
    var animationStates = [],
        animationCallbackId;
    return {
      captureAnimationState: function captureAnimationState() {
        animationStates = [];
        if (!this.options.animation) return;
        var children = [].slice.call(this.el.children);
        children.forEach(function (child) {
          if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
          animationStates.push({
            target: child,
            rect: getRect(child)
          });

          var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


          if (child.thisAnimationDuration) {
            var childMatrix = matrix(child, true);

            if (childMatrix) {
              fromRect.top -= childMatrix.f;
              fromRect.left -= childMatrix.e;
            }
          }

          child.fromRect = fromRect;
        });
      },
      addAnimationState: function addAnimationState(state) {
        animationStates.push(state);
      },
      removeAnimationState: function removeAnimationState(target) {
        animationStates.splice(indexOfObject(animationStates, {
          target: target
        }), 1);
      },
      animateAll: function animateAll(callback) {
        var _this = this;

        if (!this.options.animation) {
          clearTimeout(animationCallbackId);
          if (typeof callback === 'function') callback();
          return;
        }

        var animating = false,
            animationTime = 0;
        animationStates.forEach(function (state) {
          var time = 0,
              target = state.target,
              fromRect = target.fromRect,
              toRect = getRect(target),
              prevFromRect = target.prevFromRect,
              prevToRect = target.prevToRect,
              animatingRect = state.rect,
              targetMatrix = matrix(target, true);

          if (targetMatrix) {
            // Compensate for current animation
            toRect.top -= targetMatrix.f;
            toRect.left -= targetMatrix.e;
          }

          target.toRect = toRect;

          if (target.thisAnimationDuration) {
            // Could also check if animatingRect is between fromRect and toRect
            if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
            (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
              // If returning to same place as started from animation and on same axis
              time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
            }
          } // if fromRect != toRect: animate


          if (!isRectEqual(toRect, fromRect)) {
            target.prevFromRect = fromRect;
            target.prevToRect = toRect;

            if (!time) {
              time = _this.options.animation;
            }

            _this.animate(target, animatingRect, toRect, time);
          }

          if (time) {
            animating = true;
            animationTime = Math.max(animationTime, time);
            clearTimeout(target.animationResetTimer);
            target.animationResetTimer = setTimeout(function () {
              target.animationTime = 0;
              target.prevFromRect = null;
              target.fromRect = null;
              target.prevToRect = null;
              target.thisAnimationDuration = null;
            }, time);
            target.thisAnimationDuration = time;
          }
        });
        clearTimeout(animationCallbackId);

        if (!animating) {
          if (typeof callback === 'function') callback();
        } else {
          animationCallbackId = setTimeout(function () {
            if (typeof callback === 'function') callback();
          }, animationTime);
        }

        animationStates = [];
      },
      animate: function animate(target, currentRect, toRect, duration) {
        if (duration) {
          css(target, 'transition', '');
          css(target, 'transform', '');
          var elMatrix = matrix(this.el),
              scaleX = elMatrix && elMatrix.a,
              scaleY = elMatrix && elMatrix.d,
              translateX = (currentRect.left - toRect.left) / (scaleX || 1),
              translateY = (currentRect.top - toRect.top) / (scaleY || 1);
          target.animatingX = !!translateX;
          target.animatingY = !!translateY;
          css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
          this.forRepaintDummy = repaint(target); // repaint

          css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
          css(target, 'transform', 'translate3d(0,0,0)');
          typeof target.animated === 'number' && clearTimeout(target.animated);
          target.animated = setTimeout(function () {
            css(target, 'transition', '');
            css(target, 'transform', '');
            target.animated = false;
            target.animatingX = false;
            target.animatingY = false;
          }, duration);
        }
      }
    };
  }

  function repaint(target) {
    return target.offsetWidth;
  }

  function calculateRealTime(animatingRect, fromRect, toRect, options) {
    return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
  }

  var plugins$1 = [];
  var defaults = {
    initializeByDefault: true
  };
  var PluginManager = {
    mount: function mount(plugin) {
      // Set default static properties
      for (var option in defaults) {
        if (defaults.hasOwnProperty(option) && !(option in plugin)) {
          plugin[option] = defaults[option];
        }
      }

      plugins$1.forEach(function (p) {
        if (p.pluginName === plugin.pluginName) {
          throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
        }
      });
      plugins$1.push(plugin);
    },
    pluginEvent: function pluginEvent(eventName, sortable, evt) {
      var _this = this;

      this.eventCanceled = false;

      evt.cancel = function () {
        _this.eventCanceled = true;
      };

      var eventNameGlobal = eventName + 'Global';
      plugins$1.forEach(function (plugin) {
        if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

        if (sortable[plugin.pluginName][eventNameGlobal]) {
          sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
            sortable: sortable
          }, evt));
        } // Only fire plugin event if plugin is enabled in this sortable,
        // and plugin has event defined


        if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
          sortable[plugin.pluginName][eventName](_objectSpread2({
            sortable: sortable
          }, evt));
        }
      });
    },
    initializePlugins: function initializePlugins(sortable, el, defaults, options) {
      plugins$1.forEach(function (plugin) {
        var pluginName = plugin.pluginName;
        if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
        var initialized = new plugin(sortable, el, sortable.options);
        initialized.sortable = sortable;
        initialized.options = sortable.options;
        sortable[pluginName] = initialized; // Add default options from plugin

        _extends(defaults, initialized.defaults);
      });

      for (var option in sortable.options) {
        if (!sortable.options.hasOwnProperty(option)) continue;
        var modified = this.modifyOption(sortable, option, sortable.options[option]);

        if (typeof modified !== 'undefined') {
          sortable.options[option] = modified;
        }
      }
    },
    getEventProperties: function getEventProperties(name, sortable) {
      var eventProperties = {};
      plugins$1.forEach(function (plugin) {
        if (typeof plugin.eventProperties !== 'function') return;

        _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
      });
      return eventProperties;
    },
    modifyOption: function modifyOption(sortable, name, value) {
      var modifiedValue;
      plugins$1.forEach(function (plugin) {
        // Plugin must exist on the Sortable
        if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

        if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
          modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
        }
      });
      return modifiedValue;
    }
  };

  function dispatchEvent(_ref) {
    var sortable = _ref.sortable,
        rootEl = _ref.rootEl,
        name = _ref.name,
        targetEl = _ref.targetEl,
        cloneEl = _ref.cloneEl,
        toEl = _ref.toEl,
        fromEl = _ref.fromEl,
        oldIndex = _ref.oldIndex,
        newIndex = _ref.newIndex,
        oldDraggableIndex = _ref.oldDraggableIndex,
        newDraggableIndex = _ref.newDraggableIndex,
        originalEvent = _ref.originalEvent,
        putSortable = _ref.putSortable,
        extraEventProperties = _ref.extraEventProperties;
    sortable = sortable || rootEl && rootEl[expando];
    if (!sortable) return;
    var evt,
        options = sortable.options,
        onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent(name, {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent('Event');
      evt.initEvent(name, true, true);
    }

    evt.to = toEl || rootEl;
    evt.from = fromEl || rootEl;
    evt.item = targetEl || rootEl;
    evt.clone = cloneEl;
    evt.oldIndex = oldIndex;
    evt.newIndex = newIndex;
    evt.oldDraggableIndex = oldDraggableIndex;
    evt.newDraggableIndex = newDraggableIndex;
    evt.originalEvent = originalEvent;
    evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

    var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));

    for (var option in allEventProperties) {
      evt[option] = allEventProperties[option];
    }

    if (rootEl) {
      rootEl.dispatchEvent(evt);
    }

    if (options[onName]) {
      options[onName].call(sortable, evt);
    }
  }

  var _excluded = ["evt"];

  var pluginEvent = function pluginEvent(eventName, sortable) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        originalEvent = _ref.evt,
        data = _objectWithoutProperties(_ref, _excluded);

    PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
      dragEl: dragEl,
      parentEl: parentEl,
      ghostEl: ghostEl,
      rootEl: rootEl,
      nextEl: nextEl,
      lastDownEl: lastDownEl,
      cloneEl: cloneEl,
      cloneHidden: cloneHidden,
      dragStarted: moved,
      putSortable: putSortable,
      activeSortable: Sortable.active,
      originalEvent: originalEvent,
      oldIndex: oldIndex,
      oldDraggableIndex: oldDraggableIndex,
      newIndex: newIndex,
      newDraggableIndex: newDraggableIndex,
      hideGhostForTarget: _hideGhostForTarget,
      unhideGhostForTarget: _unhideGhostForTarget,
      cloneNowHidden: function cloneNowHidden() {
        cloneHidden = true;
      },
      cloneNowShown: function cloneNowShown() {
        cloneHidden = false;
      },
      dispatchSortableEvent: function dispatchSortableEvent(name) {
        _dispatchEvent({
          sortable: sortable,
          name: name,
          originalEvent: originalEvent
        });
      }
    }, data));
  };

  function _dispatchEvent(info) {
    dispatchEvent(_objectSpread2({
      putSortable: putSortable,
      cloneEl: cloneEl,
      targetEl: dragEl,
      rootEl: rootEl,
      oldIndex: oldIndex,
      oldDraggableIndex: oldDraggableIndex,
      newIndex: newIndex,
      newDraggableIndex: newDraggableIndex
    }, info));
  }

  var dragEl,
      parentEl,
      ghostEl,
      rootEl,
      nextEl,
      lastDownEl,
      cloneEl,
      cloneHidden,
      oldIndex,
      newIndex,
      oldDraggableIndex,
      newDraggableIndex,
      activeGroup,
      putSortable,
      awaitingDragStarted = false,
      ignoreNextClick = false,
      sortables = [],
      tapEvt,
      touchEvt,
      lastDx,
      lastDy,
      tapDistanceLeft,
      tapDistanceTop,
      moved,
      lastTarget,
      lastDirection,
      pastFirstInvertThresh = false,
      isCircumstantialInvert = false,
      targetMoveDistance,
      // For positioning ghost absolutely
  ghostRelativeParent,
      ghostRelativeParentInitialScroll = [],
      // (left, top)
  _silent = false,
      savedInputChecked = [];
  /** @const */

  var documentExists = typeof document !== 'undefined',
      PositionGhostAbsolutely = IOS,
      CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
      // This will not pass for IE9, because IE9 DnD only works on anchors
  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
      supportCssPointerEvents = function () {
    if (!documentExists) return; // false when <= IE11

    if (IE11OrLess) {
      return false;
    }

    var el = document.createElement('x');
    el.style.cssText = 'pointer-events:auto';
    return el.style.pointerEvents === 'auto';
  }(),
      _detectDirection = function _detectDirection(el, options) {
    var elCSS = css(el),
        elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
        child1 = getChild(el, 0, options),
        child2 = getChild(el, 1, options),
        firstChildCSS = child1 && css(child1),
        secondChildCSS = child2 && css(child2),
        firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
        secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

    if (elCSS.display === 'flex') {
      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
    }

    if (elCSS.display === 'grid') {
      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
    }

    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
      var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
    }

    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
  },
      _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
        dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
        dragElOppLength = vertical ? dragRect.width : dragRect.height,
        targetS1Opp = vertical ? targetRect.left : targetRect.top,
        targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
        targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  },

  /**
   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
   * @param  {Number} x      X position
   * @param  {Number} y      Y position
   * @return {HTMLElement}   Element of the first found nearest Sortable
   */
  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
    var ret;
    sortables.some(function (sortable) {
      var threshold = sortable[expando].options.emptyInsertThreshold;
      if (!threshold || lastChild(sortable)) return;
      var rect = getRect(sortable),
          insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
          insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

      if (insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  },
      _prepareGroup = function _prepareGroup(options) {
    function toFn(value, pull) {
      return function (to, from, dragEl, evt) {
        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

        if (value == null && (pull || sameGroup)) {
          // Default pull value
          // Default pull and put value if same group
          return true;
        } else if (value == null || value === false) {
          return false;
        } else if (pull && value === 'clone') {
          return value;
        } else if (typeof value === 'function') {
          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
        } else {
          var otherGroup = (pull ? to : from).options.group.name;
          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
        }
      };
    }

    var group = {};
    var originalGroup = options.group;

    if (!originalGroup || _typeof(originalGroup) != 'object') {
      originalGroup = {
        name: originalGroup
      };
    }

    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
  },
      _hideGhostForTarget = function _hideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', 'none');
    }
  },
      _unhideGhostForTarget = function _unhideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', '');
    }
  }; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


  if (documentExists && !ChromeForAndroid) {
    document.addEventListener('click', function (evt) {
      if (ignoreNextClick) {
        evt.preventDefault();
        evt.stopPropagation && evt.stopPropagation();
        evt.stopImmediatePropagation && evt.stopImmediatePropagation();
        ignoreNextClick = false;
        return false;
      }
    }, true);
  }

  var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
    if (dragEl) {
      evt = evt.touches ? evt.touches[0] : evt;

      var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

      if (nearest) {
        // Create imitation event
        var event = {};

        for (var i in evt) {
          if (evt.hasOwnProperty(i)) {
            event[i] = evt[i];
          }
        }

        event.target = event.rootEl = nearest;
        event.preventDefault = void 0;
        event.stopPropagation = void 0;

        nearest[expando]._onDragOver(event);
      }
    }
  };

  var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
    if (dragEl) {
      dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
    }
  };
  /**
   * @class  Sortable
   * @param  {HTMLElement}  el
   * @param  {Object}       [options]
   */


  function Sortable(el, options) {
    if (!(el && el.nodeType && el.nodeType === 1)) {
      throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
    }

    this.el = el; // root element

    this.options = options = _extends({}, options); // Export instance

    el[expando] = this;
    var defaults = {
      group: null,
      sort: true,
      disabled: false,
      store: null,
      handle: null,
      draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
      swapThreshold: 1,
      // percentage; 0 <= x <= 1
      invertSwap: false,
      // invert always
      invertedSwapThreshold: null,
      // will be set to same as swapThreshold if default
      removeCloneOnHide: true,
      direction: function direction() {
        return _detectDirection(el, this.options);
      },
      ghostClass: 'sortable-ghost',
      chosenClass: 'sortable-chosen',
      dragClass: 'sortable-drag',
      ignore: 'a, img',
      filter: null,
      preventOnFilter: true,
      animation: 0,
      easing: null,
      setData: function setData(dataTransfer, dragEl) {
        dataTransfer.setData('Text', dragEl.textContent);
      },
      dropBubble: false,
      dragoverBubble: false,
      dataIdAttr: 'data-id',
      delay: 0,
      delayOnTouchOnly: false,
      touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
      forceFallback: false,
      fallbackClass: 'sortable-fallback',
      fallbackOnBody: false,
      fallbackTolerance: 0,
      fallbackOffset: {
        x: 0,
        y: 0
      },
      supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,
      emptyInsertThreshold: 5
    };
    PluginManager.initializePlugins(this, el, defaults); // Set default options

    for (var name in defaults) {
      !(name in options) && (options[name] = defaults[name]);
    }

    _prepareGroup(options); // Bind all private methods


    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    } // Setup drag mode


    this.nativeDraggable = options.forceFallback ? false : supportDraggable;

    if (this.nativeDraggable) {
      // Touch start threshold cannot be greater than the native dragstart threshold
      this.options.touchStartThreshold = 1;
    } // Bind events


    if (options.supportPointer) {
      on(el, 'pointerdown', this._onTapStart);
    } else {
      on(el, 'mousedown', this._onTapStart);
      on(el, 'touchstart', this._onTapStart);
    }

    if (this.nativeDraggable) {
      on(el, 'dragover', this);
      on(el, 'dragenter', this);
    }

    sortables.push(this.el); // Restore sorting

    options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

    _extends(this, AnimationStateManager());
  }

  Sortable.prototype =
  /** @lends Sortable.prototype */
  {
    constructor: Sortable,
    _isOutsideThisEl: function _isOutsideThisEl(target) {
      if (!this.el.contains(target) && target !== this.el) {
        lastTarget = null;
      }
    },
    _getDirection: function _getDirection(evt, target) {
      return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
    },
    _onTapStart: function _onTapStart(
    /** Event|TouchEvent */
    evt) {
      if (!evt.cancelable) return;

      var _this = this,
          el = this.el,
          options = this.options,
          preventOnFilter = options.preventOnFilter,
          type = evt.type,
          touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
          target = (touch || evt).target,
          originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
          filter = options.filter;

      _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


      if (dragEl) {
        return;
      }

      if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
        return; // only left button and enabled
      } // cancel dnd if original target is content editable


      if (originalTarget.isContentEditable) {
        return;
      } // Safari ignores further event handling after mousedown


      if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
        return;
      }

      target = closest(target, options.draggable, el, false);

      if (target && target.animated) {
        return;
      }

      if (lastDownEl === target) {
        // Ignoring duplicate `down`
        return;
      } // Get the index of the dragged element within its parent


      oldIndex = index(target);
      oldDraggableIndex = index(target, options.draggable); // Check filter

      if (typeof filter === 'function') {
        if (filter.call(this, evt, target, this)) {
          _dispatchEvent({
            sortable: _this,
            rootEl: originalTarget,
            name: 'filter',
            targetEl: target,
            toEl: el,
            fromEl: el
          });

          pluginEvent('filter', _this, {
            evt: evt
          });
          preventOnFilter && evt.cancelable && evt.preventDefault();
          return; // cancel dnd
        }
      } else if (filter) {
        filter = filter.split(',').some(function (criteria) {
          criteria = closest(originalTarget, criteria.trim(), el, false);

          if (criteria) {
            _dispatchEvent({
              sortable: _this,
              rootEl: criteria,
              name: 'filter',
              targetEl: target,
              fromEl: el,
              toEl: el
            });

            pluginEvent('filter', _this, {
              evt: evt
            });
            return true;
          }
        });

        if (filter) {
          preventOnFilter && evt.cancelable && evt.preventDefault();
          return; // cancel dnd
        }
      }

      if (options.handle && !closest(originalTarget, options.handle, el, false)) {
        return;
      } // Prepare `dragstart`


      this._prepareDragStart(evt, touch, target);
    },
    _prepareDragStart: function _prepareDragStart(
    /** Event */
    evt,
    /** Touch */
    touch,
    /** HTMLElement */
    target) {
      var _this = this,
          el = _this.el,
          options = _this.options,
          ownerDocument = el.ownerDocument,
          dragStartFn;

      if (target && !dragEl && target.parentNode === el) {
        var dragRect = getRect(target);
        rootEl = el;
        dragEl = target;
        parentEl = dragEl.parentNode;
        nextEl = dragEl.nextSibling;
        lastDownEl = target;
        activeGroup = options.group;
        Sortable.dragged = dragEl;
        tapEvt = {
          target: dragEl,
          clientX: (touch || evt).clientX,
          clientY: (touch || evt).clientY
        };
        tapDistanceLeft = tapEvt.clientX - dragRect.left;
        tapDistanceTop = tapEvt.clientY - dragRect.top;
        this._lastX = (touch || evt).clientX;
        this._lastY = (touch || evt).clientY;
        dragEl.style['will-change'] = 'all';

        dragStartFn = function dragStartFn() {
          pluginEvent('delayEnded', _this, {
            evt: evt
          });

          if (Sortable.eventCanceled) {
            _this._onDrop();

            return;
          } // Delayed drag has been triggered
          // we can re-enable the events: touchmove/mousemove


          _this._disableDelayedDragEvents();

          if (!FireFox && _this.nativeDraggable) {
            dragEl.draggable = true;
          } // Bind the events: dragstart/dragend


          _this._triggerDragStart(evt, touch); // Drag start event


          _dispatchEvent({
            sortable: _this,
            name: 'choose',
            originalEvent: evt
          }); // Chosen item


          toggleClass(dragEl, options.chosenClass, true);
        }; // Disable "draggable"


        options.ignore.split(',').forEach(function (criteria) {
          find(dragEl, criteria.trim(), _disableDraggable);
        });
        on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
        on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
        on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
        on(ownerDocument, 'mouseup', _this._onDrop);
        on(ownerDocument, 'touchend', _this._onDrop);
        on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

        if (FireFox && this.nativeDraggable) {
          this.options.touchStartThreshold = 4;
          dragEl.draggable = true;
        }

        pluginEvent('delayStart', this, {
          evt: evt
        }); // Delay is impossible for native DnD in Edge or IE

        if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
          if (Sortable.eventCanceled) {
            this._onDrop();

            return;
          } // If the user moves the pointer or let go the click or touch
          // before the delay has been reached:
          // disable the delayed drag


          on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
          on(ownerDocument, 'touchend', _this._disableDelayedDrag);
          on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
          on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
          on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
          options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
          _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
        } else {
          dragStartFn();
        }
      }
    },
    _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
    /** TouchEvent|PointerEvent **/
    e) {
      var touch = e.touches ? e.touches[0] : e;

      if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
        this._disableDelayedDrag();
      }
    },
    _disableDelayedDrag: function _disableDelayedDrag() {
      dragEl && _disableDraggable(dragEl);
      clearTimeout(this._dragStartTimer);

      this._disableDelayedDragEvents();
    },
    _disableDelayedDragEvents: function _disableDelayedDragEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, 'mouseup', this._disableDelayedDrag);
      off(ownerDocument, 'touchend', this._disableDelayedDrag);
      off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
      off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
      off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
      off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
    },
    _triggerDragStart: function _triggerDragStart(
    /** Event */
    evt,
    /** Touch */
    touch) {
      touch = touch || evt.pointerType == 'touch' && evt;

      if (!this.nativeDraggable || touch) {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._onTouchMove);
        } else if (touch) {
          on(document, 'touchmove', this._onTouchMove);
        } else {
          on(document, 'mousemove', this._onTouchMove);
        }
      } else {
        on(dragEl, 'dragend', this);
        on(rootEl, 'dragstart', this._onDragStart);
      }

      try {
        if (document.selection) {
          // Timeout neccessary for IE9
          _nextTick(function () {
            document.selection.empty();
          });
        } else {
          window.getSelection().removeAllRanges();
        }
      } catch (err) {}
    },
    _dragStarted: function _dragStarted(fallback, evt) {

      awaitingDragStarted = false;

      if (rootEl && dragEl) {
        pluginEvent('dragStarted', this, {
          evt: evt
        });

        if (this.nativeDraggable) {
          on(document, 'dragover', _checkOutsideTargetEl);
        }

        var options = this.options; // Apply effect

        !fallback && toggleClass(dragEl, options.dragClass, false);
        toggleClass(dragEl, options.ghostClass, true);
        Sortable.active = this;
        fallback && this._appendGhost(); // Drag start event

        _dispatchEvent({
          sortable: this,
          name: 'start',
          originalEvent: evt
        });
      } else {
        this._nulling();
      }
    },
    _emulateDragOver: function _emulateDragOver() {
      if (touchEvt) {
        this._lastX = touchEvt.clientX;
        this._lastY = touchEvt.clientY;

        _hideGhostForTarget();

        var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        var parent = target;

        while (target && target.shadowRoot) {
          target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
          if (target === parent) break;
          parent = target;
        }

        dragEl.parentNode[expando]._isOutsideThisEl(target);

        if (parent) {
          do {
            if (parent[expando]) {
              var inserted = void 0;
              inserted = parent[expando]._onDragOver({
                clientX: touchEvt.clientX,
                clientY: touchEvt.clientY,
                target: target,
                rootEl: parent
              });

              if (inserted && !this.options.dragoverBubble) {
                break;
              }
            }

            target = parent; // store last element
          }
          /* jshint boss:true */
          while (parent = parent.parentNode);
        }

        _unhideGhostForTarget();
      }
    },
    _onTouchMove: function _onTouchMove(
    /**TouchEvent*/
    evt) {
      if (tapEvt) {
        var options = this.options,
            fallbackTolerance = options.fallbackTolerance,
            fallbackOffset = options.fallbackOffset,
            touch = evt.touches ? evt.touches[0] : evt,
            ghostMatrix = ghostEl && matrix(ghostEl, true),
            scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
            scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
            relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
            dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
            dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

        if (!Sortable.active && !awaitingDragStarted) {
          if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
            return;
          }

          this._onDragStart(evt, true);
        }

        if (ghostEl) {
          if (ghostMatrix) {
            ghostMatrix.e += dx - (lastDx || 0);
            ghostMatrix.f += dy - (lastDy || 0);
          } else {
            ghostMatrix = {
              a: 1,
              b: 0,
              c: 0,
              d: 1,
              e: dx,
              f: dy
            };
          }

          var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
          css(ghostEl, 'webkitTransform', cssMatrix);
          css(ghostEl, 'mozTransform', cssMatrix);
          css(ghostEl, 'msTransform', cssMatrix);
          css(ghostEl, 'transform', cssMatrix);
          lastDx = dx;
          lastDy = dy;
          touchEvt = touch;
        }

        evt.cancelable && evt.preventDefault();
      }
    },
    _appendGhost: function _appendGhost() {
      // Bug if using scale(): https://stackoverflow.com/questions/2637058
      // Not being adjusted for
      if (!ghostEl) {
        var container = this.options.fallbackOnBody ? document.body : rootEl,
            rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
            options = this.options; // Position absolutely

        if (PositionGhostAbsolutely) {
          // Get relatively positioned parent
          ghostRelativeParent = container;

          while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
            ghostRelativeParent = ghostRelativeParent.parentNode;
          }

          if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
            if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
            rect.top += ghostRelativeParent.scrollTop;
            rect.left += ghostRelativeParent.scrollLeft;
          } else {
            ghostRelativeParent = getWindowScrollingElement();
          }

          ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
        }

        ghostEl = dragEl.cloneNode(true);
        toggleClass(ghostEl, options.ghostClass, false);
        toggleClass(ghostEl, options.fallbackClass, true);
        toggleClass(ghostEl, options.dragClass, true);
        css(ghostEl, 'transition', '');
        css(ghostEl, 'transform', '');
        css(ghostEl, 'box-sizing', 'border-box');
        css(ghostEl, 'margin', 0);
        css(ghostEl, 'top', rect.top);
        css(ghostEl, 'left', rect.left);
        css(ghostEl, 'width', rect.width);
        css(ghostEl, 'height', rect.height);
        css(ghostEl, 'opacity', '0.8');
        css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
        css(ghostEl, 'zIndex', '100000');
        css(ghostEl, 'pointerEvents', 'none');
        Sortable.ghost = ghostEl;
        container.appendChild(ghostEl); // Set transform-origin

        css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
      }
    },
    _onDragStart: function _onDragStart(
    /**Event*/
    evt,
    /**boolean*/
    fallback) {
      var _this = this;

      var dataTransfer = evt.dataTransfer;
      var options = _this.options;
      pluginEvent('dragStart', this, {
        evt: evt
      });

      if (Sortable.eventCanceled) {
        this._onDrop();

        return;
      }

      pluginEvent('setupClone', this);

      if (!Sortable.eventCanceled) {
        cloneEl = clone(dragEl);
        cloneEl.removeAttribute("id");
        cloneEl.draggable = false;
        cloneEl.style['will-change'] = '';

        this._hideClone();

        toggleClass(cloneEl, this.options.chosenClass, false);
        Sortable.clone = cloneEl;
      } // #1143: IFrame support workaround


      _this.cloneId = _nextTick(function () {
        pluginEvent('clone', _this);
        if (Sortable.eventCanceled) return;

        if (!_this.options.removeCloneOnHide) {
          rootEl.insertBefore(cloneEl, dragEl);
        }

        _this._hideClone();

        _dispatchEvent({
          sortable: _this,
          name: 'clone'
        });
      });
      !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

      if (fallback) {
        ignoreNextClick = true;
        _this._loopId = setInterval(_this._emulateDragOver, 50);
      } else {
        // Undo what was set in _prepareDragStart before drag started
        off(document, 'mouseup', _this._onDrop);
        off(document, 'touchend', _this._onDrop);
        off(document, 'touchcancel', _this._onDrop);

        if (dataTransfer) {
          dataTransfer.effectAllowed = 'move';
          options.setData && options.setData.call(_this, dataTransfer, dragEl);
        }

        on(document, 'drop', _this); // #1276 fix:

        css(dragEl, 'transform', 'translateZ(0)');
      }

      awaitingDragStarted = true;
      _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
      on(document, 'selectstart', _this);
      moved = true;

      if (Safari) {
        css(document.body, 'user-select', 'none');
      }
    },
    // Returns true - if no further action is needed (either inserted or another condition)
    _onDragOver: function _onDragOver(
    /**Event*/
    evt) {
      var el = this.el,
          target = evt.target,
          dragRect,
          targetRect,
          revert,
          options = this.options,
          group = options.group,
          activeSortable = Sortable.active,
          isOwner = activeGroup === group,
          canSort = options.sort,
          fromSortable = putSortable || activeSortable,
          vertical,
          _this = this,
          completedFired = false;

      if (_silent) return;

      function dragOverEvent(name, extra) {
        pluginEvent(name, _this, _objectSpread2({
          evt: evt,
          isOwner: isOwner,
          axis: vertical ? 'vertical' : 'horizontal',
          revert: revert,
          dragRect: dragRect,
          targetRect: targetRect,
          canSort: canSort,
          fromSortable: fromSortable,
          target: target,
          completed: completed,
          onMove: function onMove(target, after) {
            return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
          },
          changed: changed
        }, extra));
      } // Capture animation state


      function capture() {
        dragOverEvent('dragOverAnimationCapture');

        _this.captureAnimationState();

        if (_this !== fromSortable) {
          fromSortable.captureAnimationState();
        }
      } // Return invocation when dragEl is inserted (or completed)


      function completed(insertion) {
        dragOverEvent('dragOverCompleted', {
          insertion: insertion
        });

        if (insertion) {
          // Clones must be hidden before folding animation to capture dragRectAbsolute properly
          if (isOwner) {
            activeSortable._hideClone();
          } else {
            activeSortable._showClone(_this);
          }

          if (_this !== fromSortable) {
            // Set ghost class to new sortable's ghost class
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
            toggleClass(dragEl, options.ghostClass, true);
          }

          if (putSortable !== _this && _this !== Sortable.active) {
            putSortable = _this;
          } else if (_this === Sortable.active && putSortable) {
            putSortable = null;
          } // Animation


          if (fromSortable === _this) {
            _this._ignoreWhileAnimating = target;
          }

          _this.animateAll(function () {
            dragOverEvent('dragOverAnimationComplete');
            _this._ignoreWhileAnimating = null;
          });

          if (_this !== fromSortable) {
            fromSortable.animateAll();
            fromSortable._ignoreWhileAnimating = null;
          }
        } // Null lastTarget if it is not inside a previously swapped element


        if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
          lastTarget = null;
        } // no bubbling and not fallback


        if (!options.dragoverBubble && !evt.rootEl && target !== document) {
          dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


          !insertion && nearestEmptyInsertDetectEvent(evt);
        }

        !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
        return completedFired = true;
      } // Call when dragEl has been inserted


      function changed() {
        newIndex = index(dragEl);
        newDraggableIndex = index(dragEl, options.draggable);

        _dispatchEvent({
          sortable: _this,
          name: 'change',
          toEl: el,
          newIndex: newIndex,
          newDraggableIndex: newDraggableIndex,
          originalEvent: evt
        });
      }

      if (evt.preventDefault !== void 0) {
        evt.cancelable && evt.preventDefault();
      }

      target = closest(target, options.draggable, el, true);
      dragOverEvent('dragOver');
      if (Sortable.eventCanceled) return completedFired;

      if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
        return completed(false);
      }

      ignoreNextClick = false;

      if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
      : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
        vertical = this._getDirection(evt, target) === 'vertical';
        dragRect = getRect(dragEl);
        dragOverEvent('dragOverValid');
        if (Sortable.eventCanceled) return completedFired;

        if (revert) {
          parentEl = rootEl; // actualization

          capture();

          this._hideClone();

          dragOverEvent('revert');

          if (!Sortable.eventCanceled) {
            if (nextEl) {
              rootEl.insertBefore(dragEl, nextEl);
            } else {
              rootEl.appendChild(dragEl);
            }
          }

          return completed(true);
        }

        var elLastChild = lastChild(el, options.draggable);

        if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
          // Insert to end of list
          // If already at end of list: Do not insert
          if (elLastChild === dragEl) {
            return completed(false);
          } // if there is a last element, it is the target


          if (elLastChild && el === evt.target) {
            target = elLastChild;
          }

          if (target) {
            targetRect = getRect(target);
          }

          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
            capture();

            if (elLastChild && elLastChild.nextSibling) {
              // the last draggable element is not the last node
              el.insertBefore(dragEl, elLastChild.nextSibling);
            } else {
              el.appendChild(dragEl);
            }

            parentEl = el; // actualization

            changed();
            return completed(true);
          }
        } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
          // Insert to start of list
          var firstChild = getChild(el, 0, options, true);

          if (firstChild === dragEl) {
            return completed(false);
          }

          target = firstChild;
          targetRect = getRect(target);

          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
            capture();
            el.insertBefore(dragEl, firstChild);
            parentEl = el; // actualization

            changed();
            return completed(true);
          }
        } else if (target.parentNode === el) {
          targetRect = getRect(target);
          var direction = 0,
              targetBeforeFirstSwap,
              differentLevel = dragEl.parentNode !== el,
              differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
              side1 = vertical ? 'top' : 'left',
              scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
              scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

          if (lastTarget !== target) {
            targetBeforeFirstSwap = targetRect[side1];
            pastFirstInvertThresh = false;
            isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
          }

          direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
          var sibling;

          if (direction !== 0) {
            // Check if target is beside dragEl in respective direction (ignoring hidden elements)
            var dragIndex = index(dragEl);

            do {
              dragIndex -= direction;
              sibling = parentEl.children[dragIndex];
            } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
          } // If dragEl is already beside target: Do not insert


          if (direction === 0 || sibling === target) {
            return completed(false);
          }

          lastTarget = target;
          lastDirection = direction;
          var nextSibling = target.nextElementSibling,
              after = false;
          after = direction === 1;

          var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

          if (moveVector !== false) {
            if (moveVector === 1 || moveVector === -1) {
              after = moveVector === 1;
            }

            _silent = true;
            setTimeout(_unsilent, 30);
            capture();

            if (after && !nextSibling) {
              el.appendChild(dragEl);
            } else {
              target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
            } // Undo chrome's scroll adjustment (has no effect on other browsers)


            if (scrolledPastTop) {
              scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
            }

            parentEl = dragEl.parentNode; // actualization
            // must be done before animation

            if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
              targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
            }

            changed();
            return completed(true);
          }
        }

        if (el.contains(dragEl)) {
          return completed(false);
        }
      }

      return false;
    },
    _ignoreWhileAnimating: null,
    _offMoveEvents: function _offMoveEvents() {
      off(document, 'mousemove', this._onTouchMove);
      off(document, 'touchmove', this._onTouchMove);
      off(document, 'pointermove', this._onTouchMove);
      off(document, 'dragover', nearestEmptyInsertDetectEvent);
      off(document, 'mousemove', nearestEmptyInsertDetectEvent);
      off(document, 'touchmove', nearestEmptyInsertDetectEvent);
    },
    _offUpEvents: function _offUpEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, 'mouseup', this._onDrop);
      off(ownerDocument, 'touchend', this._onDrop);
      off(ownerDocument, 'pointerup', this._onDrop);
      off(ownerDocument, 'touchcancel', this._onDrop);
      off(document, 'selectstart', this);
    },
    _onDrop: function _onDrop(
    /**Event*/
    evt) {
      var el = this.el,
          options = this.options; // Get the index of the dragged element within its parent

      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      pluginEvent('drop', this, {
        evt: evt
      });
      parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);

      if (Sortable.eventCanceled) {
        this._nulling();

        return;
      }

      awaitingDragStarted = false;
      isCircumstantialInvert = false;
      pastFirstInvertThresh = false;
      clearInterval(this._loopId);
      clearTimeout(this._dragStartTimer);

      _cancelNextTick(this.cloneId);

      _cancelNextTick(this._dragStartId); // Unbind events


      if (this.nativeDraggable) {
        off(document, 'drop', this);
        off(el, 'dragstart', this._onDragStart);
      }

      this._offMoveEvents();

      this._offUpEvents();

      if (Safari) {
        css(document.body, 'user-select', '');
      }

      css(dragEl, 'transform', '');

      if (evt) {
        if (moved) {
          evt.cancelable && evt.preventDefault();
          !options.dropBubble && evt.stopPropagation();
        }

        ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
          // Remove clone(s)
          cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
        }

        if (dragEl) {
          if (this.nativeDraggable) {
            off(dragEl, 'dragend', this);
          }

          _disableDraggable(dragEl);

          dragEl.style['will-change'] = ''; // Remove classes
          // ghostClass is added in dragStarted

          if (moved && !awaitingDragStarted) {
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
          }

          toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

          _dispatchEvent({
            sortable: this,
            name: 'unchoose',
            toEl: parentEl,
            newIndex: null,
            newDraggableIndex: null,
            originalEvent: evt
          });

          if (rootEl !== parentEl) {
            if (newIndex >= 0) {
              // Add event
              _dispatchEvent({
                rootEl: parentEl,
                name: 'add',
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              }); // Remove event


              _dispatchEvent({
                sortable: this,
                name: 'remove',
                toEl: parentEl,
                originalEvent: evt
              }); // drag from one list and drop into another


              _dispatchEvent({
                rootEl: parentEl,
                name: 'sort',
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });

              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }

            putSortable && putSortable.save();
          } else {
            if (newIndex !== oldIndex) {
              if (newIndex >= 0) {
                // drag & drop within the same list
                _dispatchEvent({
                  sortable: this,
                  name: 'update',
                  toEl: parentEl,
                  originalEvent: evt
                });

                _dispatchEvent({
                  sortable: this,
                  name: 'sort',
                  toEl: parentEl,
                  originalEvent: evt
                });
              }
            }
          }

          if (Sortable.active) {
            /* jshint eqnull:true */
            if (newIndex == null || newIndex === -1) {
              newIndex = oldIndex;
              newDraggableIndex = oldDraggableIndex;
            }

            _dispatchEvent({
              sortable: this,
              name: 'end',
              toEl: parentEl,
              originalEvent: evt
            }); // Save sorting


            this.save();
          }
        }
      }

      this._nulling();
    },
    _nulling: function _nulling() {
      pluginEvent('nulling', this);
      rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
      savedInputChecked.forEach(function (el) {
        el.checked = true;
      });
      savedInputChecked.length = lastDx = lastDy = 0;
    },
    handleEvent: function handleEvent(
    /**Event*/
    evt) {
      switch (evt.type) {
        case 'drop':
        case 'dragend':
          this._onDrop(evt);

          break;

        case 'dragenter':
        case 'dragover':
          if (dragEl) {
            this._onDragOver(evt);

            _globalDragOver(evt);
          }

          break;

        case 'selectstart':
          evt.preventDefault();
          break;
      }
    },

    /**
     * Serializes the item into an array of string.
     * @returns {String[]}
     */
    toArray: function toArray() {
      var order = [],
          el,
          children = this.el.children,
          i = 0,
          n = children.length,
          options = this.options;

      for (; i < n; i++) {
        el = children[i];

        if (closest(el, options.draggable, this.el, false)) {
          order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
        }
      }

      return order;
    },

    /**
     * Sorts the elements according to the array.
     * @param  {String[]}  order  order of the items
     */
    sort: function sort(order, useAnimation) {
      var items = {},
          rootEl = this.el;
      this.toArray().forEach(function (id, i) {
        var el = rootEl.children[i];

        if (closest(el, this.options.draggable, rootEl, false)) {
          items[id] = el;
        }
      }, this);
      useAnimation && this.captureAnimationState();
      order.forEach(function (id) {
        if (items[id]) {
          rootEl.removeChild(items[id]);
          rootEl.appendChild(items[id]);
        }
      });
      useAnimation && this.animateAll();
    },

    /**
     * Save the current sorting
     */
    save: function save() {
      var store = this.options.store;
      store && store.set && store.set(this);
    },

    /**
     * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
     * @param   {HTMLElement}  el
     * @param   {String}       [selector]  default: `options.draggable`
     * @returns {HTMLElement|null}
     */
    closest: function closest$1(el, selector) {
      return closest(el, selector || this.options.draggable, this.el, false);
    },

    /**
     * Set/get option
     * @param   {string} name
     * @param   {*}      [value]
     * @returns {*}
     */
    option: function option(name, value) {
      var options = this.options;

      if (value === void 0) {
        return options[name];
      } else {
        var modifiedValue = PluginManager.modifyOption(this, name, value);

        if (typeof modifiedValue !== 'undefined') {
          options[name] = modifiedValue;
        } else {
          options[name] = value;
        }

        if (name === 'group') {
          _prepareGroup(options);
        }
      }
    },

    /**
     * Destroy
     */
    destroy: function destroy() {
      pluginEvent('destroy', this);
      var el = this.el;
      el[expando] = null;
      off(el, 'mousedown', this._onTapStart);
      off(el, 'touchstart', this._onTapStart);
      off(el, 'pointerdown', this._onTapStart);

      if (this.nativeDraggable) {
        off(el, 'dragover', this);
        off(el, 'dragenter', this);
      } // Remove draggable attributes


      Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
        el.removeAttribute('draggable');
      });

      this._onDrop();

      this._disableDelayedDragEvents();

      sortables.splice(sortables.indexOf(this.el), 1);
      this.el = el = null;
    },
    _hideClone: function _hideClone() {
      if (!cloneHidden) {
        pluginEvent('hideClone', this);
        if (Sortable.eventCanceled) return;
        css(cloneEl, 'display', 'none');

        if (this.options.removeCloneOnHide && cloneEl.parentNode) {
          cloneEl.parentNode.removeChild(cloneEl);
        }

        cloneHidden = true;
      }
    },
    _showClone: function _showClone(putSortable) {
      if (putSortable.lastPutMode !== 'clone') {
        this._hideClone();

        return;
      }

      if (cloneHidden) {
        pluginEvent('showClone', this);
        if (Sortable.eventCanceled) return; // show clone at dragEl or original position

        if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
          rootEl.insertBefore(cloneEl, dragEl);
        } else if (nextEl) {
          rootEl.insertBefore(cloneEl, nextEl);
        } else {
          rootEl.appendChild(cloneEl);
        }

        if (this.options.group.revertClone) {
          this.animate(dragEl, cloneEl);
        }

        css(cloneEl, 'display', '');
        cloneHidden = false;
      }
    }
  };

  function _globalDragOver(
  /**Event*/
  evt) {
    if (evt.dataTransfer) {
      evt.dataTransfer.dropEffect = 'move';
    }

    evt.cancelable && evt.preventDefault();
  }

  function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
    var evt,
        sortable = fromEl[expando],
        onMoveFn = sortable.options.onMove,
        retVal; // Support for new CustomEvent feature

    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent('move', {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent('Event');
      evt.initEvent('move', true, true);
    }

    evt.to = toEl;
    evt.from = fromEl;
    evt.dragged = dragEl;
    evt.draggedRect = dragRect;
    evt.related = targetEl || toEl;
    evt.relatedRect = targetRect || getRect(toEl);
    evt.willInsertAfter = willInsertAfter;
    evt.originalEvent = originalEvent;
    fromEl.dispatchEvent(evt);

    if (onMoveFn) {
      retVal = onMoveFn.call(sortable, evt, originalEvent);
    }

    return retVal;
  }

  function _disableDraggable(el) {
    el.draggable = false;
  }

  function _unsilent() {
    _silent = false;
  }

  function _ghostIsFirst(evt, vertical, sortable) {
    var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
    var spacer = 10;
    return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
  }

  function _ghostIsLast(evt, vertical, sortable) {
    var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
    var spacer = 10;
    return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
  }

  function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
    var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
        targetLength = vertical ? targetRect.height : targetRect.width,
        targetS1 = vertical ? targetRect.top : targetRect.left,
        targetS2 = vertical ? targetRect.bottom : targetRect.right,
        invert = false;

    if (!invertSwap) {
      // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
      if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
        // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
        // check if past first invert threshold on side opposite of lastDirection
        if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
          // past first invert threshold, do not restrict inverted threshold to dragEl shadow
          pastFirstInvertThresh = true;
        }

        if (!pastFirstInvertThresh) {
          // dragEl shadow (target move distance shadow)
          if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
          : mouseOnAxis > targetS2 - targetMoveDistance) {
            return -lastDirection;
          }
        } else {
          invert = true;
        }
      } else {
        // Regular
        if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
          return _getInsertDirection(target);
        }
      }
    }

    invert = invert || invertSwap;

    if (invert) {
      // Invert of regular
      if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
        return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
      }
    }

    return 0;
  }
  /**
   * Gets the direction dragEl must be swapped relative to target in order to make it
   * seem that dragEl has been "inserted" into that element's position
   * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
   * @return {Number}                   Direction dragEl must be swapped
   */


  function _getInsertDirection(target) {
    if (index(dragEl) < index(target)) {
      return 1;
    } else {
      return -1;
    }
  }
  /**
   * Generate id
   * @param   {HTMLElement} el
   * @returns {String}
   * @private
   */


  function _generateId(el) {
    var str = el.tagName + el.className + el.src + el.href + el.textContent,
        i = str.length,
        sum = 0;

    while (i--) {
      sum += str.charCodeAt(i);
    }

    return sum.toString(36);
  }

  function _saveInputCheckedState(root) {
    savedInputChecked.length = 0;
    var inputs = root.getElementsByTagName('input');
    var idx = inputs.length;

    while (idx--) {
      var el = inputs[idx];
      el.checked && savedInputChecked.push(el);
    }
  }

  function _nextTick(fn) {
    return setTimeout(fn, 0);
  }

  function _cancelNextTick(id) {
    return clearTimeout(id);
  } // Fixed #973:


  if (documentExists) {
    on(document, 'touchmove', function (evt) {
      if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
        evt.preventDefault();
      }
    });
  } // Export utils


  Sortable.utils = {
    on: on,
    off: off,
    css: css,
    find: find,
    is: function is(el, selector) {
      return !!closest(el, selector, el, false);
    },
    extend: extend,
    throttle: throttle,
    closest: closest,
    toggleClass: toggleClass,
    clone: clone,
    index: index,
    nextTick: _nextTick,
    cancelNextTick: _cancelNextTick,
    detectDirection: _detectDirection,
    getChild: getChild
  };
  /**
   * Get the Sortable instance of an element
   * @param  {HTMLElement} element The element
   * @return {Sortable|undefined}         The instance of Sortable
   */

  Sortable.get = function (element) {
    return element[expando];
  };
  /**
   * Mount a plugin to Sortable
   * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
   */


  Sortable.mount = function () {
    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }

    if (plugins[0].constructor === Array) plugins = plugins[0];
    plugins.forEach(function (plugin) {
      if (!plugin.prototype || !plugin.prototype.constructor) {
        throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
      }

      if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
      PluginManager.mount(plugin);
    });
  };
  /**
   * Create sortable instance
   * @param {HTMLElement}  el
   * @param {Object}      [options]
   */


  Sortable.create = function (el, options) {
    return new Sortable(el, options);
  }; // Export


  Sortable.version = version$1;

  var autoScrolls = [],
      scrollEl,
      scrollRootEl,
      scrolling = false,
      lastAutoScrollX,
      lastAutoScrollY,
      touchEvt$1,
      pointerElemChangedInterval;

  function AutoScrollPlugin() {
    function AutoScroll() {
      this.defaults = {
        scroll: true,
        forceAutoScrollFallback: false,
        scrollSensitivity: 30,
        scrollSpeed: 10,
        bubbleScroll: true
      }; // Bind all private methods

      for (var fn in this) {
        if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
          this[fn] = this[fn].bind(this);
        }
      }
    }

    AutoScroll.prototype = {
      dragStarted: function dragStarted(_ref) {
        var originalEvent = _ref.originalEvent;

        if (this.sortable.nativeDraggable) {
          on(document, 'dragover', this._handleAutoScroll);
        } else {
          if (this.options.supportPointer) {
            on(document, 'pointermove', this._handleFallbackAutoScroll);
          } else if (originalEvent.touches) {
            on(document, 'touchmove', this._handleFallbackAutoScroll);
          } else {
            on(document, 'mousemove', this._handleFallbackAutoScroll);
          }
        }
      },
      dragOverCompleted: function dragOverCompleted(_ref2) {
        var originalEvent = _ref2.originalEvent;

        // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
        if (!this.options.dragOverBubble && !originalEvent.rootEl) {
          this._handleAutoScroll(originalEvent);
        }
      },
      drop: function drop() {
        if (this.sortable.nativeDraggable) {
          off(document, 'dragover', this._handleAutoScroll);
        } else {
          off(document, 'pointermove', this._handleFallbackAutoScroll);
          off(document, 'touchmove', this._handleFallbackAutoScroll);
          off(document, 'mousemove', this._handleFallbackAutoScroll);
        }

        clearPointerElemChangedInterval();
        clearAutoScrolls();
        cancelThrottle();
      },
      nulling: function nulling() {
        touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
        autoScrolls.length = 0;
      },
      _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
        this._handleAutoScroll(evt, true);
      },
      _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
        var _this = this;

        var x = (evt.touches ? evt.touches[0] : evt).clientX,
            y = (evt.touches ? evt.touches[0] : evt).clientY,
            elem = document.elementFromPoint(x, y);
        touchEvt$1 = evt; // IE does not seem to have native autoscroll,
        // Edge's autoscroll seems too conditional,
        // MACOS Safari does not have autoscroll,
        // Firefox and Chrome are good

        if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
          autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

          var ogElemScroller = getParentAutoScrollElement(elem, true);

          if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
            pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

            pointerElemChangedInterval = setInterval(function () {
              var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

              if (newElem !== ogElemScroller) {
                ogElemScroller = newElem;
                clearAutoScrolls();
              }

              autoScroll(evt, _this.options, newElem, fallback);
            }, 10);
            lastAutoScrollX = x;
            lastAutoScrollY = y;
          }
        } else {
          // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
          if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
            clearAutoScrolls();
            return;
          }

          autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
        }
      }
    };
    return _extends(AutoScroll, {
      pluginName: 'scroll',
      initializeByDefault: true
    });
  }

  function clearAutoScrolls() {
    autoScrolls.forEach(function (autoScroll) {
      clearInterval(autoScroll.pid);
    });
    autoScrolls = [];
  }

  function clearPointerElemChangedInterval() {
    clearInterval(pointerElemChangedInterval);
  }

  var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
    // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
    if (!options.scroll) return;
    var x = (evt.touches ? evt.touches[0] : evt).clientX,
        y = (evt.touches ? evt.touches[0] : evt).clientY,
        sens = options.scrollSensitivity,
        speed = options.scrollSpeed,
        winScroller = getWindowScrollingElement();
    var scrollThisInstance = false,
        scrollCustomFn; // New scroll root, set scrollEl

    if (scrollRootEl !== rootEl) {
      scrollRootEl = rootEl;
      clearAutoScrolls();
      scrollEl = options.scroll;
      scrollCustomFn = options.scrollFn;

      if (scrollEl === true) {
        scrollEl = getParentAutoScrollElement(rootEl, true);
      }
    }

    var layersOut = 0;
    var currentParent = scrollEl;

    do {
      var el = currentParent,
          rect = getRect(el),
          top = rect.top,
          bottom = rect.bottom,
          left = rect.left,
          right = rect.right,
          width = rect.width,
          height = rect.height,
          canScrollX = void 0,
          canScrollY = void 0,
          scrollWidth = el.scrollWidth,
          scrollHeight = el.scrollHeight,
          elCSS = css(el),
          scrollPosX = el.scrollLeft,
          scrollPosY = el.scrollTop;

      if (el === winScroller) {
        canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
        canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
      } else {
        canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
        canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
      }

      var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
      var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

      if (!autoScrolls[layersOut]) {
        for (var i = 0; i <= layersOut; i++) {
          if (!autoScrolls[i]) {
            autoScrolls[i] = {};
          }
        }
      }

      if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
        autoScrolls[layersOut].el = el;
        autoScrolls[layersOut].vx = vx;
        autoScrolls[layersOut].vy = vy;
        clearInterval(autoScrolls[layersOut].pid);

        if (vx != 0 || vy != 0) {
          scrollThisInstance = true;
          /* jshint loopfunc:true */

          autoScrolls[layersOut].pid = setInterval(function () {
            // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
            if (isFallback && this.layer === 0) {
              Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

            }

            var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
            var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

            if (typeof scrollCustomFn === 'function') {
              if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
                return;
              }
            }

            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
          }.bind({
            layer: layersOut
          }), 24);
        }
      }

      layersOut++;
    } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

    scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
  }, 30);

  var drop = function drop(_ref) {
    var originalEvent = _ref.originalEvent,
        putSortable = _ref.putSortable,
        dragEl = _ref.dragEl,
        activeSortable = _ref.activeSortable,
        dispatchSortableEvent = _ref.dispatchSortableEvent,
        hideGhostForTarget = _ref.hideGhostForTarget,
        unhideGhostForTarget = _ref.unhideGhostForTarget;
    if (!originalEvent) return;
    var toSortable = putSortable || activeSortable;
    hideGhostForTarget();
    var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
    var target = document.elementFromPoint(touch.clientX, touch.clientY);
    unhideGhostForTarget();

    if (toSortable && !toSortable.el.contains(target)) {
      dispatchSortableEvent('spill');
      this.onSpill({
        dragEl: dragEl,
        putSortable: putSortable
      });
    }
  };

  function Revert() {}

  Revert.prototype = {
    startIndex: null,
    dragStart: function dragStart(_ref2) {
      var oldDraggableIndex = _ref2.oldDraggableIndex;
      this.startIndex = oldDraggableIndex;
    },
    onSpill: function onSpill(_ref3) {
      var dragEl = _ref3.dragEl,
          putSortable = _ref3.putSortable;
      this.sortable.captureAnimationState();

      if (putSortable) {
        putSortable.captureAnimationState();
      }

      var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

      if (nextSibling) {
        this.sortable.el.insertBefore(dragEl, nextSibling);
      } else {
        this.sortable.el.appendChild(dragEl);
      }

      this.sortable.animateAll();

      if (putSortable) {
        putSortable.animateAll();
      }
    },
    drop: drop
  };

  _extends(Revert, {
    pluginName: 'revertOnSpill'
  });

  function Remove() {}

  Remove.prototype = {
    onSpill: function onSpill(_ref4) {
      var dragEl = _ref4.dragEl,
          putSortable = _ref4.putSortable;
      var parentSortable = putSortable || this.sortable;
      parentSortable.captureAnimationState();
      dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
      parentSortable.animateAll();
    },
    drop: drop
  };

  _extends(Remove, {
    pluginName: 'removeOnSpill'
  });

  Sortable.mount(new AutoScrollPlugin());
  Sortable.mount(Remove, Revert);

  const _hoisted_1$a = { class: "plus-table-column-drag-icon" };
  var _sfc_main$g = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusTableColumnDragSort"
    },
    __name: "table-column-drag-sort",
    props: {
      sortable: { type: Boolean, default: true },
      tableInstance: { default: null },
      dragSortableTableColumnProps: { default: () => ({}) }
    },
    emits: ["dragSortEnd"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const { t } = useLocale();
      vue.watch(
        () => props.tableInstance,
        (val) => {
          if (val && props.sortable) {
            rowDrop();
          }
        }
      );
      const rowDrop = () => {
        var _a, _b;
        const tbody = (_b = (_a = props.tableInstance) == null ? void 0 : _a.$el) == null ? void 0 : _b.querySelector(".el-table__body-wrapper tbody");
        if (!tbody) return;
        let config = {
          handle: ".plus-table-column-drag-icon",
          animation: 150,
          group: "box",
          easing: "cubic-bezier(1, 0, 0, 1)",
          chosenClass: "sortable-chosen",
          forceFallback: true,
          onEnd({ newIndex, oldIndex }) {
            emit("dragSortEnd", newIndex, oldIndex);
          }
        };
        if (isPlainObject(props.sortable)) {
          config = { ...config, ...props.sortable };
        }
        Sortable.create(tbody, config);
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElTableColumn), vue.mergeProps({
          key: "dragSort",
          label: vue.unref(t)("plus.table.sort"),
          width: "60",
          "class-name": "plus-table-column-drag-sort"
        }, _ctx.dragSortableTableColumnProps), {
          default: vue.withCtx(() => [
            vue.createElementVNode("span", _hoisted_1$a, [
              vue.renderSlot(_ctx.$slots, "drag-sort-icon", {}, () => [
                vue.createTextVNode("\u2637")
              ])
            ])
          ]),
          _: 3
          /* FORWARDED */
        }, 16, ["label"]);
      };
    }
  });

  var PlusTableColumnDragSort = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__file", "table-column-drag-sort.vue"]]);

  const _hoisted_1$9 = {
    key: 0,
    style: { "padding-top": "12px" }
  };
  var _sfc_main$f = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusPopover"
    },
    __name: "index",
    props: {
      hasShowBottomButton: { type: Boolean, default: false },
      confirmLoading: { type: Boolean, default: false },
      cancelText: { default: "" },
      confirmText: { default: "" }
    },
    emits: ["cancel", "confirm"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const subVisible = vue.ref(false);
      const { t } = useLocale();
      vue.watch(
        () => props.visible,
        (val) => {
          subVisible.value = val;
        },
        {
          immediate: true
        }
      );
      const handleCancelPopover = () => {
        subVisible.value = false;
        emit("cancel");
      };
      const handleConfirmPopover = () => {
        subVisible.value = false;
        emit("confirm");
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElPopover), vue.mergeProps({
          visible: subVisible.value,
          "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => subVisible.value = $event)
        }, _ctx.$attrs), {
          reference: vue.withCtx(() => [
            vue.createElementVNode("span", null, [
              vue.renderSlot(_ctx.$slots, "reference")
            ])
          ]),
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "default"),
            _ctx.hasShowBottomButton ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$9, [
              vue.createVNode(vue.unref(elementPlus.ElButton), {
                size: "small",
                plain: "",
                onClick: handleCancelPopover
              }, {
                default: vue.withCtx(() => [
                  vue.createTextVNode(
                    vue.toDisplayString(_ctx.cancelText || vue.unref(t)("plus.popover.cancelText")),
                    1
                    /* TEXT */
                  )
                ]),
                _: 1
                /* STABLE */
              }),
              vue.createVNode(vue.unref(elementPlus.ElButton), {
                size: "small",
                type: "primary",
                loading: _ctx.confirmLoading,
                onClick: handleConfirmPopover
              }, {
                default: vue.withCtx(() => [
                  vue.createTextVNode(
                    vue.toDisplayString(_ctx.confirmText || vue.unref(t)("plus.popover.confirmText")),
                    1
                    /* TEXT */
                  )
                ]),
                _: 1
                /* STABLE */
              }, 8, ["loading"])
            ])) : vue.createCommentVNode("v-if", true)
          ]),
          _: 3
          /* FORWARDED */
        }, 16, ["visible"]);
      };
    }
  });

  var Popover = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__file", "index.vue"]]);

  const PlusPopover = Popover;

  const _hoisted_1$8 = { class: "plus-table-title-bar" };
  const _hoisted_2$4 = { class: "plus-table-title-bar__title" };
  const _hoisted_3$2 = { class: "plus-table-title-bar__toolbar" };
  const _hoisted_4$2 = { class: "plus-table-title-bar__toolbar__density" };
  const _hoisted_5$2 = /* @__PURE__ */ vue.createElementVNode(
    "svg",
    {
      viewBox: "0 0 1024 1024",
      focusable: "false",
      "data-icon": "column-height",
      fill: "currentColor",
      "aria-hidden": "true"
    },
    [
      /* @__PURE__ */ vue.createElementVNode("path", { d: "M840 836H184c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h656c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm0-724H184c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h656c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zM610.8 378c6 0 9.4-7 5.7-11.7L515.7 238.7a7.14 7.14 0 00-11.3 0L403.6 366.3a7.23 7.23 0 005.7 11.7H476v268h-62.8c-6 0-9.4 7-5.7 11.7l100.8 127.5c2.9 3.7 8.5 3.7 11.3 0l100.8-127.5c3.7-4.7.4-11.7-5.7-11.7H548V378h62.8z" })
    ],
    -1
    /* HOISTED */
  );
  const _hoisted_6$1 = { class: "plus-table-checkbox-checkAll" };
  const _hoisted_7$1 = {
    key: 0,
    class: "plus-table-checkbox-handle"
  };
  const _hoisted_8$1 = { key: 1 };
  const _hoisted_9$1 = { key: 1 };
  var _sfc_main$e = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusTableToolbar"
    },
    __name: "table-title-bar",
    props: {
      columns: { default: () => [] },
      titleBar: { type: [Boolean, Object], default: true },
      filterTableHeaderOverflowLabelLength: { default: 6 },
      defaultSize: { default: "default" },
      columnsIsChange: { type: Boolean, default: false }
    },
    emits: ["filterTable", "clickDensity", "refresh"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const originColumns = cloneDeep(props.columns);
      const { t } = useLocale();
      const checkboxGroupInstance = vue.ref(null);
      const titleBarConfig = vue.computed(() => props.titleBar);
      const iconSize = vue.computed(() => {
        var _a, _b;
        return ((_b = (_a = titleBarConfig.value) == null ? void 0 : _a.icon) == null ? void 0 : _b.size) || 18;
      });
      const iconColor = vue.computed(() => {
        var _a, _b;
        return ((_b = (_a = titleBarConfig.value) == null ? void 0 : _a.icon) == null ? void 0 : _b.color) || "";
      });
      const columnSetting = vue.computed(() => {
        var _a;
        return (_a = titleBarConfig.value) == null ? void 0 : _a.columnSetting;
      });
      const sortable = vue.ref(null);
      const buttonNameDensity = [
        {
          size: "default",
          text: vue.computed(() => t("plus.table.default"))
        },
        {
          size: "large",
          text: vue.computed(() => t("plus.table.loose"))
        },
        {
          size: "small",
          text: vue.computed(() => t("plus.table.compact"))
        }
      ];
      const getCheckList = (hasDisabled = false) => {
        if (hasDisabled) {
          return props.columns.filter((item) => item.disabledHeaderFilter === true).map((item) => getTableKey(item));
        }
        return props.columns.map((item) => getTableKey(item));
      };
      const state = vue.reactive({
        checkAll: true,
        isIndeterminate: false,
        bigImageVisible: false,
        srcList: [],
        checkList: []
      });
      const setCheckAllState = (value) => {
        const checkedCount = value.length;
        state.checkAll = checkedCount === props.columns.length;
        state.isIndeterminate = checkedCount > 0 && checkedCount < props.columns.length;
      };
      vue.watch(
        () => props.columnsIsChange,
        () => {
          state.checkList = getCheckList();
          setCheckAllState(state.checkList);
        },
        {
          immediate: true
        }
      );
      const handleCheckAllChange = (val) => {
        state.checkList = val ? getCheckList() : getCheckList(true);
        setCheckAllState(state.checkList);
        handleFilterTableConfirm();
      };
      const handleFilterTableConfirm = () => {
        const filterColumns = props.columns.map((item) => {
          if (state.checkList.includes(getTableKey(item))) {
            return { ...item, __selfHideInTable: false };
          }
          return { ...item, __selfHideInTable: true };
        });
        emit("filterTable", filterColumns);
      };
      const handleCheckGroupChange = (value) => {
        setCheckAllState(value);
        handleFilterTableConfirm();
      };
      const handleClickDensity = (size) => {
        emit("clickDensity", size);
      };
      const handleRefresh = () => {
        emit("refresh");
      };
      const getLabelValue = (label) => {
        const tempLabel = getLabel(label);
        if (tempLabel && (tempLabel == null ? void 0 : tempLabel.length) <= props.filterTableHeaderOverflowLabelLength) {
          return tempLabel;
        }
        return (tempLabel == null ? void 0 : tempLabel.slice(0, props.filterTableHeaderOverflowLabelLength)) + "...";
      };
      const handleDrop = () => {
        var _a;
        if (!checkboxGroupInstance.value) return;
        let config = {
          onEnd: handleDragEnd,
          ghostClass: "plus-table-ghost-class"
        };
        const dragSort = (_a = columnSetting.value) == null ? void 0 : _a.dragSort;
        if (isPlainObject(dragSort)) {
          config = { ...config, ...dragSort, handle: ".plus-table-checkbox-handle" };
        }
        sortable.value = new Sortable(checkboxGroupInstance.value, config);
      };
      const handleDragEnd = (event) => {
        const subDragCheckboxList = cloneDeep(props.columns);
        const draggedCheckbox = props.columns[event.oldIndex];
        subDragCheckboxList.splice(event.oldIndex, 1);
        subDragCheckboxList.splice(event.newIndex, 0, draggedCheckbox);
        const list = subDragCheckboxList.filter((item) => item);
        emit("filterTable", list);
      };
      const resetCheckBoxList = () => {
        state.checkList = originColumns.map((item) => getTableKey(item));
        setCheckAllState(state.checkList);
        const filterColumns = originColumns.map((item) => ({ ...item, __selfHideInTable: false }));
        emit("filterTable", filterColumns);
      };
      vue.onMounted(() => {
        var _a;
        const dragSort = (_a = columnSetting.value) == null ? void 0 : _a.dragSort;
        if (dragSort !== false) {
          if (checkboxGroupInstance.value) {
            handleDrop();
          }
        }
      });
      return (_ctx, _cache) => {
        var _a, _b, _c;
        return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$8, [
          vue.createElementVNode("div", _hoisted_2$4, [
            vue.renderSlot(_ctx.$slots, "title", {}, () => [
              vue.createTextVNode(
                vue.toDisplayString(titleBarConfig.value.title),
                1
                /* TEXT */
              )
            ])
          ]),
          vue.createElementVNode("div", _hoisted_3$2, [
            vue.renderSlot(_ctx.$slots, "toolbar"),
            ((_a = titleBarConfig.value) == null ? void 0 : _a.refresh) === true ? (vue.openBlock(), vue.createElementBlock("span", {
              key: 0,
              class: "plus-table-title-bar__toolbar__refresh",
              onClick: handleRefresh
            }, [
              vue.createVNode(vue.unref(elementPlus.ElTooltip), {
                effect: "dark",
                content: vue.unref(t)("plus.table.refresh"),
                placement: "top"
              }, {
                default: vue.withCtx(() => [
                  vue.renderSlot(_ctx.$slots, "refresh-icon", {}, () => [
                    vue.createVNode(vue.unref(elementPlus.ElIcon), {
                      size: iconSize.value,
                      color: iconColor.value,
                      class: "plus-table-title-bar__toolbar__icon"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(refresh_right_default))
                      ]),
                      _: 1
                      /* STABLE */
                    }, 8, ["size", "color"])
                  ])
                ]),
                _: 3
                /* FORWARDED */
              }, 8, ["content"])
            ])) : vue.createCommentVNode("v-if", true),
            vue.createCommentVNode(" \u8868\u683C\u5BC6\u5EA6 "),
            ((_b = titleBarConfig.value) == null ? void 0 : _b.density) !== false ? (vue.openBlock(), vue.createBlock(vue.unref(PlusPopover), {
              key: 1,
              placement: "bottom",
              width: 150,
              trigger: "click",
              title: vue.unref(t)("plus.table.density")
            }, {
              reference: vue.withCtx(() => [
                vue.createVNode(vue.unref(elementPlus.ElTooltip), {
                  effect: "dark",
                  content: vue.unref(t)("plus.table.density"),
                  placement: "top"
                }, {
                  default: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "density-icon", {}, () => [
                      vue.createVNode(vue.unref(elementPlus.ElIcon), {
                        size: iconSize.value,
                        color: iconColor.value,
                        class: "plus-table-title-bar__toolbar__icon"
                      }, {
                        default: vue.withCtx(() => [
                          _hoisted_5$2
                        ]),
                        _: 1
                        /* STABLE */
                      }, 8, ["size", "color"])
                    ])
                  ]),
                  _: 3
                  /* FORWARDED */
                }, 8, ["content"])
              ]),
              default: vue.withCtx(() => [
                vue.createElementVNode("div", _hoisted_4$2, [
                  (vue.openBlock(), vue.createElementBlock(
                    vue.Fragment,
                    null,
                    vue.renderList(buttonNameDensity, (item) => {
                      return vue.createVNode(vue.unref(elementPlus.ElButton), {
                        key: item.size,
                        plain: _ctx.defaultSize !== item.size,
                        type: "primary",
                        size: "small",
                        onClick: ($event) => handleClickDensity(item.size)
                      }, {
                        default: vue.withCtx(() => [
                          vue.createTextVNode(
                            vue.toDisplayString(vue.unref(item.text)),
                            1
                            /* TEXT */
                          )
                        ]),
                        _: 2
                        /* DYNAMIC */
                      }, 1032, ["plain", "onClick"]);
                    }),
                    64
                    /* STABLE_FRAGMENT */
                  ))
                ])
              ]),
              _: 3
              /* FORWARDED */
            }, 8, ["title"])) : vue.createCommentVNode("v-if", true),
            vue.createCommentVNode(" \u5217\u8BBE\u7F6E "),
            ((_c = titleBarConfig.value) == null ? void 0 : _c.columnSetting) !== false ? (vue.openBlock(), vue.createBlock(vue.unref(PlusPopover), {
              key: 2,
              placement: "bottom",
              width: 100,
              trigger: "click",
              title: vue.unref(t)("plus.table.columnSettings")
            }, {
              reference: vue.withCtx(() => [
                vue.createVNode(vue.unref(elementPlus.ElTooltip), {
                  effect: "dark",
                  content: vue.unref(t)("plus.table.columnSettings"),
                  placement: "top"
                }, {
                  default: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "column-settings-icon", {}, () => [
                      vue.createVNode(vue.unref(elementPlus.ElIcon), {
                        size: iconSize.value,
                        color: iconColor.value,
                        class: "plus-table-title-bar__toolbar__icon"
                      }, {
                        default: vue.withCtx(() => [
                          vue.createVNode(vue.unref(setting_default))
                        ]),
                        _: 1
                        /* STABLE */
                      }, 8, ["size", "color"])
                    ])
                  ]),
                  _: 3
                  /* FORWARDED */
                }, 8, ["content"])
              ]),
              default: vue.withCtx(() => {
                var _a2, _b2, _c2;
                return [
                  vue.createElementVNode("div", _hoisted_6$1, [
                    vue.createVNode(vue.unref(elementPlus.ElCheckbox), {
                      modelValue: state.checkAll,
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.checkAll = $event),
                      indeterminate: state.isIndeterminate,
                      onChange: handleCheckAllChange
                    }, {
                      default: vue.withCtx(() => [
                        vue.createTextVNode(
                          vue.toDisplayString(vue.unref(t)("plus.table.selectAll")),
                          1
                          /* TEXT */
                        )
                      ]),
                      _: 1
                      /* STABLE */
                    }, 8, ["modelValue", "indeterminate"]),
                    ((_a2 = columnSetting.value) == null ? void 0 : _a2.reset) !== false ? (vue.openBlock(), vue.createBlock(
                      vue.unref(elementPlus.ElLink),
                      vue.mergeProps({
                        key: 0,
                        type: "primary",
                        underline: false,
                        href: "javaScript:;"
                      }, vue.unref(isPlainObject)((_b2 = columnSetting.value) == null ? void 0 : _b2.reset) ? (_c2 = columnSetting.value) == null ? void 0 : _c2.reset : {}, {
                        onClick: vue.withModifiers(resetCheckBoxList, ["stop", "prevent"])
                      }),
                      {
                        default: vue.withCtx(() => [
                          vue.createTextVNode("\u91CD\u7F6E")
                        ]),
                        _: 1
                        /* STABLE */
                      },
                      16
                      /* FULL_PROPS */
                    )) : vue.createCommentVNode("v-if", true)
                  ]),
                  vue.createVNode(vue.unref(elementPlus.ElCheckboxGroup), {
                    modelValue: state.checkList,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => state.checkList = $event),
                    onChange: handleCheckGroupChange
                  }, {
                    default: vue.withCtx(() => [
                      vue.createElementVNode(
                        "div",
                        {
                          ref_key: "checkboxGroupInstance",
                          ref: checkboxGroupInstance,
                          class: "plus-table-checkbox-sortable-list"
                        },
                        [
                          (vue.openBlock(true), vue.createElementBlock(
                            vue.Fragment,
                            null,
                            vue.renderList(_ctx.columns, (item) => {
                              var _a3;
                              return vue.openBlock(), vue.createElementBlock("div", {
                                key: item.prop,
                                class: "plus-table-checkbox-item"
                              }, [
                                ((_a3 = columnSetting.value) == null ? void 0 : _a3.dragSort) !== false ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_7$1, [
                                  vue.renderSlot(_ctx.$slots, "drag-sort-icon", {}, () => [
                                    vue.createTextVNode("\u2637")
                                  ])
                                ])) : vue.createCommentVNode("v-if", true),
                                vue.createCommentVNode(" element-plus \u7248\u672C\u53F7\u5C0F\u4E8E2.6.0 "),
                                vue.unref(versionIsLessThan260) ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElCheckbox), {
                                  key: 1,
                                  label: vue.unref(getTableKey)(item),
                                  disabled: item.disabledHeaderFilter,
                                  class: "plus-table-title-bar__toolbar__checkbox__item"
                                }, {
                                  default: vue.withCtx(() => [
                                    vue.unref(getLabel)(item.label).length > _ctx.filterTableHeaderOverflowLabelLength ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElTooltip), {
                                      key: 0,
                                      content: vue.unref(getLabel)(item.label),
                                      placement: "right-start"
                                    }, {
                                      default: vue.withCtx(() => [
                                        vue.createTextVNode(
                                          vue.toDisplayString(getLabelValue(item.label)),
                                          1
                                          /* TEXT */
                                        )
                                      ]),
                                      _: 2
                                      /* DYNAMIC */
                                    }, 1032, ["content"])) : (vue.openBlock(), vue.createElementBlock(
                                      "span",
                                      _hoisted_8$1,
                                      vue.toDisplayString(item.label ? getLabelValue(item.label) : ""),
                                      1
                                      /* TEXT */
                                    ))
                                  ]),
                                  _: 2
                                  /* DYNAMIC */
                                }, 1032, ["label", "disabled"])) : (vue.openBlock(), vue.createElementBlock(
                                  vue.Fragment,
                                  { key: 2 },
                                  [
                                    vue.createCommentVNode(" element-plus \u7248\u672C\u53F7\u5927\u4E8E\u7B49\u4E8E2.6.0 "),
                                    vue.createVNode(vue.unref(elementPlus.ElCheckbox), {
                                      value: vue.unref(getTableKey)(item),
                                      disabled: item.disabledHeaderFilter,
                                      class: "plus-table-title-bar__toolbar__checkbox__item"
                                    }, {
                                      default: vue.withCtx(() => [
                                        vue.unref(getLabel)(item.label).length > _ctx.filterTableHeaderOverflowLabelLength ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElTooltip), {
                                          key: 0,
                                          content: vue.unref(getLabel)(item.label),
                                          placement: "right-start"
                                        }, {
                                          default: vue.withCtx(() => [
                                            vue.createTextVNode(
                                              vue.toDisplayString(getLabelValue(item.label)),
                                              1
                                              /* TEXT */
                                            )
                                          ]),
                                          _: 2
                                          /* DYNAMIC */
                                        }, 1032, ["content"])) : (vue.openBlock(), vue.createElementBlock(
                                          "span",
                                          _hoisted_9$1,
                                          vue.toDisplayString(item.label ? getLabelValue(item.label) : ""),
                                          1
                                          /* TEXT */
                                        ))
                                      ]),
                                      _: 2
                                      /* DYNAMIC */
                                    }, 1032, ["value", "disabled"])
                                  ],
                                  64
                                  /* STABLE_FRAGMENT */
                                ))
                              ]);
                            }),
                            128
                            /* KEYED_FRAGMENT */
                          ))
                        ],
                        512
                        /* NEED_PATCH */
                      )
                    ]),
                    _: 3
                    /* FORWARDED */
                  }, 8, ["modelValue"])
                ];
              }),
              _: 3
              /* FORWARDED */
            }, 8, ["title"])) : vue.createCommentVNode("v-if", true)
          ])
        ]);
      };
    }
  });

  var PlusTableTitleBar = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__file", "table-title-bar.vue"]]);

  const _hoisted_1$7 = { class: "plus-table-expand-col" };
  var _sfc_main$d = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusTable",
      inheritAttrs: false
    },
    __name: "index",
    props: {
      tableData: { default: () => [] },
      data: { default: () => [] },
      columns: { default: () => [] },
      defaultSize: { default: "default" },
      pagination: { type: [Boolean, Object], default: false },
      actionBar: { type: [Boolean, Object], default: false },
      hasIndexColumn: { type: Boolean, default: false },
      titleBar: { type: [Boolean, Object], default: true },
      isSelection: { type: Boolean, default: false },
      hasExpand: { type: Boolean, default: false },
      loadingStatus: { type: Boolean, default: false },
      height: {},
      headerCellStyle: { default: () => ({
        "background-color": "var(--el-fill-color-light)"
      }) },
      rowKey: { type: [String, Function], default: "id" },
      dragSortable: { type: [Boolean, Object], default: false },
      dragSortableTableColumnProps: { default: () => ({}) },
      indexTableColumnProps: { default: () => ({}) },
      selectionTableColumnProps: { default: () => ({
        width: 40
      }) },
      expandTableColumnProps: { default: () => ({}) },
      indexContentStyle: { type: [Object, Function], default: () => ({}) },
      editable: { type: [Boolean, String], default: false },
      adaptive: { type: [Boolean, Object], default: false }
    },
    emits: ["paginationChange", "clickAction", "clickActionConfirmCancel", "dragSortEnd", "formChange", "refresh", "edited", "cell-click", "cell-dblclick"],
    setup(__props, { expose: __expose, emit: __emit }) {
      var _a, _b;
      const props = __props;
      const emit = __emit;
      const subColumns = vue.ref([]);
      const columnsIsChange = vue.ref(false);
      const filterColumns = vue.ref([]);
      const tableInstance = vue.shallowRef(null);
      const tableWrapperInstance = vue.ref(null);
      const paginationInstance = vue.ref(null);
      const state = vue.reactive({
        subPageInfo: {
          ...((_a = props.pagination) == null ? void 0 : _a.modelValue) || DefaultPageInfo
        },
        size: props.defaultSize
      });
      const __tableData = vue.computed(
        () => {
          var _a2;
          return ((_a2 = props.tableData) == null ? void 0 : _a2.length) ? props.tableData : props.data;
        }
      );
      const hasAdaptive = vue.computed(() => typeof props.height === "undefined" && props.adaptive);
      const slots = vue.useSlots();
      const cellSlots = filterSlots(slots, getTableCellSlotName());
      const headerSlots = filterSlots(slots, getTableHeaderSlotName());
      const fieldSlots = filterSlots(slots, getFieldSlotName());
      const extraSlots = filterSlots(slots, getExtraSlotName());
      const formRefs = vue.shallowRef({});
      vue.provide(TableFormRefInjectionKey, formRefs);
      const formFieldRefs = vue.shallowRef({});
      vue.provide(TableFormFieldRefInjectionKey, formFieldRefs);
      vue.watch(
        () => props.columns,
        (val) => {
          subColumns.value = val.filter((item) => vue.unref(item.hideInTable) !== true);
          filterColumns.value = cloneDeep(subColumns.value);
          columnsIsChange.value = !columnsIsChange.value;
        },
        {
          deep: true,
          immediate: true
        }
      );
      const handlePaginationChange = () => {
        emit("paginationChange", { ...state.subPageInfo });
      };
      const handleAction = (callbackParams) => {
        emit("clickAction", callbackParams);
      };
      const handleClickActionConfirmCancel = (callbackParams) => {
        emit("clickActionConfirmCancel", callbackParams);
      };
      const handleFilterTableConfirm = (_columns) => {
        filterColumns.value = _columns;
        subColumns.value = _columns.filter(
          (item) => vue.unref(item.hideInTable) !== true && item.__selfHideInTable !== true
        );
      };
      const handleClickDensity = (size2) => {
        state.size = size2;
      };
      const handleDragSortEnd = (newIndex, oldIndex) => {
        emit("dragSortEnd", newIndex, oldIndex);
      };
      const handleRefresh = () => {
        emit("refresh");
      };
      const handleFormChange = (data) => {
        emit("formChange", data);
      };
      const currentForm = vue.ref();
      const handleCellEdit = (row, column, type) => {
        var _a2;
        const rowIndex = __tableData.value.indexOf(row);
        const columnIndex = column.getColumnIndex();
        const columnConfig = subColumns.value[columnIndex];
        if (!columnConfig) return;
        if (props.editable === type) {
          const currentCellForm = formRefs.value[rowIndex][columnIndex];
          if (!currentCellForm) return;
          document.addEventListener("click", handleStopEditClick);
          if (currentForm.value) {
            (_a2 = currentForm.value) == null ? void 0 : _a2.stopCellEdit();
          }
          currentForm.value = currentCellForm;
          currentCellForm.startCellEdit();
          const unwatch = vue.watch(
            () => formFieldRefs.value.valueIsReady,
            (val) => {
              var _a3, _b2;
              if ((val == null ? void 0 : val.value) && ((_b2 = (_a3 = formFieldRefs.value) == null ? void 0 : _a3.fieldInstance) == null ? void 0 : _b2.focus) && (props.editable === "click" || props.editable === "dblclick")) {
                formFieldRefs.value.fieldInstance.focus();
                unwatch();
              }
            }
          );
        }
      };
      const handleClickCell = (row, column, cell, event) => {
        handleCellEdit(row, column, "click");
        emit("cell-click", row, column, cell, event);
      };
      const handleDoubleClickCell = (row, column, cell, event) => {
        handleCellEdit(row, column, "dblclick");
        emit("cell-dblclick", row, column, cell, event);
      };
      const handleStopEditClick = (e) => {
        var _a2, _b2;
        if (tableWrapperInstance.value && currentForm.value) {
          const target = e == null ? void 0 : e.target;
          if (target.classList.contains("el-icon")) {
            return;
          }
          const contains = (_a2 = tableWrapperInstance.value) == null ? void 0 : _a2.contains(target);
          if (!contains && !isSVGElement(target)) {
            (_b2 = currentForm.value) == null ? void 0 : _b2.stopCellEdit();
            emit("edited");
            document.removeEventListener("click", handleStopEditClick);
          }
        }
      };
      const setAdaptive = async () => {
        var _a2;
        await vue.nextTick();
        if (!tableInstance.value) return;
        const tableWrapper = tableInstance.value.$el;
        let offsetBottom = 20;
        let paginationHeight = 0;
        if (isPlainObject(props.adaptive)) {
          offsetBottom = (_a2 = props.adaptive.offsetBottom) != null ? _a2 : offsetBottom;
        }
        if (paginationInstance.value && props.pagination) {
          paginationHeight = paginationInstance.value.$el.offsetHeight;
        }
        tableWrapper.style.height = `${window.innerHeight - tableWrapper.getBoundingClientRect().top - offsetBottom - paginationHeight}px`;
      };
      const debounceSetAdaptive = debounce(
        setAdaptive,
        isPlainObject(props.adaptive) ? (_b = props.adaptive.timeout) != null ? _b : 60 : 60
      );
      vue.onMounted(() => {
        if (hasAdaptive.value) {
          setAdaptive();
          window.addEventListener("resize", debounceSetAdaptive);
        }
      });
      vue.onBeforeUnmount(() => {
        if (hasAdaptive.value) {
          window.removeEventListener("resize", debounceSetAdaptive);
        }
      });
      const { subPageInfo, size } = vue.toRefs(state);
      __expose({
        formRefs,
        tableInstance
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            ref_key: "tableWrapperInstance",
            ref: tableWrapperInstance,
            class: "plus-table"
          },
          [
            _ctx.titleBar ? (vue.openBlock(), vue.createBlock(PlusTableTitleBar, {
              key: 0,
              columns: filterColumns.value,
              "default-size": vue.unref(size),
              "columns-is-change": columnsIsChange.value,
              "title-bar": _ctx.titleBar,
              onClickDensity: handleClickDensity,
              onFilterTable: handleFilterTableConfirm,
              onRefresh: handleRefresh
            }, vue.createSlots({
              title: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "title")
              ]),
              toolbar: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "toolbar")
              ]),
              _: 2
              /* DYNAMIC */
            }, [
              _ctx.$slots["drag-sort-icon"] ? {
                name: "drag-sort-icon",
                fn: vue.withCtx(() => [
                  vue.renderSlot(_ctx.$slots, "drag-sort-icon")
                ]),
                key: "0"
              } : void 0,
              _ctx.$slots["column-settings-icon"] ? {
                name: "column-settings-icon",
                fn: vue.withCtx(() => [
                  vue.renderSlot(_ctx.$slots, "column-settings-icon")
                ]),
                key: "1"
              } : void 0,
              _ctx.$slots["density-icon"] ? {
                name: "density-icon",
                fn: vue.withCtx(() => [
                  vue.renderSlot(_ctx.$slots, "density-icon")
                ]),
                key: "2"
              } : void 0
            ]), 1032, ["columns", "default-size", "columns-is-change", "title-bar"])) : vue.createCommentVNode("v-if", true),
            vue.withDirectives((vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElTable), vue.mergeProps({
              ref_key: "tableInstance",
              ref: tableInstance,
              "reserve-selection": true,
              data: __tableData.value,
              border: true,
              height: _ctx.height,
              "header-cell-style": _ctx.headerCellStyle,
              size: vue.unref(size),
              "row-key": _ctx.rowKey,
              "highlight-current-row": "",
              "scrollbar-always-on": ""
            }, _ctx.$attrs, {
              onCellClick: handleClickCell,
              onCellDblclick: handleDoubleClickCell
            }), {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "default", {}, () => {
                  var _a2;
                  return [
                    vue.createCommentVNode(" \u9009\u62E9\u680F "),
                    _ctx.isSelection ? (vue.openBlock(), vue.createBlock(
                      vue.unref(elementPlus.ElTableColumn),
                      vue.mergeProps({
                        key: "selection",
                        type: "selection"
                      }, _ctx.selectionTableColumnProps),
                      null,
                      16
                      /* FULL_PROPS */
                    )) : vue.createCommentVNode("v-if", true),
                    vue.createCommentVNode(" \u5E8F\u53F7\u680F "),
                    _ctx.hasIndexColumn ? (vue.openBlock(), vue.createBlock(PlusTableTableColumnIndex, {
                      key: 1,
                      "index-content-style": _ctx.indexContentStyle,
                      "index-table-column-props": _ctx.indexTableColumnProps,
                      "page-info": (_a2 = _ctx.pagination) == null ? void 0 : _a2.modelValue
                    }, null, 8, ["index-content-style", "index-table-column-props", "page-info"])) : vue.createCommentVNode("v-if", true),
                    vue.createCommentVNode(" \u62D6\u62FD\u884C "),
                    _ctx.dragSortable ? (vue.openBlock(), vue.createBlock(PlusTableColumnDragSort, {
                      key: 2,
                      sortable: _ctx.dragSortable,
                      "drag-sortable-table-column-props": _ctx.dragSortableTableColumnProps,
                      "table-instance": tableInstance.value,
                      onDragSortEnd: handleDragSortEnd
                    }, vue.createSlots({
                      _: 2
                      /* DYNAMIC */
                    }, [
                      _ctx.$slots["drag-sort-icon"] ? {
                        name: "drag-sort-icon",
                        fn: vue.withCtx(() => [
                          vue.renderSlot(_ctx.$slots, "drag-sort-icon")
                        ]),
                        key: "0"
                      } : void 0
                    ]), 1032, ["sortable", "drag-sortable-table-column-props", "table-instance"])) : vue.createCommentVNode("v-if", true),
                    vue.createCommentVNode(" \u5C55\u5F00\u884C "),
                    _ctx.hasExpand ? (vue.openBlock(), vue.createBlock(
                      vue.unref(elementPlus.ElTableColumn),
                      vue.mergeProps({
                        key: 3,
                        type: "expand"
                      }, _ctx.expandTableColumnProps),
                      {
                        default: vue.withCtx((scoped) => [
                          vue.createElementVNode("div", _hoisted_1$7, [
                            vue.renderSlot(_ctx.$slots, "expand", vue.mergeProps({
                              index: scoped.$index
                            }, scoped))
                          ])
                        ]),
                        _: 3
                        /* FORWARDED */
                      },
                      16
                      /* FULL_PROPS */
                    )) : vue.createCommentVNode("v-if", true),
                    vue.createCommentVNode("\u914D\u7F6E\u6E32\u67D3\u680F  "),
                    vue.createVNode(PlusTableColumn, {
                      columns: subColumns.value,
                      editable: _ctx.editable,
                      onFormChange: handleFormChange
                    }, vue.createSlots({
                      _: 2
                      /* DYNAMIC */
                    }, [
                      vue.renderList(vue.unref(headerSlots), (_, key) => {
                        return {
                          name: key,
                          fn: vue.withCtx((data) => [
                            vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                          ])
                        };
                      }),
                      vue.renderList(vue.unref(cellSlots), (_, key) => {
                        return {
                          name: key,
                          fn: vue.withCtx((data) => [
                            vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                          ])
                        };
                      }),
                      vue.renderList(vue.unref(fieldSlots), (_, key) => {
                        return {
                          name: key,
                          fn: vue.withCtx((data) => [
                            vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                          ])
                        };
                      }),
                      vue.renderList(vue.unref(extraSlots), (_, key) => {
                        return {
                          name: key,
                          fn: vue.withCtx((data) => [
                            vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                          ])
                        };
                      }),
                      _ctx.$slots["tooltip-icon"] ? {
                        name: "tooltip-icon",
                        fn: vue.withCtx(() => [
                          vue.renderSlot(_ctx.$slots, "tooltip-icon")
                        ]),
                        key: "0"
                      } : void 0,
                      _ctx.$slots["edit-icon"] ? {
                        name: "edit-icon",
                        fn: vue.withCtx(() => [
                          vue.renderSlot(_ctx.$slots, "edit-icon")
                        ]),
                        key: "1"
                      } : void 0
                    ]), 1032, ["columns", "editable"]),
                    vue.createCommentVNode(" \u64CD\u4F5C\u680F "),
                    _ctx.actionBar ? (vue.openBlock(), vue.createBlock(
                      PlusTableActionBar,
                      vue.mergeProps({ key: 4 }, _ctx.actionBar, {
                        onClickAction: handleAction,
                        onClickActionConfirmCancel: handleClickActionConfirmCancel
                      }),
                      vue.createSlots({
                        _: 2
                        /* DYNAMIC */
                      }, [
                        _ctx.$slots["action-bar-more-icon"] ? {
                          name: "action-bar-more-icon",
                          fn: vue.withCtx(() => [
                            vue.renderSlot(_ctx.$slots, "action-bar-more-icon")
                          ]),
                          key: "0"
                        } : void 0
                      ]),
                      1040
                      /* FULL_PROPS, DYNAMIC_SLOTS */
                    )) : vue.createCommentVNode("v-if", true)
                  ];
                })
              ]),
              append: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "append")
              ]),
              empty: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "empty")
              ]),
              _: 3
              /* FORWARDED */
            }, 16, ["data", "height", "header-cell-style", "size", "row-key"])), [
              [vue.unref(elementPlus.vLoading), _ctx.loadingStatus]
            ]),
            vue.createCommentVNode(" \u5206\u9875 "),
            _ctx.pagination ? (vue.openBlock(), vue.createBlock(vue.unref(PlusPagination), vue.mergeProps({
              key: 1,
              ref_key: "paginationInstance",
              ref: paginationInstance,
              modelValue: vue.unref(subPageInfo),
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vue.isRef(subPageInfo) ? subPageInfo.value = $event : null)
            }, _ctx.pagination, { onChange: handlePaginationChange }), vue.createSlots({
              _: 2
              /* DYNAMIC */
            }, [
              _ctx.$slots["pagination-left"] ? {
                name: "pagination-left",
                fn: vue.withCtx(() => [
                  vue.renderSlot(_ctx.$slots, "pagination-left")
                ]),
                key: "0"
              } : void 0,
              _ctx.$slots["pagination-right"] ? {
                name: "pagination-right",
                fn: vue.withCtx(() => [
                  vue.renderSlot(_ctx.$slots, "pagination-right")
                ]),
                key: "1"
              } : void 0
            ]), 1040, ["modelValue"])) : vue.createCommentVNode("v-if", true)
          ],
          512
          /* NEED_PATCH */
        );
      };
    }
  });

  var _Table = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__file", "index.vue"]]);

  const PlusTable = _Table;

  var _sfc_main$c = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusDescriptions"
    },
    __name: "index",
    props: {
      data: { default: () => ({}) },
      columns: { default: () => [] },
      column: { default: 3 },
      title: { default: "" },
      border: { type: Boolean, default: true },
      editable: { type: Boolean, default: false },
      formProps: { default: void 0 },
      descriptionsItemProps: { default: void 0 }
    },
    emits: ["formChange"],
    setup(__props, { expose: __expose, emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const plusDisplayItemInstance = vue.ref();
      const elBorder = vue.computed(() => props.editable ? true : props.border);
      const formRefs = vue.shallowRef([]);
      const subColumns = vue.computed(
        () => props.columns.filter((item) => vue.unref(item.hideInDescriptions) !== true)
      );
      const getDisplayValue = (prop) => getValue(props.data, prop);
      const setFormRef = () => {
        var _a, _b;
        if (!((_a = plusDisplayItemInstance.value) == null ? void 0 : _a.length)) return;
        const list = ((_b = plusDisplayItemInstance.value) == null ? void 0 : _b.map((item) => ({
          ...item,
          ...item == null ? void 0 : item.getDisplayItemInstance()
        }))) || [];
        formRefs.value = list;
      };
      vue.watch(
        plusDisplayItemInstance,
        () => {
          setFormRef();
        },
        {
          deep: true,
          flush: "post"
        }
      );
      const getIsRequired = (item, index) => {
        var _a;
        const itemFormProps = isFunction(item.formProps) ? item.formProps(props.data[item.prop], { row: props.data, index }) : vue.unref(item.formProps);
        const rules = Reflect.get((itemFormProps == null ? void 0 : itemFormProps.rules) || ((_a = props.formProps) == null ? void 0 : _a.rules) || {}, item.prop) || {};
        const isRequired = Object.values(rules).some((i) => i.required);
        return isRequired;
      };
      const handleChange = (data, index, item) => {
        const formChangeCallBackParams = { ...data, index, column: { ...item } };
        emit("formChange", formChangeCallBackParams);
      };
      const validate = async () => {
        var _a;
        try {
          await Promise.all(
            (_a = formRefs.value) == null ? void 0 : _a.map((item) => {
              var _a2;
              return (_a2 = item.formInstance.value) == null ? void 0 : _a2.validate();
            })
          );
        } catch (errors) {
          return Promise.reject(errors);
        }
      };
      const clearValidate = () => {
        var _a;
        (_a = formRefs.value) == null ? void 0 : _a.forEach((item) => {
          var _a2;
          (_a2 = item.formInstance.value) == null ? void 0 : _a2.clearValidate();
        });
      };
      __expose({
        formRefs,
        validate,
        clearValidate
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElDescriptions), vue.mergeProps({
          title: _ctx.title,
          column: _ctx.column,
          class: ["plus-description", { "no-border": !_ctx.border }],
          border: elBorder.value
        }, _ctx.$attrs), {
          title: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "title")
          ]),
          extra: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "extra")
          ]),
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "default", {}, () => [
              (vue.openBlock(true), vue.createElementBlock(
                vue.Fragment,
                null,
                vue.renderList(subColumns.value, (item, index) => {
                  var _a, _b;
                  return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElDescriptionsItem), vue.mergeProps({
                    key: item.prop,
                    label: vue.unref(getLabel)(item.label),
                    "class-name": (((_a = item.descriptionsItemProps) == null ? void 0 : _a.className) || "") + " plus-description__name  plus-description__content",
                    "label-class-name": (((_b = item.descriptionsItemProps) == null ? void 0 : _b.labelClassName) || "") + " plus-description__label" + (getIsRequired(item, index) ? " is-required" : "")
                  }, item.descriptionsItemProps || _ctx.descriptionsItemProps), {
                    label: vue.withCtx(() => [
                      item.renderDescriptionsLabel && vue.unref(isFunction)(item.renderDescriptionsLabel) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(item.renderDescriptionsLabel), {
                        key: 0,
                        label: vue.unref(getLabel)(item.label),
                        column: item,
                        row: _ctx.data
                      }, null, 8, ["label", "column", "row"])) : _ctx.$slots[vue.unref(getDescLabelSlotName)(item.prop)] ? (vue.openBlock(), vue.createElementBlock(
                        vue.Fragment,
                        { key: 1 },
                        [
                          vue.createCommentVNode(" plus-desc-label-* "),
                          vue.renderSlot(_ctx.$slots, vue.unref(getDescLabelSlotName)(item.prop), {
                            column: item,
                            row: _ctx.data,
                            label: vue.unref(getLabel)(item.label)
                          })
                        ],
                        64
                        /* STABLE_FRAGMENT */
                      )) : (vue.openBlock(), vue.createElementBlock(
                        vue.Fragment,
                        { key: 2 },
                        [
                          vue.createCommentVNode(" normal "),
                          vue.createTextVNode(
                            vue.toDisplayString(vue.unref(getLabel)(item.label)),
                            1
                            /* TEXT */
                          )
                        ],
                        64
                        /* STABLE_FRAGMENT */
                      ))
                    ]),
                    default: vue.withCtx(() => [
                      _ctx.editable ? (vue.openBlock(), vue.createBlock(vue.unref(PlusDisplayItem), {
                        key: 0,
                        ref_for: true,
                        ref_key: "plusDisplayItemInstance",
                        ref: plusDisplayItemInstance,
                        column: item,
                        row: _ctx.data,
                        editable: "",
                        "form-props": _ctx.formProps,
                        onChange: (data) => handleChange(data, index, item)
                      }, null, 8, ["column", "row", "form-props", "onChange"])) : item.renderDescriptionsItem && vue.unref(isFunction)(item.renderDescriptionsItem) ? (vue.openBlock(), vue.createElementBlock(
                        vue.Fragment,
                        { key: 1 },
                        [
                          vue.createCommentVNode(" renderDescriptionsItem "),
                          (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(item.renderDescriptionsItem), {
                            value: getDisplayValue(item.prop),
                            column: item,
                            row: _ctx.data
                          }, null, 8, ["value", "column", "row"]))
                        ],
                        2112
                        /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                      )) : _ctx.$slots[vue.unref(getDescSlotName)(item.prop)] ? (vue.openBlock(), vue.createElementBlock(
                        vue.Fragment,
                        { key: 2 },
                        [
                          vue.createCommentVNode(" plus-desc-* "),
                          vue.renderSlot(_ctx.$slots, vue.unref(getDescSlotName)(item.prop), {
                            column: item,
                            row: _ctx.data,
                            value: getDisplayValue(item.prop)
                          })
                        ],
                        64
                        /* STABLE_FRAGMENT */
                      )) : (vue.openBlock(), vue.createElementBlock(
                        vue.Fragment,
                        { key: 3 },
                        [
                          vue.createCommentVNode(" normal "),
                          vue.createVNode(vue.unref(PlusDisplayItem), {
                            column: item,
                            row: _ctx.data
                          }, null, 8, ["column", "row"])
                        ],
                        64
                        /* STABLE_FRAGMENT */
                      ))
                    ]),
                    _: 2
                    /* DYNAMIC */
                  }, 1040, ["label", "class-name", "label-class-name"]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ])
          ]),
          _: 3
          /* FORWARDED */
        }, 16, ["title", "column", "class", "border"]);
      };
    }
  });

  var Descriptions = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__file", "index.vue"]]);

  const PlusDescriptions = Descriptions;

  var _sfc_main$b = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusSearch"
    },
    __name: "index",
    props: {
      modelValue: { default: () => ({}) },
      defaultValues: { default: () => ({}) },
      columns: { default: () => [] },
      hasFooter: { type: Boolean, default: true },
      hasReset: { type: Boolean, default: true },
      hasUnfold: { type: Boolean, default: true },
      searchText: { default: "" },
      resetText: { default: "" },
      retractText: { default: "" },
      expandText: { default: "" },
      searchLoading: { type: Boolean, default: false },
      inline: { type: Boolean, default: true },
      showNumber: { default: 2 },
      labelPosition: { default: void 0 },
      rowProps: { default: () => ({
        gutter: 20
      }) },
      colProps: { default: () => ({
        xs: 24,
        sm: 12,
        md: 8,
        lg: 8,
        xl: 6
      }) },
      needValidate: { type: Boolean, default: false }
    },
    emits: ["update:modelValue", "search", "change", "reset", "collapse"],
    setup(__props, { expose: __expose, emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const { t } = useLocale();
      const plusFormInstance = vue.ref();
      const isShowUnfold = vue.ref(false);
      const values = vue.ref({});
      const slots = vue.useSlots();
      const attrs = vue.useAttrs();
      const rules = vue.computed(
        () => props.needValidate ? attrs.rules : void 0
      );
      const labelSlots = filterSlots(slots, getLabelSlotName());
      const fieldSlots = filterSlots(slots, getFieldSlotName());
      const extraSlots = filterSlots(slots, getExtraSlotName());
      const originData = vue.computed(() => {
        const filterData = props.columns.filter((item) => vue.unref(item.hideInSearch) !== true).map((item) => ({ ...item, hideInForm: false })).map((item) => ({ ...item, order: (item == null ? void 0 : item.order) ? vue.unref(item.order) : 0 }));
        return orderBy(filterData, ["order"], ["desc"]);
      });
      const subColumns = vue.computed(() => {
        if (props.hasUnfold && !isShowUnfold.value) {
          return originData.value.slice(0, props.showNumber);
        } else {
          return originData.value;
        }
      });
      vue.watch(
        () => props.modelValue,
        (val) => {
          values.value = val;
        },
        {
          immediate: true
        }
      );
      const handleChange = async (values2, column) => {
        emit("update:modelValue", values2);
        emit("change", values2, column);
      };
      const handleSearchDefault = () => {
        emit("search", values.value);
      };
      const handleSearchValidate = async () => {
        var _a;
        const isValid = await ((_a = plusFormInstance.value) == null ? void 0 : _a.handleSubmit());
        if (isValid) {
          emit("search", values.value);
        }
      };
      const handleSearch = vue.computed(
        () => props.needValidate ? handleSearchValidate : handleSearchDefault
      );
      const handleReset = () => {
        values.value = { ...props.defaultValues };
        emit("update:modelValue", values.value);
        emit("reset", values.value);
      };
      const handleUnfold = (e) => {
        e.preventDefault();
        isShowUnfold.value = !isShowUnfold.value;
        emit("collapse", isShowUnfold.value);
      };
      __expose({
        plusFormInstance,
        handleReset,
        handleSearch: handleSearch.value,
        handleUnfold
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(PlusForm), vue.mergeProps({
          ref_key: "plusFormInstance",
          ref: plusFormInstance
        }, _ctx.$attrs, {
          modelValue: values.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => values.value = $event),
          inline: _ctx.inline,
          rules: rules.value,
          "label-position": _ctx.labelPosition,
          "row-props": _ctx.rowProps,
          "col-props": _ctx.colProps,
          columns: subColumns.value,
          class: "plus-search",
          "has-footer": false,
          onChange: handleChange
        }), vue.createSlots({
          "search-footer": vue.withCtx(() => [
            _ctx.hasFooter ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElFormItem), {
              key: 0,
              class: "plus-search__button__wrapper",
              label: _ctx.labelPosition === "top" ? "placeholder" : ""
            }, {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "footer", {
                  isShowUnfold: isShowUnfold.value,
                  handleReset,
                  handleSearch: handleSearch.value,
                  handleUnfold
                }, () => [
                  _ctx.hasReset ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElButton), {
                    key: 0,
                    icon: vue.unref(refresh_right_default),
                    onClick: handleReset
                  }, {
                    default: vue.withCtx(() => [
                      vue.createTextVNode(
                        vue.toDisplayString(_ctx.resetText || vue.unref(t)("plus.search.resetText")),
                        1
                        /* TEXT */
                      )
                    ]),
                    _: 1
                    /* STABLE */
                  }, 8, ["icon"])) : vue.createCommentVNode("v-if", true),
                  vue.createVNode(vue.unref(elementPlus.ElButton), {
                    type: "primary",
                    loading: _ctx.searchLoading,
                    icon: vue.unref(search_default),
                    onClick: handleSearch.value
                  }, {
                    default: vue.withCtx(() => [
                      vue.createTextVNode(
                        vue.toDisplayString(_ctx.searchText || vue.unref(t)("plus.search.searchText")),
                        1
                        /* TEXT */
                      )
                    ]),
                    _: 1
                    /* STABLE */
                  }, 8, ["loading", "icon", "onClick"]),
                  _ctx.hasUnfold && originData.value.length > _ctx.showNumber ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElLink), {
                    key: 1,
                    class: "plus-search__unfold",
                    type: "primary",
                    underline: false,
                    href: "javaScript:;",
                    onClick: handleUnfold
                  }, {
                    default: vue.withCtx(() => [
                      vue.createTextVNode(
                        vue.toDisplayString(isShowUnfold.value ? _ctx.retractText || vue.unref(t)("plus.search.retract") : _ctx.expandText || vue.unref(t)("plus.search.expand")) + " ",
                        1
                        /* TEXT */
                      ),
                      vue.createVNode(vue.unref(elementPlus.ElIcon), null, {
                        default: vue.withCtx(() => [
                          isShowUnfold.value ? (vue.openBlock(), vue.createBlock(vue.unref(arrow_up_default), { key: 0 })) : (vue.openBlock(), vue.createBlock(vue.unref(arrow_down_default), { key: 1 }))
                        ]),
                        _: 1
                        /* STABLE */
                      })
                    ]),
                    _: 1
                    /* STABLE */
                  })) : vue.createCommentVNode("v-if", true)
                ])
              ]),
              _: 3
              /* FORWARDED */
            }, 8, ["label"])) : vue.createCommentVNode("v-if", true)
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          vue.renderList(vue.unref(labelSlots), (_, key) => {
            return {
              name: key,
              fn: vue.withCtx((data) => [
                vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
              ])
            };
          }),
          vue.renderList(vue.unref(fieldSlots), (_, key) => {
            return {
              name: key,
              fn: vue.withCtx((data) => [
                vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
              ])
            };
          }),
          vue.renderList(vue.unref(extraSlots), (_, key) => {
            return {
              name: key,
              fn: vue.withCtx((data) => [
                vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
              ])
            };
          }),
          _ctx.$slots["tooltip-icon"] ? {
            name: "tooltip-icon",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "tooltip-icon")
            ]),
            key: "0"
          } : void 0
        ]), 1040, ["modelValue", "inline", "rules", "label-position", "row-props", "col-props", "columns"]);
      };
    }
  });

  var Search = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__file", "index.vue"]]);

  const PlusSearch = Search;

  var _sfc_main$a = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusDialogForm"
    },
    __name: "index",
    props: {
      modelValue: { default: () => ({}) },
      visible: { type: Boolean, default: false },
      dialog: { default: () => ({}) },
      form: { default: () => ({}) },
      hasErrorTip: { type: Boolean, default: true }
    },
    emits: ["update:modelValue", "update:visible", "confirm", "change", "cancel", "confirmError"],
    setup(__props, { expose: __expose, emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const { t } = useLocale();
      const formInstance = vue.ref();
      const computedFormInstance = vue.computed(() => {
        var _a;
        return (_a = formInstance.value) == null ? void 0 : _a.formInstance;
      });
      const state = vue.ref({});
      const subVisible = vue.ref(false);
      const slots = vue.useSlots();
      const labelSlots = filterSlots(slots, getLabelSlotName());
      const fieldSlots = filterSlots(slots, getFieldSlotName());
      const extraSlots = filterSlots(slots, getExtraSlotName());
      vue.watch(
        () => props.visible,
        (val) => {
          subVisible.value = val;
        },
        {
          immediate: true
        }
      );
      vue.watch(
        () => props.modelValue,
        (val) => {
          state.value = val;
        },
        {
          immediate: true
        }
      );
      const handleChange = (values, column) => {
        emit("update:modelValue", values);
        emit("change", values, column);
      };
      const handleConfirm = async () => {
        var _a, _b, _c;
        try {
          const valid = await ((_a = computedFormInstance.value) == null ? void 0 : _a.validate());
          if (valid) {
            emit("confirm", state.value);
          }
        } catch (errors) {
          if (props.hasErrorTip) {
            elementPlus.ElMessage.closeAll();
            const values = isPlainObject(errors) && Object.values(errors);
            const message = values ? (_c = (_b = values[0]) == null ? void 0 : _b[0]) == null ? void 0 : _c.message : void 0;
            elementPlus.ElMessage.warning(message || t("plus.form.errorTip"));
          }
          emit("confirmError", errors);
        }
      };
      const handleCancel = () => {
        subVisible.value = false;
        emit("update:visible", subVisible.value);
        emit("cancel");
      };
      __expose({
        handleConfirm,
        handleCancel,
        formInstance: computedFormInstance
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(PlusDialog), vue.mergeProps({
          modelValue: subVisible.value,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => subVisible.value = $event),
          width: "800px",
          top: "10vh",
          title: vue.unref(t)("plus.dialogForm.title")
        }, _ctx.dialog, {
          onCancel: handleCancel,
          onConfirm: handleConfirm
        }), vue.createSlots({
          default: vue.withCtx(() => [
            vue.createVNode(vue.unref(PlusForm), vue.mergeProps({
              ref_key: "formInstance",
              ref: formInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.value = $event),
              "has-footer": false,
              "footer-align": "right"
            }, _ctx.form, { onChange: handleChange }), vue.createSlots({
              _: 2
              /* DYNAMIC */
            }, [
              _ctx.$slots["form-footer"] ? {
                name: "footer",
                fn: vue.withCtx((data) => [
                  vue.renderSlot(_ctx.$slots, "form-footer", vue.normalizeProps(vue.guardReactiveProps(data)))
                ]),
                key: "0"
              } : void 0,
              _ctx.$slots["form-group-header"] ? {
                name: "group-header",
                fn: vue.withCtx((data) => [
                  vue.renderSlot(_ctx.$slots, "form-group-header", vue.normalizeProps(vue.guardReactiveProps(data)))
                ]),
                key: "1"
              } : void 0,
              vue.renderList(vue.unref(labelSlots), (_, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                  ])
                };
              }),
              vue.renderList(vue.unref(fieldSlots), (_, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                  ])
                };
              }),
              vue.renderList(vue.unref(extraSlots), (_, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                  ])
                };
              }),
              _ctx.$slots["tooltip-icon"] ? {
                name: "tooltip-icon",
                fn: vue.withCtx(() => [
                  vue.renderSlot(_ctx.$slots, "tooltip-icon")
                ]),
                key: "2"
              } : void 0
            ]), 1040, ["modelValue"])
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          _ctx.$slots["dialog-header"] ? {
            name: "header",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "dialog-header")
            ]),
            key: "0"
          } : void 0,
          _ctx.$slots["dialog-footer"] ? {
            name: "footer",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "dialog-footer", vue.normalizeProps(vue.guardReactiveProps({ handleConfirm, handleCancel })))
            ]),
            key: "1"
          } : void 0
        ]), 1040, ["modelValue", "title"]);
      };
    }
  });

  var DialogForm = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__file", "index.vue"]]);

  const PlusDialogForm = DialogForm;

  const _hoisted_1$6 = { class: "plus-drawer-form__footer" };
  var _sfc_main$9 = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusDrawerForm"
    },
    __name: "index",
    props: {
      modelValue: { default: () => ({}) },
      visible: { type: Boolean, default: false },
      drawer: { default: () => ({}) },
      size: { default: "540px" },
      form: { default: () => ({}) },
      hasFooter: { type: Boolean, default: true },
      cancelText: { default: "" },
      confirmText: { default: "" },
      confirmLoading: { type: Boolean, default: false },
      hasErrorTip: { type: Boolean, default: true }
    },
    emits: ["update:modelValue", "update:visible", "confirm", "change", "cancel", "confirmError"],
    setup(__props, { expose: __expose, emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const { t } = useLocale();
      const formInstance = vue.ref(null);
      const computedFormInstance = vue.computed(() => {
        var _a;
        return (_a = formInstance.value) == null ? void 0 : _a.formInstance;
      });
      const drawerInstance = vue.ref();
      const state = vue.ref({});
      const subVisible = vue.ref(false);
      const slots = vue.useSlots();
      const labelSlots = filterSlots(slots, getLabelSlotName());
      const fieldSlots = filterSlots(slots, getFieldSlotName());
      const extraSlots = filterSlots(slots, getExtraSlotName());
      vue.watch(
        () => props.visible,
        (val) => {
          subVisible.value = val;
        },
        {
          immediate: true
        }
      );
      vue.watch(
        () => props.modelValue,
        (val) => {
          state.value = val;
        },
        {
          immediate: true
        }
      );
      const handleChange = (values, column) => {
        emit("update:modelValue", values);
        emit("change", values, column);
      };
      const handleConfirm = async () => {
        var _a, _b, _c;
        try {
          const valid = await ((_a = computedFormInstance.value) == null ? void 0 : _a.validate());
          if (valid) {
            emit("confirm", state.value);
          }
        } catch (errors) {
          if (props.hasErrorTip) {
            elementPlus.ElMessage.closeAll();
            const values = isPlainObject(errors) && Object.values(errors);
            const message = values ? (_c = (_b = values[0]) == null ? void 0 : _b[0]) == null ? void 0 : _c.message : void 0;
            elementPlus.ElMessage.warning(message || t("plus.form.errorTip"));
          }
          emit("confirmError", errors);
        }
      };
      const handleCancel = () => {
        subVisible.value = false;
        emit("update:visible", subVisible.value);
        emit("cancel");
      };
      __expose({
        drawerInstance,
        formInstance: computedFormInstance
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElDrawer), vue.mergeProps({
          ref_key: "drawerInstance",
          ref: drawerInstance,
          modelValue: subVisible.value,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => subVisible.value = $event),
          class: "plus-drawer-form",
          size: _ctx.size || "540px",
          title: vue.unref(t)("plus.drawerForm.title"),
          "close-on-click-modal": false,
          "close-on-press-escape": false
        }, _ctx.$attrs, { onClose: handleCancel }), vue.createSlots({
          default: vue.withCtx(() => [
            vue.createVNode(vue.unref(PlusForm), vue.mergeProps({
              ref_key: "formInstance",
              ref: formInstance,
              modelValue: state.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.value = $event),
              "has-footer": false
            }, _ctx.form, { onChange: handleChange }), vue.createSlots({
              _: 2
              /* DYNAMIC */
            }, [
              _ctx.$slots["form-footer"] ? {
                name: "footer",
                fn: vue.withCtx(() => [
                  vue.renderSlot(_ctx.$slots, "form-footer")
                ]),
                key: "0"
              } : void 0,
              _ctx.$slots["form-group-header"] ? {
                name: "group-header",
                fn: vue.withCtx((data) => [
                  vue.renderSlot(_ctx.$slots, "form-group-header", vue.normalizeProps(vue.guardReactiveProps(data)))
                ]),
                key: "1"
              } : void 0,
              vue.renderList(vue.unref(labelSlots), (_, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                  ])
                };
              }),
              vue.renderList(vue.unref(fieldSlots), (_, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                  ])
                };
              }),
              vue.renderList(vue.unref(extraSlots), (_, key) => {
                return {
                  name: key,
                  fn: vue.withCtx((data) => [
                    vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                  ])
                };
              }),
              _ctx.$slots["tooltip-icon"] ? {
                name: "tooltip-icon",
                fn: vue.withCtx(() => [
                  vue.renderSlot(_ctx.$slots, "tooltip-icon")
                ]),
                key: "2"
              } : void 0
            ]), 1040, ["modelValue"])
          ]),
          _: 2
          /* DYNAMIC */
        }, [
          _ctx.$slots["drawer-header"] ? {
            name: "header",
            fn: vue.withCtx(() => [
              vue.renderSlot(_ctx.$slots, "drawer-header")
            ]),
            key: "0"
          } : void 0,
          _ctx.hasFooter ? {
            name: "footer",
            fn: vue.withCtx(() => [
              vue.createElementVNode("div", _hoisted_1$6, [
                vue.renderSlot(_ctx.$slots, "drawer-footer", vue.normalizeProps(vue.guardReactiveProps({ handleConfirm, handleCancel })), () => [
                  vue.createVNode(vue.unref(elementPlus.ElButton), { onClick: handleCancel }, {
                    default: vue.withCtx(() => [
                      vue.createTextVNode(
                        vue.toDisplayString(_ctx.cancelText || vue.unref(t)("plus.drawerForm.cancelText")),
                        1
                        /* TEXT */
                      )
                    ]),
                    _: 1
                    /* STABLE */
                  }),
                  vue.createVNode(vue.unref(elementPlus.ElButton), {
                    type: "primary",
                    loading: _ctx.confirmLoading,
                    onClick: handleConfirm
                  }, {
                    default: vue.withCtx(() => [
                      vue.createTextVNode(
                        vue.toDisplayString(_ctx.confirmText || vue.unref(t)("plus.drawerForm.confirmText")),
                        1
                        /* TEXT */
                      )
                    ]),
                    _: 1
                    /* STABLE */
                  }, 8, ["loading"])
                ])
              ])
            ]),
            key: "1"
          } : void 0
        ]), 1040, ["modelValue", "size", "title"]);
      };
    }
  });

  var DrawerForm = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__file", "index.vue"]]);

  const PlusDrawerForm = DrawerForm;

  const _hoisted_1$5 = { class: "plus-page" };
  var _sfc_main$8 = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusPage"
    },
    __name: "index",
    props: {
      columns: { default: () => [] },
      request: {},
      search: { type: [Boolean, Object], default: () => ({}) },
      table: { default: () => ({}) },
      params: { default: () => ({}) },
      postData: { type: Function, default: void 0 },
      beforeSearchSubmit: { type: Function, default: void 0 },
      isCard: { type: Boolean, default: true },
      searchCardProps: { default: () => ({}) },
      tableCardProps: { default: () => ({}) },
      defaultPageInfo: { default: () => ({ ...DefaultPageInfo }) },
      defaultPageSizeList: { default: () => DefaultPageSizeList },
      pagination: { type: [Boolean, Object], default: () => ({}) },
      immediate: { type: Boolean, default: true },
      dividerProps: { type: [Boolean, Object], default: false },
      pageInfoMap: { default: () => ({
        page: "page",
        pageSize: "pageSize"
      }) }
    },
    emits: ["search", "reset", "paginationChange", "requestError", "requestComplete"],
    setup(__props, { expose: __expose, emit: __emit }) {
      var _a;
      const props = __props;
      const emit = __emit;
      const slots = vue.useSlots();
      const computedDefaultPageInfo = vue.computed(() => props.defaultPageInfo);
      const computedDefaultPageSizeList = vue.computed(() => props.defaultPageSizeList);
      const { tableData, pageInfo, total, loadingStatus } = useTable(computedDefaultPageInfo);
      const plusSearchInstance = vue.ref(null);
      const plusTableInstance = vue.ref(null);
      const values = vue.ref({ ...(_a = props.search) == null ? void 0 : _a.defaultValues });
      const cellSlots = filterSlots(slots, getTableCellSlotName());
      const headerSlots = filterSlots(slots, getTableHeaderSlotName());
      const fieldSlots = filterSlots(slots, getFieldSlotName());
      const renderWrapper = () => {
        if (props.isCard) {
          return {
            search: vue.h(elementPlus.ElCard, props.searchCardProps),
            table: vue.h(elementPlus.ElCard, props.tableCardProps)
          };
        }
        return { search: vue.h("div"), table: vue.h("div") };
      };
      const getList = async () => {
        var _a2, _b;
        if (!props.request) return;
        try {
          loadingStatus.value = true;
          const payload = {
            ...values.value,
            // eslint-disabled no-useless-spread
            ...{
              [((_a2 = props.pageInfoMap) == null ? void 0 : _a2.page) || "page"]: pageInfo.value.page,
              [((_b = props.pageInfoMap) == null ? void 0 : _b.pageSize) || "pageSize"]: pageInfo.value.pageSize
            },
            ...props.params
          };
          const { data, total: dataTotal } = await props.request(payload);
          const list = props.postData && props.postData(data) || data;
          tableData.value = list || [];
          total.value = dataTotal || list.length;
          emit("requestComplete", tableData.value);
        } catch (error) {
          emit("requestError", error);
        }
        loadingStatus.value = false;
      };
      if (props.immediate) {
        getList();
      }
      const handlePaginationChange = (_pageInfo) => {
        pageInfo.value = _pageInfo;
        getList();
        emit("paginationChange", _pageInfo);
      };
      const handleSearch = (val) => {
        const data = props.beforeSearchSubmit && props.beforeSearchSubmit(val) || val;
        values.value = data;
        pageInfo.value.page = 1;
        getList();
        emit("search", values.value);
      };
      const handleReset = (val) => {
        values.value = { ...val };
        pageInfo.value.page = 1;
        getList();
        emit("reset", values.value);
      };
      const handleRefresh = () => {
        getList();
      };
      const setSearchFieldsValue = (val) => {
        if (isPlainObject(val)) {
          Object.keys(val).forEach((key) => {
            Reflect.set(values.value, key, val[key]);
          });
        }
      };
      const getSearchFieldsValue = (key) => {
        if (key !== void 0 && key !== null) {
          return Reflect.get(values.value, key);
        } else {
          return { ...values.value };
        }
      };
      const clearSearchFieldsValue = () => {
        values.value = {};
      };
      __expose({
        plusSearchInstance,
        plusTableInstance,
        getList,
        handleReset,
        /**
         * TODO: v0.2.0
         */
        handleRest: handleReset,
        setSearchFieldsValue,
        getSearchFieldsValue,
        clearSearchFieldsValue
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$5, [
          _ctx.search ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(renderWrapper().search), { key: 0 }, {
            default: vue.withCtx(() => [
              vue.createVNode(vue.unref(PlusSearch), vue.mergeProps({
                ref_key: "plusSearchInstance",
                ref: plusSearchInstance
              }, _ctx.search, {
                modelValue: values.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => values.value = $event),
                columns: _ctx.columns,
                "search-loading": vue.unref(loadingStatus),
                onSearch: handleSearch,
                onReset: handleReset
              }), vue.createSlots({
                _: 2
                /* DYNAMIC */
              }, [
                _ctx.$slots["search-footer"] ? {
                  name: "footer",
                  fn: vue.withCtx((data) => [
                    vue.renderSlot(_ctx.$slots, "search-footer", vue.normalizeProps(vue.guardReactiveProps(data)))
                  ]),
                  key: "0"
                } : void 0
              ]), 1040, ["modelValue", "columns", "search-loading"])
            ]),
            _: 3
            /* FORWARDED */
          })) : vue.createCommentVNode("v-if", true),
          _ctx.dividerProps ? (vue.openBlock(), vue.createBlock(
            vue.unref(elementPlus.ElDivider),
            vue.normalizeProps(vue.mergeProps({ key: 1 }, _ctx.dividerProps)),
            null,
            16
            /* FULL_PROPS */
          )) : vue.createCommentVNode("v-if", true),
          vue.renderSlot(_ctx.$slots, "extra"),
          (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(renderWrapper().table), { class: "plus-page__table_wrapper" }, {
            default: vue.withCtx(() => [
              vue.createVNode(vue.unref(PlusTable), vue.mergeProps({
                ref_key: "plusTableInstance",
                ref: plusTableInstance,
                "title-bar": { refresh: true }
              }, _ctx.table, {
                "table-data": vue.unref(tableData),
                "loading-status": vue.unref(loadingStatus),
                columns: _ctx.columns,
                pagination: _ctx.pagination === false ? void 0 : {
                  ..._ctx.pagination,
                  total: vue.unref(total),
                  modelValue: vue.unref(pageInfo),
                  pageSizeList: computedDefaultPageSizeList.value
                },
                onPaginationChange: handlePaginationChange,
                onRefresh: handleRefresh
              }), vue.createSlots({
                _: 2
                /* DYNAMIC */
              }, [
                vue.renderList(vue.unref(headerSlots), (_, key) => {
                  return {
                    name: key,
                    fn: vue.withCtx((data) => [
                      vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                    ])
                  };
                }),
                vue.renderList(vue.unref(cellSlots), (_, key) => {
                  return {
                    name: key,
                    fn: vue.withCtx((data) => [
                      vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                    ])
                  };
                }),
                vue.renderList(vue.unref(fieldSlots), (_, key) => {
                  return {
                    name: key,
                    fn: vue.withCtx((data) => [
                      vue.renderSlot(_ctx.$slots, key, vue.normalizeProps(vue.guardReactiveProps(data)))
                    ])
                  };
                }),
                _ctx.$slots["table-title"] ? {
                  name: "title",
                  fn: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "table-title")
                  ]),
                  key: "0"
                } : void 0,
                _ctx.$slots["table-toolbar"] ? {
                  name: "toolbar",
                  fn: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "table-toolbar")
                  ]),
                  key: "1"
                } : void 0,
                _ctx.$slots["table-expand"] ? {
                  name: "expand",
                  fn: vue.withCtx((data) => [
                    vue.renderSlot(_ctx.$slots, "table-expand", vue.normalizeProps(vue.guardReactiveProps(data)))
                  ]),
                  key: "2"
                } : void 0,
                _ctx.$slots["table-append"] ? {
                  name: "append",
                  fn: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "table-append")
                  ]),
                  key: "3"
                } : void 0,
                _ctx.$slots["table-empty"] ? {
                  name: "empty",
                  fn: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "table-empty")
                  ]),
                  key: "4"
                } : void 0,
                _ctx.$slots["pagination-left"] ? {
                  name: "pagination-left",
                  fn: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "pagination-left")
                  ]),
                  key: "5"
                } : void 0,
                _ctx.$slots["pagination-right"] ? {
                  name: "pagination-right",
                  fn: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "pagination-right")
                  ]),
                  key: "6"
                } : void 0,
                _ctx.$slots["drag-sort-icon"] ? {
                  name: "drag-sort-icon",
                  fn: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "drag-sort-icon")
                  ]),
                  key: "7"
                } : void 0,
                _ctx.$slots["column-settings-icon"] ? {
                  name: "column-settings-icon",
                  fn: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "column-settings-icon")
                  ]),
                  key: "8"
                } : void 0,
                _ctx.$slots["density-icon"] ? {
                  name: "density-icon",
                  fn: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "density-icon")
                  ]),
                  key: "9"
                } : void 0,
                _ctx.$slots["tooltip-icon"] ? {
                  name: "tooltip-icon",
                  fn: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "tooltip-icon")
                  ]),
                  key: "10"
                } : void 0,
                _ctx.$slots["action-bar-more-icon"] ? {
                  name: "action-bar-more-icon",
                  fn: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "action-bar-more-icon")
                  ]),
                  key: "11"
                } : void 0,
                _ctx.$slots["edit-icon"] ? {
                  name: "edit-icon",
                  fn: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "edit-icon")
                  ]),
                  key: "12"
                } : void 0
              ]), 1040, ["table-data", "loading-status", "columns", "pagination"])
            ]),
            _: 3
            /* FORWARDED */
          }))
        ]);
      };
    }
  });

  var Page = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__file", "index.vue"]]);

  const PlusPage = Page;

  var _sfc_main$7 = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusStepsForm"
    },
    __name: "index",
    props: {
      modelValue: { default: 1 },
      data: { default: () => [] },
      submitText: { default: void 0 },
      nextText: { default: void 0 },
      preText: { default: void 0 }
    },
    emits: ["pre", "next", "update:modelValue", "change"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const { t } = useLocale();
      const active = vue.ref();
      vue.watchEffect(() => {
        active.value = props.modelValue;
      });
      const handleChange = (values, column) => {
        emit("change", values, column);
      };
      const pre = () => {
        if (active.value-- > props.data.length + 1) active.value = 1;
        emit("update:modelValue", active.value);
        emit("pre", active.value);
      };
      const next = (values) => {
        if (active.value++ > props.data.length - 1) active.value = props.data.length;
        emit("update:modelValue", active.value);
        emit("next", active.value, values);
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass(["plus-steps-form", _ctx.$attrs.direction === "vertical" ? "plus-steps-from-vertical" : ""])
          },
          [
            vue.createVNode(vue.unref(elementPlus.ElSteps), vue.mergeProps({
              active: active.value,
              "finish-status": "success"
            }, _ctx.$attrs), {
              default: vue.withCtx(() => [
                (vue.openBlock(true), vue.createElementBlock(
                  vue.Fragment,
                  null,
                  vue.renderList(_ctx.data, (item) => {
                    return vue.openBlock(), vue.createBlock(
                      vue.unref(elementPlus.ElStep),
                      vue.mergeProps({
                        key: item.title
                      }, item),
                      vue.createSlots({
                        _: 2
                        /* DYNAMIC */
                      }, [
                        _ctx.$slots.icon ? {
                          name: "icon",
                          fn: vue.withCtx(() => [
                            vue.renderSlot(_ctx.$slots, "icon", {
                              icon: item.icon,
                              title: item.title,
                              description: item.description
                            })
                          ]),
                          key: "0"
                        } : void 0,
                        _ctx.$slots.title ? {
                          name: "title",
                          fn: vue.withCtx(() => [
                            vue.renderSlot(_ctx.$slots, "title", {
                              icon: item.icon,
                              title: item.title,
                              description: item.description
                            })
                          ]),
                          key: "1"
                        } : void 0,
                        _ctx.$slots.description ? {
                          name: "description",
                          fn: vue.withCtx(() => [
                            vue.renderSlot(_ctx.$slots, "description", {
                              icon: item.icon,
                              title: item.title,
                              description: item.description
                            })
                          ]),
                          key: "2"
                        } : void 0
                      ]),
                      1040
                      /* FULL_PROPS, DYNAMIC_SLOTS */
                    );
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ]),
              _: 3
              /* FORWARDED */
            }, 16, ["active"]),
            vue.createVNode(vue.unref(PlusForm), vue.mergeProps(_ctx.data[active.value - 1].form, {
              "has-reset": active.value !== 1,
              "submit-text": active.value === _ctx.data.length ? _ctx.submitText || vue.unref(t)("plus.stepsForm.submitText") : _ctx.nextText || vue.unref(t)("plus.stepsForm.nextText"),
              "reset-text": _ctx.preText || vue.unref(t)("plus.stepsForm.preText"),
              onSubmit: next,
              onReset: pre,
              onChange: handleChange
            }), null, 16, ["has-reset", "submit-text", "reset-text"])
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  var StepsForm = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__file", "index.vue"]]);

  const PlusStepsForm = StepsForm;

  var _sfc_main$6 = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusBreadcrumb"
    },
    __name: "index",
    props: {
      routes: { default: () => [] },
      replace: { type: Boolean, default: false },
      renderTitle: {}
    },
    setup(__props) {
      const props = __props;
      const instance = vue.getCurrentInstance();
      const route = vue.computed(
        () => instance.appContext.config.globalProperties.$route
      );
      const breadcrumbList = vue.ref([]);
      vue.watchEffect(() => {
        var _a;
        const breadcrumb = ((_a = props.routes) == null ? void 0 : _a.length) ? props.routes : route.value ? route.value.matched : [];
        breadcrumbList.value = breadcrumb.filter((item) => {
          var _a2;
          return ((_a2 = item.meta) == null ? void 0 : _a2.hideInBreadcrumb) !== true;
        });
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElBreadcrumb), vue.mergeProps(_ctx.$attrs, {
          class: ["plus-breadcrumb", {
            "no-data": breadcrumbList.value.length === 0
          }]
        }), {
          default: vue.withCtx(() => [
            (vue.openBlock(true), vue.createElementBlock(
              vue.Fragment,
              null,
              vue.renderList(breadcrumbList.value, (item) => {
                return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElBreadcrumbItem), {
                  key: item.path,
                  class: "plus-breadcrumb-item",
                  to: item.redirect || item.path,
                  replace: _ctx.replace
                }, {
                  default: vue.withCtx(() => {
                    var _a;
                    return [
                      _ctx.renderTitle && vue.unref(isFunction)(_ctx.renderTitle) ? (vue.openBlock(), vue.createBlock(
                        vue.resolveDynamicComponent(_ctx.renderTitle),
                        vue.normalizeProps(vue.mergeProps({ key: 0 }, vue.unref(removeChildrenField)(item))),
                        null,
                        16
                        /* FULL_PROPS */
                      )) : _ctx.$slots["breadcrumb-item-title"] ? (vue.openBlock(), vue.createElementBlock(
                        vue.Fragment,
                        { key: 1 },
                        [
                          vue.createCommentVNode(" \u9762\u5305\u5C51title \u63D2\u69FD "),
                          vue.renderSlot(_ctx.$slots, "breadcrumb-item-title", vue.normalizeProps(vue.guardReactiveProps(item)))
                        ],
                        2112
                        /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                      )) : (vue.openBlock(), vue.createElementBlock(
                        vue.Fragment,
                        { key: 2 },
                        [
                          vue.createTextVNode(
                            vue.toDisplayString(((_a = item.meta) == null ? void 0 : _a.title) || item.name || item.path),
                            1
                            /* TEXT */
                          )
                        ],
                        64
                        /* STABLE_FRAGMENT */
                      ))
                    ];
                  }),
                  _: 2
                  /* DYNAMIC */
                }, 1032, ["to", "replace"]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ]),
          _: 3
          /* FORWARDED */
        }, 16, ["class"]);
      };
    }
  });

  var Breadcrumb = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__file", "index.vue"]]);

  const PlusBreadcrumb = Breadcrumb;

  const _hoisted_1$4 = { class: "plus-sidebar__item-title" };
  const _hoisted_2$3 = { class: "plus-sidebar__item-title" };
  var _sfc_main$5 = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusSidebarItem"
    },
    __name: "sidebar-item",
    props: {
      item: {},
      collapse: { type: Boolean, default: false },
      renderMenuItem: { type: Function, default: void 0 },
      renderSubMenuItem: { type: Function, default: void 0 },
      renderTitle: { type: Function, default: void 0 }
    },
    setup(__props) {
      const instance = vue.getCurrentInstance();
      const router = instance.appContext.config.globalProperties.$router;
      const resolveMenuItem = (item) => {
        var _a;
        if (!((_a = item.children) == null ? void 0 : _a.length)) return true;
        const children = item.children.filter((i) => {
          var _a2;
          return ((_a2 = i.meta) == null ? void 0 : _a2.hideInMenu) !== true;
        });
        if (!children.length) {
          return true;
        }
        return false;
      };
      const replacePath = (path) => path.replace("/http", "http");
      const getIndex = (item) => {
        return item.redirect || item.path;
      };
      const handleClickItem = (item) => {
        if (isUrl(replacePath(item.path))) {
          const url = replacePath(item.path);
          window.open(url);
        } else {
          router && router.push(getIndex(item));
        }
      };
      return (_ctx, _cache) => {
        var _a, _b;
        const _component_PlusSidebarItem = vue.resolveComponent("PlusSidebarItem");
        return ((_a = _ctx.item.meta) == null ? void 0 : _a.hideInMenu) !== true ? (vue.openBlock(), vue.createElementBlock(
          vue.Fragment,
          { key: 0 },
          [
            vue.createCommentVNode(" \u6CA1\u6709\u5B50\u83DC\u5355\u7684\u60C5\u51B5 "),
            resolveMenuItem(_ctx.item) ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElMenuItem), {
              key: getIndex(_ctx.item),
              class: "plus-sidebar__item",
              index: getIndex(_ctx.item),
              disabled: (_b = _ctx.item.meta) == null ? void 0 : _b.disabled,
              onClick: _cache[0] || (_cache[0] = ($event) => handleClickItem(_ctx.item))
            }, {
              title: vue.withCtx(() => {
                var _a2;
                return [
                  vue.createElementVNode("span", _hoisted_1$4, [
                    _ctx.renderTitle && vue.unref(isFunction)(_ctx.renderTitle) ? (vue.openBlock(), vue.createBlock(
                      vue.resolveDynamicComponent(_ctx.renderTitle),
                      vue.normalizeProps(vue.mergeProps({ key: 0 }, vue.unref(removeChildrenField)(_ctx.item))),
                      null,
                      16
                      /* FULL_PROPS */
                    )) : _ctx.$slots["sidebar-item-title"] ? (vue.openBlock(), vue.createElementBlock(
                      vue.Fragment,
                      { key: 1 },
                      [
                        vue.createCommentVNode(" menu-item title \u63D2\u69FD "),
                        vue.renderSlot(_ctx.$slots, "sidebar-item-title", vue.normalizeProps(vue.guardReactiveProps(_ctx.item)))
                      ],
                      2112
                      /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                    )) : (vue.openBlock(), vue.createElementBlock(
                      vue.Fragment,
                      { key: 2 },
                      [
                        vue.createTextVNode(
                          vue.toDisplayString(((_a2 = _ctx.item.meta) == null ? void 0 : _a2.title) || _ctx.item.name || _ctx.item.path),
                          1
                          /* TEXT */
                        )
                      ],
                      64
                      /* STABLE_FRAGMENT */
                    ))
                  ])
                ];
              }),
              default: vue.withCtx(() => [
                _ctx.renderMenuItem && vue.unref(isFunction)(_ctx.renderMenuItem) ? (vue.openBlock(), vue.createBlock(
                  vue.resolveDynamicComponent(_ctx.renderMenuItem),
                  vue.normalizeProps(vue.mergeProps({ key: 0 }, vue.unref(removeChildrenField)(_ctx.item))),
                  null,
                  16
                  /* FULL_PROPS */
                )) : _ctx.$slots["sidebar-item"] ? (vue.openBlock(), vue.createElementBlock(
                  vue.Fragment,
                  { key: 1 },
                  [
                    vue.createCommentVNode(" menu-item \u63D2\u69FD "),
                    vue.renderSlot(_ctx.$slots, "sidebar-item", vue.normalizeProps(vue.guardReactiveProps(_ctx.item)))
                  ],
                  2112
                  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                )) : _ctx.item.meta && _ctx.item.meta.icon ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElIcon), {
                  key: 2,
                  class: "plus-sidebar__item-icon"
                }, {
                  default: vue.withCtx(() => [
                    (vue.openBlock(), vue.createBlock(
                      vue.resolveDynamicComponent(_ctx.item.meta.icon),
                      vue.normalizeProps(vue.guardReactiveProps(vue.unref(removeChildrenField)(_ctx.item))),
                      null,
                      16
                      /* FULL_PROPS */
                    ))
                  ]),
                  _: 1
                  /* STABLE */
                })) : vue.createCommentVNode("v-if", true)
              ]),
              _: 3
              /* FORWARDED */
            }, 8, ["index", "disabled"])) : (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 1 },
              [
                vue.createCommentVNode(" \u6709\u5B50\u83DC\u5355\u7684\u60C5\u51B5 "),
                (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElSubMenu), {
                  key: getIndex(_ctx.item),
                  index: getIndex(_ctx.item),
                  class: "plus-sidebar__item-sub"
                }, {
                  title: vue.withCtx(() => {
                    var _a2, _b2;
                    return [
                      vue.createCommentVNode(" \u81EA\u5B9A\u4E49\u663E\u793A "),
                      _ctx.renderSubMenuItem && vue.unref(isFunction)(_ctx.renderSubMenuItem) ? (vue.openBlock(), vue.createBlock(
                        vue.resolveDynamicComponent(_ctx.renderSubMenuItem),
                        vue.normalizeProps(vue.mergeProps({ key: 0 }, vue.unref(removeChildrenField)(_ctx.item))),
                        null,
                        16
                        /* FULL_PROPS */
                      )) : _ctx.$slots["sidebar-sub"] ? (vue.openBlock(), vue.createElementBlock(
                        vue.Fragment,
                        { key: 1 },
                        [
                          vue.createCommentVNode(" sub-menu \u63D2\u69FD "),
                          vue.renderSlot(_ctx.$slots, "sidebar-sub", vue.normalizeProps(vue.guardReactiveProps(_ctx.item)))
                        ],
                        2112
                        /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                      )) : ((_a2 = _ctx.item.meta) == null ? void 0 : _a2.icon) ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElIcon), {
                        key: 2,
                        class: "plus-sidebar__item-icon"
                      }, {
                        default: vue.withCtx(() => {
                          var _a3;
                          return [
                            (vue.openBlock(), vue.createBlock(
                              vue.resolveDynamicComponent((_a3 = _ctx.item.meta) == null ? void 0 : _a3.icon),
                              vue.normalizeProps(vue.guardReactiveProps(vue.unref(removeChildrenField)(_ctx.item))),
                              null,
                              16
                              /* FULL_PROPS */
                            ))
                          ];
                        }),
                        _: 1
                        /* STABLE */
                      })) : vue.createCommentVNode("v-if", true),
                      vue.createElementVNode("span", _hoisted_2$3, [
                        _ctx.renderTitle && vue.unref(isFunction)(_ctx.renderTitle) ? (vue.openBlock(), vue.createBlock(
                          vue.resolveDynamicComponent(_ctx.renderTitle),
                          vue.normalizeProps(vue.mergeProps({ key: 0 }, vue.unref(removeChildrenField)(_ctx.item))),
                          null,
                          16
                          /* FULL_PROPS */
                        )) : _ctx.$slots["sidebar-item-title"] ? (vue.openBlock(), vue.createElementBlock(
                          vue.Fragment,
                          { key: 1 },
                          [
                            vue.createCommentVNode(" sub-menu title \u63D2\u69FD "),
                            vue.renderSlot(_ctx.$slots, "sidebar-item-title", vue.normalizeProps(vue.guardReactiveProps(_ctx.item)))
                          ],
                          2112
                          /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
                        )) : (vue.openBlock(), vue.createElementBlock(
                          vue.Fragment,
                          { key: 2 },
                          [
                            vue.createTextVNode(
                              vue.toDisplayString(((_b2 = _ctx.item.meta) == null ? void 0 : _b2.title) || _ctx.item.name || _ctx.item.path),
                              1
                              /* TEXT */
                            )
                          ],
                          64
                          /* STABLE_FRAGMENT */
                        ))
                      ])
                    ];
                  }),
                  default: vue.withCtx(() => [
                    (vue.openBlock(true), vue.createElementBlock(
                      vue.Fragment,
                      null,
                      vue.renderList(_ctx.item.children, (child) => {
                        return vue.openBlock(), vue.createBlock(_component_PlusSidebarItem, {
                          key: child.path,
                          item: child,
                          collapse: _ctx.collapse,
                          "render-menu-item": _ctx.renderMenuItem,
                          "render-sub-menu-item": _ctx.renderSubMenuItem,
                          "render-title": _ctx.renderTitle
                        }, vue.createSlots({
                          _: 2
                          /* DYNAMIC */
                        }, [
                          _ctx.$slots["sidebar-item"] ? {
                            name: "sidebar-item",
                            fn: vue.withCtx((data) => [
                              vue.renderSlot(_ctx.$slots, "sidebar-item", vue.normalizeProps(vue.guardReactiveProps(data)))
                            ]),
                            key: "0"
                          } : void 0,
                          _ctx.$slots["sidebar-sub"] ? {
                            name: "sidebar-sub",
                            fn: vue.withCtx((data) => [
                              vue.renderSlot(_ctx.$slots, "sidebar-sub", vue.normalizeProps(vue.guardReactiveProps(data)))
                            ]),
                            key: "1"
                          } : void 0,
                          _ctx.$slots["sidebar-item-title"] ? {
                            name: "sidebar-item-title",
                            fn: vue.withCtx((data) => [
                              vue.renderSlot(_ctx.$slots, "sidebar-item-title", vue.normalizeProps(vue.guardReactiveProps(data)))
                            ]),
                            key: "2"
                          } : void 0
                        ]), 1032, ["item", "collapse", "render-menu-item", "render-sub-menu-item", "render-title"]);
                      }),
                      128
                      /* KEYED_FRAGMENT */
                    ))
                  ]),
                  _: 3
                  /* FORWARDED */
                }, 8, ["index"]))
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            ))
          ],
          64
          /* STABLE_FRAGMENT */
        )) : vue.createCommentVNode("v-if", true);
      };
    }
  });

  var SidebarItem = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__file", "sidebar-item.vue"]]);

  var _sfc_main$4 = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusSidebar"
    },
    __name: "index",
    props: {
      routes: { default: () => [] },
      collapse: { type: Boolean, default: false },
      defaultActive: { default: void 0 },
      renderMenuItem: { type: Function, default: void 0 },
      renderSubMenuItem: { type: Function, default: void 0 },
      renderTitle: { type: Function, default: void 0 },
      renderMenuExtra: { type: Function, default: void 0 },
      scrollbarProps: { default: () => ({}) },
      width: { default: 200 }
    },
    emits: ["update:collapse", "toggleCollapse"],
    setup(__props, { expose: __expose, emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const instance = vue.getCurrentInstance();
      const route = vue.computed(
        () => instance.appContext.config.globalProperties.$route
      );
      const plusSidebarInstance = vue.ref(null);
      const subCollapse = vue.ref(false);
      const subRoutes = vue.computed(
        () => cloneDeep(props.routes).sort((a, b) => {
          var _a, _b;
          return (((_a = a.meta) == null ? void 0 : _a.sort) || 0) - (((_b = b.meta) == null ? void 0 : _b.sort) || 0);
        })
      );
      const computedDefaultActive = vue.computed(
        () => {
          var _a, _b, _c, _d;
          return ((_a = route.value) == null ? void 0 : _a.redirectedFrom) && ((_c = (_b = route.value) == null ? void 0 : _b.redirectedFrom) == null ? void 0 : _c.path) || ((_d = route.value) == null ? void 0 : _d.path);
        }
      );
      const subDefaultActive = vue.computed(
        () => vue.unref(props.defaultActive) || computedDefaultActive.value
      );
      const toggleCollapse = () => {
        subCollapse.value = !subCollapse.value;
        emit("update:collapse", subCollapse.value);
        emit("toggleCollapse", subCollapse.value);
      };
      vue.watchEffect(() => {
        subCollapse.value = props.collapse;
      });
      __expose({
        collapse: subCollapse,
        toggleCollapse,
        plusSidebarInstance
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElMenu), vue.mergeProps({
          ref_key: "plusSidebarInstance",
          ref: plusSidebarInstance,
          mode: "vertical",
          collapse: subCollapse.value,
          "default-active": subDefaultActive.value,
          "collapse-transition": true,
          class: ["plus-sidebar", [_ctx.$attrs.mode === "horizontal" ? "is-horizontal" : "is-vertical"]],
          ellipsis: false,
          "unique-opened": ""
        }, _ctx.$attrs), {
          default: vue.withCtx(() => [
            _ctx.renderMenuExtra && vue.unref(isFunction)(_ctx.renderMenuExtra) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.renderMenuExtra), { key: 0 })) : _ctx.$slots["sidebar-extra"] ? (vue.openBlock(), vue.createElementBlock(
              vue.Fragment,
              { key: 1 },
              [
                vue.createCommentVNode(" \u83DC\u5355\u5934\u63D2\u69FD "),
                vue.renderSlot(_ctx.$slots, "sidebar-extra")
              ],
              2112
              /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
            )) : vue.createCommentVNode("v-if", true),
            vue.createVNode(
              vue.unref(elementPlus.ElScrollbar),
              vue.mergeProps({ class: "plus-sidebar__scrollbar" }, _ctx.scrollbarProps),
              {
                default: vue.withCtx(() => [
                  vue.createCommentVNode(" \u6DFB\u52A0\u9012\u5F52\u7EC4\u4EF6\uFF0C\u7528\u6765\u751F\u6210\u591A\u7EA7\u83DC\u5355 "),
                  (vue.openBlock(true), vue.createElementBlock(
                    vue.Fragment,
                    null,
                    vue.renderList(subRoutes.value, (item) => {
                      return vue.openBlock(), vue.createBlock(SidebarItem, {
                        key: item.path,
                        item,
                        collapse: subCollapse.value,
                        "render-menu-item": _ctx.renderMenuItem,
                        "render-sub-menu-item": _ctx.renderSubMenuItem,
                        "render-title": _ctx.renderTitle
                      }, vue.createSlots({
                        _: 2
                        /* DYNAMIC */
                      }, [
                        _ctx.$slots["sidebar-item"] ? {
                          name: "sidebar-item",
                          fn: vue.withCtx((data) => [
                            vue.renderSlot(_ctx.$slots, "sidebar-item", vue.normalizeProps(vue.guardReactiveProps(data)))
                          ]),
                          key: "0"
                        } : void 0,
                        _ctx.$slots["sidebar-sub"] ? {
                          name: "sidebar-sub",
                          fn: vue.withCtx((data) => [
                            vue.renderSlot(_ctx.$slots, "sidebar-sub", vue.normalizeProps(vue.guardReactiveProps(data)))
                          ]),
                          key: "1"
                        } : void 0,
                        _ctx.$slots["sidebar-item-title"] ? {
                          name: "sidebar-item-title",
                          fn: vue.withCtx((data) => [
                            vue.renderSlot(_ctx.$slots, "sidebar-item-title", vue.normalizeProps(vue.guardReactiveProps(data)))
                          ]),
                          key: "2"
                        } : void 0
                      ]), 1032, ["item", "collapse", "render-menu-item", "render-sub-menu-item", "render-title"]);
                    }),
                    128
                    /* KEYED_FRAGMENT */
                  ))
                ]),
                _: 3
                /* FORWARDED */
              },
              16
              /* FULL_PROPS */
            ),
            _ctx.$attrs.mode !== "horizontal" ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElMenuItem), {
              key: 2,
              index: "collapse",
              class: vue.normalizeClass(["plus-sidebar__collapse", subCollapse.value ? "is-collapse" : ""]),
              onClick: toggleCollapse
            }, {
              default: vue.withCtx(() => [
                subCollapse.value ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElIcon), { key: 0 }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(expand_default))
                  ]),
                  _: 1
                  /* STABLE */
                })) : (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElIcon), { key: 1 }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(fold_default))
                  ]),
                  _: 1
                  /* STABLE */
                }))
              ]),
              _: 1
              /* STABLE */
            }, 8, ["class"])) : vue.createCommentVNode("v-if", true)
          ]),
          _: 3
          /* FORWARDED */
        }, 16, ["collapse", "default-active", "class"]);
      };
    }
  });

  var Sidebar = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__file", "index.vue"]]);

  const PlusSidebar = Sidebar;
  const PlusSidebarItem = SidebarItem;

  const _hoisted_1$3 = { class: "plus-header__left" };
  const _hoisted_2$2 = ["src"];
  const _hoisted_3$1 = {
    key: 1,
    class: "plus-header__title"
  };
  const _hoisted_4$1 = /* @__PURE__ */ vue.createElementVNode(
    "div",
    { class: "plus-header__placeholder" },
    null,
    -1
    /* HOISTED */
  );
  const _hoisted_5$1 = { class: "plus-header__right" };
  const _hoisted_6 = { class: "plus-header__dropdown-area" };
  const _hoisted_7 = ["src"];
  const _hoisted_8 = { class: "plus-header__username" };
  const _hoisted_9 = {
    key: 0,
    class: "plus-header-placeholder"
  };
  var _sfc_main$3 = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusHeader"
    },
    __name: "index",
    props: {
      logo: { default: "https://plus-pro-components.com/logo.png" },
      fixed: { type: Boolean, default: false },
      title: { default: "PlusProComponents" },
      logoutText: { default: "" },
      trigger: { default: "click" },
      userInfo: { default: () => ({}) },
      hasUserInfo: { type: Boolean, default: true },
      dropdownList: { default: () => [] },
      renderHeaderLeft: {},
      renderHeaderRight: {}
    },
    emits: ["clickDropdownItem"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const { t } = useLocale();
      const logoutItem = {
        label: props.logoutText || t("plus.header.logout"),
        value: "logout"
      };
      const handleClickItem = (item) => {
        emit("clickDropdownItem", item);
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          vue.Fragment,
          null,
          [
            vue.createVNode(vue.unref(elementPlus.ElHeader), {
              class: vue.normalizeClass(["plus-header", { "is-fixed": _ctx.fixed }])
            }, {
              default: vue.withCtx(() => [
                vue.createElementVNode("div", _hoisted_1$3, [
                  _ctx.renderHeaderLeft && vue.unref(isFunction)(_ctx.renderHeaderLeft) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.renderHeaderLeft), {
                    key: 0,
                    logo: _ctx.logo,
                    title: _ctx.title
                  }, null, 8, ["logo", "title"])) : _ctx.$slots["header-left"] ? vue.renderSlot(_ctx.$slots, "header-left", {
                    key: 1,
                    logo: _ctx.logo,
                    title: _ctx.title
                  }) : (vue.openBlock(), vue.createElementBlock(
                    vue.Fragment,
                    { key: 2 },
                    [
                      _ctx.logo ? (vue.openBlock(), vue.createElementBlock("img", {
                        key: 0,
                        src: _ctx.logo,
                        alt: "",
                        class: "plus-header__logo"
                      }, null, 8, _hoisted_2$2)) : vue.createCommentVNode("v-if", true),
                      _ctx.title ? (vue.openBlock(), vue.createElementBlock(
                        "h2",
                        _hoisted_3$1,
                        vue.toDisplayString(_ctx.title),
                        1
                        /* TEXT */
                      )) : vue.createCommentVNode("v-if", true)
                    ],
                    64
                    /* STABLE_FRAGMENT */
                  ))
                ]),
                _hoisted_4$1,
                vue.createElementVNode("div", _hoisted_5$1, [
                  _ctx.renderHeaderRight && vue.unref(isFunction)(_ctx.renderHeaderRight) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.renderHeaderRight), {
                    key: 0,
                    "user-info": _ctx.userInfo,
                    title: _ctx.title
                  }, null, 8, ["user-info", "title"])) : _ctx.$slots["header-right"] ? vue.renderSlot(_ctx.$slots, "header-right", {
                    key: 1,
                    userInfo: _ctx.userInfo,
                    title: _ctx.title
                  }) : vue.createCommentVNode("v-if", true),
                  _ctx.hasUserInfo ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElDropdown), {
                    key: 2,
                    placement: "bottom-end",
                    trigger: "click"
                  }, {
                    dropdown: vue.withCtx(() => [
                      vue.createVNode(vue.unref(elementPlus.ElDropdownMenu), { class: "header-dropdown" }, {
                        default: vue.withCtx(() => [
                          vue.createVNode(vue.unref(elementPlus.ElDropdownItem), {
                            onClick: _cache[0] || (_cache[0] = ($event) => handleClickItem(logoutItem))
                          }, {
                            default: vue.withCtx(() => [
                              vue.createTextVNode(
                                vue.toDisplayString(_ctx.logoutText || vue.unref(t)("plus.header.logout")),
                                1
                                /* TEXT */
                              )
                            ]),
                            _: 1
                            /* STABLE */
                          }),
                          (vue.openBlock(true), vue.createElementBlock(
                            vue.Fragment,
                            null,
                            vue.renderList(_ctx.dropdownList, (item) => {
                              return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElDropdownItem), {
                                key: item.value,
                                onClick: ($event) => handleClickItem(item)
                              }, {
                                default: vue.withCtx(() => [
                                  vue.createTextVNode(
                                    vue.toDisplayString(item.label),
                                    1
                                    /* TEXT */
                                  )
                                ]),
                                _: 2
                                /* DYNAMIC */
                              }, 1032, ["onClick"]);
                            }),
                            128
                            /* KEYED_FRAGMENT */
                          ))
                        ]),
                        _: 1
                        /* STABLE */
                      })
                    ]),
                    default: vue.withCtx(() => [
                      vue.createElementVNode("span", _hoisted_6, [
                        vue.createCommentVNode(" avatar "),
                        _ctx.userInfo.avatar ? (vue.openBlock(), vue.createElementBlock("img", {
                          key: 0,
                          src: _ctx.userInfo.avatar,
                          alt: "",
                          class: "plus-header__avatar"
                        }, null, 8, _hoisted_7)) : (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElIcon), {
                          key: 1,
                          size: 20,
                          class: "plus-header__avatar"
                        }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(vue.unref(user_default))
                          ]),
                          _: 1
                          /* STABLE */
                        })),
                        vue.createCommentVNode(" username "),
                        vue.createElementVNode(
                          "p",
                          _hoisted_8,
                          vue.toDisplayString(_ctx.userInfo.username || "admin"),
                          1
                          /* TEXT */
                        ),
                        vue.createVNode(vue.unref(elementPlus.ElIcon), { class: "el-icon-caret-bottom el-icon--right" }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(vue.unref(arrow_down_default))
                          ]),
                          _: 1
                          /* STABLE */
                        })
                      ])
                    ]),
                    _: 1
                    /* STABLE */
                  })) : vue.createCommentVNode("v-if", true)
                ])
              ]),
              _: 3
              /* FORWARDED */
            }, 8, ["class"]),
            _ctx.fixed ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_9)) : vue.createCommentVNode("v-if", true)
          ],
          64
          /* STABLE_FRAGMENT */
        );
      };
    }
  });

  var Header = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__file", "index.vue"]]);

  const PlusHeader = Header;

  const _hoisted_1$2 = { class: "plus-layout-main" };
  const _hoisted_2$1 = {
    key: 0,
    class: "plus-layout-extra"
  };
  var _sfc_main$2 = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusLayout"
    },
    __name: "index",
    props: {
      hasSidebar: { type: Boolean, default: true },
      hasHeader: { type: Boolean, default: true },
      hasBreadcrumb: { type: Boolean, default: true },
      sidebarProps: { default: void 0 },
      headerProps: { default: void 0 },
      breadcrumbProps: { default: void 0 },
      scrollbarProps: { default: () => ({
        always: true
      }) },
      backtop: { type: [Boolean, Object], default: true }
    },
    setup(__props, { expose: __expose }) {
      const props = __props;
      const PlusBreadcrumb$1 = PlusBreadcrumb;
      const PlusSidebar$1 = PlusSidebar;
      const PlusHeader$1 = PlusHeader;
      const height = vue.ref("100%");
      const collapse = vue.ref(false);
      const plusSidebarInstance = vue.ref();
      const plusBreadcrumbInstance = vue.ref();
      const backtopProps = vue.computed(
        () => isPlainObject(props.backtop) ? props.backtop : {}
      );
      const setHeight = () => {
        var _a;
        if (props.hasBreadcrumb && ((_a = plusBreadcrumbInstance.value) == null ? void 0 : _a.$el)) {
          requestAnimationFrame(() => {
            var _a2, _b;
            const bottom = (_b = (_a2 = plusBreadcrumbInstance.value) == null ? void 0 : _a2.$el) == null ? void 0 : _b.getBoundingClientRect().bottom;
            height.value = `calc(100% - ${bottom}px + var(--plus-header-height))`;
          });
        }
      };
      vue.onMounted(() => {
        setHeight();
      });
      __expose({
        plusSidebarInstance
      });
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElContainer), {
          class: vue.normalizeClass(["plus-layout", { collapse: collapse.value }]),
          style: vue.normalizeStyle(!_ctx.hasHeader ? "--plus-header-height: 0px" : void 0)
        }, {
          default: vue.withCtx(() => [
            vue.createCommentVNode(" \u5934\u90E8 "),
            _ctx.hasHeader ? (vue.openBlock(), vue.createBlock(
              vue.unref(PlusHeader$1),
              vue.normalizeProps(vue.mergeProps({ key: 0 }, _ctx.headerProps)),
              vue.createSlots({
                _: 2
                /* DYNAMIC */
              }, [
                _ctx.$slots["header-left"] ? {
                  name: "header-left",
                  fn: vue.withCtx((data) => [
                    vue.renderSlot(_ctx.$slots, "header-left", vue.normalizeProps(vue.guardReactiveProps(data)))
                  ]),
                  key: "0"
                } : void 0,
                _ctx.$slots["header-right"] ? {
                  name: "header-right",
                  fn: vue.withCtx((data) => [
                    vue.renderSlot(_ctx.$slots, "header-right", vue.normalizeProps(vue.guardReactiveProps(data)))
                  ]),
                  key: "1"
                } : void 0
              ]),
              1040
              /* FULL_PROPS, DYNAMIC_SLOTS */
            )) : vue.createCommentVNode("v-if", true),
            vue.createVNode(vue.unref(elementPlus.ElContainer), { class: "plus-layout-main-wrapper" }, {
              default: vue.withCtx(() => [
                vue.createCommentVNode(" \u4FA7\u8FB9\u680F "),
                _ctx.hasSidebar ? (vue.openBlock(), vue.createBlock(vue.unref(PlusSidebar$1), vue.mergeProps({ key: 0 }, _ctx.sidebarProps, {
                  ref_key: "plusSidebarInstance",
                  ref: plusSidebarInstance,
                  collapse: collapse.value,
                  "onUpdate:collapse": _cache[0] || (_cache[0] = ($event) => collapse.value = $event)
                }), vue.createSlots({
                  _: 2
                  /* DYNAMIC */
                }, [
                  _ctx.$slots["sidebar-extra"] ? {
                    name: "sidebar-extra",
                    fn: vue.withCtx((data) => [
                      vue.renderSlot(_ctx.$slots, "sidebar-extra", vue.normalizeProps(vue.guardReactiveProps(data)))
                    ]),
                    key: "0"
                  } : void 0,
                  _ctx.$slots["sidebar-item"] ? {
                    name: "sidebar-item",
                    fn: vue.withCtx((data) => [
                      vue.renderSlot(_ctx.$slots, "sidebar-item", vue.normalizeProps(vue.guardReactiveProps(data)))
                    ]),
                    key: "1"
                  } : void 0,
                  _ctx.$slots["sidebar-sub"] ? {
                    name: "sidebar-sub",
                    fn: vue.withCtx((data) => [
                      vue.renderSlot(_ctx.$slots, "sidebar-sub", vue.normalizeProps(vue.guardReactiveProps(data)))
                    ]),
                    key: "2"
                  } : void 0,
                  _ctx.$slots["sidebar-item-title"] ? {
                    name: "sidebar-item-title",
                    fn: vue.withCtx((data) => [
                      vue.renderSlot(_ctx.$slots, "sidebar-item-title", vue.normalizeProps(vue.guardReactiveProps(data)))
                    ]),
                    key: "3"
                  } : void 0
                ]), 1040, ["collapse"])) : vue.createCommentVNode("v-if", true),
                vue.createCommentVNode(" \u4E3B\u5185\u5BB9 "),
                vue.createElementVNode("main", _hoisted_1$2, [
                  vue.createCommentVNode(" \u9762\u5305\u5C51\u4E0A\u65B9 "),
                  _ctx.$slots["layout-extra"] ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$1, [
                    vue.renderSlot(_ctx.$slots, "layout-extra")
                  ])) : vue.createCommentVNode("v-if", true),
                  vue.createCommentVNode(" \u9762\u5305\u5C51 "),
                  _ctx.hasBreadcrumb ? (vue.openBlock(), vue.createBlock(
                    vue.unref(PlusBreadcrumb$1),
                    vue.mergeProps({ key: 1 }, _ctx.breadcrumbProps, {
                      ref_key: "plusBreadcrumbInstance",
                      ref: plusBreadcrumbInstance
                    }),
                    vue.createSlots({
                      _: 2
                      /* DYNAMIC */
                    }, [
                      _ctx.$slots["breadcrumb-item-title"] ? {
                        name: "breadcrumb-item-title",
                        fn: vue.withCtx((data) => [
                          vue.renderSlot(_ctx.$slots, "breadcrumb-item-title", vue.normalizeProps(vue.guardReactiveProps(data)))
                        ]),
                        key: "0"
                      } : void 0
                    ]),
                    1040
                    /* FULL_PROPS, DYNAMIC_SLOTS */
                  )) : vue.createCommentVNode("v-if", true),
                  vue.createVNode(vue.unref(elementPlus.ElMain), {
                    class: "plus-layout-content",
                    style: vue.normalizeStyle({ height: height.value })
                  }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(
                        vue.unref(elementPlus.ElScrollbar),
                        vue.mergeProps({ class: "plus-layout-main__scrollbar" }, _ctx.scrollbarProps),
                        {
                          default: vue.withCtx(() => [
                            vue.createVNode(vue.unref(elementPlus.ElMain), null, {
                              default: vue.withCtx(() => [
                                vue.renderSlot(_ctx.$slots, "default")
                              ]),
                              _: 3
                              /* FORWARDED */
                            }),
                            _ctx.backtop ? (vue.openBlock(), vue.createBlock(
                              vue.unref(elementPlus.ElBacktop),
                              vue.mergeProps({ key: 0 }, backtopProps.value, { target: ".plus-layout .plus-layout-main__scrollbar" }),
                              null,
                              16
                              /* FULL_PROPS */
                            )) : vue.createCommentVNode("v-if", true)
                          ]),
                          _: 3
                          /* FORWARDED */
                        },
                        16
                        /* FULL_PROPS */
                      )
                    ]),
                    _: 3
                    /* FORWARDED */
                  }, 8, ["style"])
                ])
              ]),
              _: 3
              /* FORWARDED */
            })
          ]),
          _: 3
          /* FORWARDED */
        }, 8, ["style", "class"]);
      };
    }
  });

  var Layout = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__file", "index.vue"]]);

  const PlusLayout = Layout;

  const _hoisted_1$1 = { class: "plus-check-card__avatar-wrapper" };
  const _hoisted_2 = { class: "plus-check-card__right-content" };
  const _hoisted_3 = {
    key: 0,
    class: "plus-check-card__title"
  };
  const _hoisted_4 = { class: "plus-check-card__title-left" };
  const _hoisted_5 = {
    key: 1,
    class: "plus-check-card__description"
  };
  var _sfc_main$1 = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusCheckCard"
    },
    __name: "index",
    props: {
      modelValue: { type: Boolean, default: false },
      size: { default: "default" },
      avatar: { type: [String, Function], default: void 0 },
      avatarProps: { default: () => ({}) },
      title: { type: [String, Function], default: void 0 },
      description: { type: [String, Function], default: void 0 },
      disabled: { type: Boolean, default: false },
      extra: { type: Function, default: void 0 }
    },
    emits: ["update:modelValue", "change", "extra"],
    setup(__props, { emit: __emit }) {
      const classDataEnum = {
        large: "plus-check-card--large",
        default: "plus-check-card--default",
        small: "plus-check-card--small"
      };
      const props = __props;
      const emit = __emit;
      const state = vue.reactive({
        checked: false
      });
      vue.watchEffect(() => {
        state.checked = props.modelValue;
      });
      const getClass = () => {
        return props.size ? classDataEnum[props.size] : "plus-check-card--default";
      };
      const handleClick = () => {
        if (props.disabled) return;
        state.checked = !state.checked;
        emit("update:modelValue", state.checked);
        emit("change", state.checked);
      };
      const handelExtra = () => {
        if (props.disabled) return;
        emit("extra");
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock(
          "div",
          {
            class: vue.normalizeClass(["plus-check-card", [
              getClass(),
              state.checked ? "plus-check-card--checked" : "",
              _ctx.disabled ? "plus-check-card--disabled" : ""
            ]]),
            onClick: handleClick
          },
          [
            vue.createElementVNode("div", _hoisted_1$1, [
              vue.unref(isFunction)(_ctx.avatar) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.avatar), {
                key: 0,
                avatar: _ctx.avatar,
                title: _ctx.title,
                description: _ctx.description
              }, null, 8, ["avatar", "title", "description"])) : _ctx.$slots.avatar ? vue.renderSlot(_ctx.$slots, "avatar", {
                key: 1,
                avatar: _ctx.avatar,
                title: _ctx.title,
                description: _ctx.description
              }) : vue.unref(isString)(_ctx.avatar) ? (vue.openBlock(), vue.createBlock(vue.unref(elementPlus.ElAvatar), vue.mergeProps({
                key: 2,
                src: _ctx.avatar
              }, _ctx.avatarProps), null, 16, ["src"])) : vue.createCommentVNode("v-if", true)
            ]),
            vue.createElementVNode("div", _hoisted_2, [
              _ctx.title || _ctx.$slots.title ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3, [
                vue.createElementVNode("div", _hoisted_4, [
                  vue.unref(isFunction)(_ctx.title) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.title), {
                    key: 0,
                    avatar: _ctx.avatar,
                    title: _ctx.title,
                    description: _ctx.description
                  }, null, 8, ["avatar", "title", "description"])) : _ctx.$slots.title ? vue.renderSlot(_ctx.$slots, "title", {
                    key: 1,
                    title: _ctx.title,
                    avatar: _ctx.avatar,
                    description: _ctx.description
                  }) : (vue.openBlock(), vue.createElementBlock(
                    vue.Fragment,
                    { key: 2 },
                    [
                      vue.createTextVNode(
                        vue.toDisplayString(_ctx.title),
                        1
                        /* TEXT */
                      )
                    ],
                    64
                    /* STABLE_FRAGMENT */
                  ))
                ]),
                vue.createElementVNode("div", {
                  class: "plus-check-card__title-right",
                  onClick: vue.withModifiers(handelExtra, ["stop"])
                }, [
                  vue.unref(isFunction)(_ctx.extra) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.extra), {
                    key: 0,
                    avatar: _ctx.avatar,
                    title: _ctx.title,
                    description: _ctx.description
                  }, null, 8, ["avatar", "title", "description"])) : _ctx.$slots.extra ? vue.renderSlot(_ctx.$slots, "extra", {
                    key: 1,
                    title: _ctx.title,
                    avatar: _ctx.avatar,
                    description: _ctx.description
                  }) : vue.createCommentVNode("v-if", true)
                ])
              ])) : vue.createCommentVNode("v-if", true),
              _ctx.description || _ctx.$slots.description ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_5, [
                vue.unref(isFunction)(_ctx.description) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.description), {
                  key: 0,
                  title: _ctx.title,
                  avatar: _ctx.avatar,
                  description: _ctx.description
                }, null, 8, ["title", "avatar", "description"])) : _ctx.$slots.description ? vue.renderSlot(_ctx.$slots, "description", {
                  key: 1,
                  title: _ctx.title,
                  description: _ctx.description,
                  avatar: _ctx.avatar
                }) : (vue.openBlock(), vue.createElementBlock(
                  vue.Fragment,
                  { key: 2 },
                  [
                    vue.createTextVNode(
                      vue.toDisplayString(_ctx.description),
                      1
                      /* TEXT */
                    )
                  ],
                  64
                  /* STABLE_FRAGMENT */
                ))
              ])) : vue.createCommentVNode("v-if", true)
            ])
          ],
          2
          /* CLASS */
        );
      };
    }
  });

  var CheckCard = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__file", "index.vue"]]);

  const PlusCheckCard = CheckCard;

  const _hoisted_1 = { class: "plus-check-card-group" };
  var _sfc_main = /* @__PURE__ */ vue.defineComponent({
    ...{
      name: "PlusCheckCardGroup"
    },
    __name: "index",
    props: {
      modelValue: { default: () => [] },
      options: { default: () => [] },
      size: { default: void 0 },
      disabled: { type: Boolean, default: false },
      multiple: { type: Boolean, default: false }
    },
    emits: ["update:modelValue", "change", "extra"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit = __emit;
      const state = vue.reactive({
        checkList: [],
        checked: ""
      });
      vue.watchEffect(() => {
        if (props.multiple) {
          state.checkList = props.modelValue;
        } else {
          state.checked = props.modelValue;
        }
      });
      const getChecked = (value) => {
        if (props.multiple) {
          return state.checkList.includes(value);
        } else {
          return state.checked === value;
        }
      };
      const handleChange = (model, value) => {
        if (props.multiple) {
          if (model) {
            state.checkList.push(value);
          } else {
            state.checkList = state.checkList.filter((item) => item !== value);
          }
          emit("update:modelValue", state.checkList);
          emit("change", state.checkList);
        } else {
          const val = model ? value : "";
          emit("update:modelValue", val);
          emit("change", val);
        }
      };
      const handleExtra = (item) => {
        if (props.disabled) return;
        emit("extra", item);
      };
      return (_ctx, _cache) => {
        return vue.openBlock(), vue.createElementBlock("div", _hoisted_1, [
          (vue.openBlock(true), vue.createElementBlock(
            vue.Fragment,
            null,
            vue.renderList(_ctx.options, (item, index) => {
              return vue.openBlock(), vue.createBlock(vue.unref(PlusCheckCard), vue.mergeProps({
                key: item.value || index,
                size: _ctx.size,
                disabled: _ctx.disabled
              }, item, {
                "model-value": getChecked(item.value),
                onChange: ($event) => handleChange($event, item.value),
                onExtra: ($event) => handleExtra(item)
              }), vue.createSlots({
                _: 2
                /* DYNAMIC */
              }, [
                _ctx.$slots["avatar-" + item.value] || _ctx.$slots.avatar ? {
                  name: "avatar",
                  fn: vue.withCtx((data) => [
                    _ctx.$slots["avatar-" + item.value] ? vue.renderSlot(_ctx.$slots, "avatar-" + item.value, vue.normalizeProps(vue.mergeProps({ key: 0 }, data))) : vue.createCommentVNode("v-if", true),
                    _ctx.$slots.avatar ? vue.renderSlot(_ctx.$slots, "avatar", vue.normalizeProps(vue.mergeProps({ key: 1 }, data))) : vue.createCommentVNode("v-if", true)
                  ]),
                  key: "0"
                } : void 0,
                _ctx.$slots["title-" + item.value] || _ctx.$slots.title ? {
                  name: "title",
                  fn: vue.withCtx((data) => [
                    _ctx.$slots["title-" + item.value] ? vue.renderSlot(_ctx.$slots, "title-" + item.value, vue.normalizeProps(vue.mergeProps({ key: 0 }, data))) : vue.createCommentVNode("v-if", true),
                    _ctx.$slots.title ? vue.renderSlot(_ctx.$slots, "title", vue.normalizeProps(vue.mergeProps({ key: 1 }, data))) : vue.createCommentVNode("v-if", true)
                  ]),
                  key: "1"
                } : void 0,
                _ctx.$slots["description-" + item.value] || _ctx.$slots.description ? {
                  name: "description",
                  fn: vue.withCtx((data) => [
                    _ctx.$slots["description-" + item.value] ? vue.renderSlot(_ctx.$slots, "description-" + item.value, vue.normalizeProps(vue.mergeProps({ key: 0 }, data))) : vue.createCommentVNode("v-if", true),
                    _ctx.$slots.description ? vue.renderSlot(_ctx.$slots, "description", vue.normalizeProps(vue.mergeProps({ key: 1 }, data))) : vue.createCommentVNode("v-if", true)
                  ]),
                  key: "2"
                } : void 0,
                _ctx.$slots["extra-" + item.value] || _ctx.$slots.extra ? {
                  name: "extra",
                  fn: vue.withCtx((data) => [
                    _ctx.$slots["extra-" + item.value] ? vue.renderSlot(_ctx.$slots, "extra-" + item.value, vue.normalizeProps(vue.mergeProps({ key: 0 }, data))) : vue.createCommentVNode("v-if", true),
                    _ctx.$slots.extra ? vue.renderSlot(_ctx.$slots, "extra", vue.normalizeProps(vue.mergeProps({ key: 1 }, data))) : vue.createCommentVNode("v-if", true)
                  ]),
                  key: "3"
                } : void 0
              ]), 1040, ["size", "disabled", "model-value", "onChange", "onExtra"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ]);
      };
    }
  });

  var CheckCardGroup = /* @__PURE__ */ _export_sfc(_sfc_main, [["__file", "index.vue"]]);

  const PlusCheckCardGroup = CheckCardGroup;

  const plugins = [
    PlusDialog,
    PlusPagination,
    PlusTable,
    PlusRadio,
    PlusDatePicker,
    PlusDescriptions,
    PlusDisplayItem,
    PlusFormItem,
    PlusForm,
    PlusPopover,
    PlusSearch,
    PlusDialogForm,
    PlusDrawerForm,
    PlusPage,
    PlusStepsForm,
    PlusInputTag,
    PlusBreadcrumb,
    PlusSidebar,
    PlusHeader,
    PlusLayout,
    PlusCheckCard,
    PlusCheckCardGroup
  ];

  var installer = makeInstaller([...plugins]);

  const version = "0.1.21";

  const install = installer.install;

  exports.DatePickerValueIsArrayList = DatePickerValueIsArrayList;
  exports.DefaultPageInfo = DefaultPageInfo;
  exports.DefaultPageSizeList = DefaultPageSizeList;
  exports.PlusBreadcrumb = PlusBreadcrumb;
  exports.PlusCheckCard = PlusCheckCard;
  exports.PlusCheckCardGroup = PlusCheckCardGroup;
  exports.PlusDatePicker = PlusDatePicker;
  exports.PlusDescriptions = PlusDescriptions;
  exports.PlusDialog = PlusDialog;
  exports.PlusDialogForm = PlusDialogForm;
  exports.PlusDisplayItem = PlusDisplayItem;
  exports.PlusDrawerForm = PlusDrawerForm;
  exports.PlusForm = PlusForm;
  exports.PlusFormItem = PlusFormItem;
  exports.PlusHeader = PlusHeader;
  exports.PlusInputTag = PlusInputTag;
  exports.PlusLayout = PlusLayout;
  exports.PlusPage = PlusPage;
  exports.PlusPagination = PlusPagination;
  exports.PlusPopover = PlusPopover;
  exports.PlusRadio = PlusRadio;
  exports.PlusSearch = PlusSearch;
  exports.PlusSidebar = PlusSidebar;
  exports.PlusSidebarItem = PlusSidebarItem;
  exports.PlusStepsForm = PlusStepsForm;
  exports.PlusTable = PlusTable;
  exports.TableFormFieldRefInjectionKey = TableFormFieldRefInjectionKey;
  exports.TableFormRefInjectionKey = TableFormRefInjectionKey;
  exports.TableFormRowInfoInjectionKey = TableFormRowInfoInjectionKey;
  exports.ValueIsArrayList = ValueIsArrayList;
  exports.ValueIsBooleanList = ValueIsBooleanList;
  exports.ValueIsNumberList = ValueIsNumberList;
  exports.buildLocaleContext = buildLocaleContext;
  exports.buildTranslator = buildTranslator;
  exports.default = installer;
  exports.getOptionsByOptionsMap = getOptionsByOptionsMap;
  exports.install = install;
  exports.translate = translate;
  exports.useGetOptions = useGetOptions;
  exports.useLocale = useLocale;
  exports.useTable = useTable;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
